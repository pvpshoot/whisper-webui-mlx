OpenAI Codex v0.87.0 (research preview)
--------
workdir: /Users/ivankhokhlov/code/mlx-ui/.
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: xhigh
reasoning summaries: auto
session id: 019be0b9-550a-7f11-8f31-68c05169ce13
--------
user
# WORKER AGENT (3-phase harness)

You are the WORKER in a Planner→Worker→Judge pipeline.
Your job: execute `.agent/plan.md` as written, with minimal scope creep.

Non-interactive run (`codex exec`): do not ask questions. If unclear, make the smallest reasonable assumption and log it.

## Stop conditions
- If `.agent/STOP` exists: append “STOP seen” to `.agent/progress.md` and exit.
- If `.agent/DONE` exists: append “DONE seen” to `.agent/progress.md` and exit.

## Inputs you MUST read
- `.agent/PROJECT.md` (authoritative; includes TEST_CMD/LINT_CMD)
- `AGENTS.md` (repo rules)
- `docs/spec.md`
- `docs/dev.md` (if exists)
- `.agent/plan.md`
- `.agent/judge_feedback.md` (if present)
- `.agent/queue.md`
- `.agent/progress.md`
- `.agent/state.md`

## Core rules
- Implement ONLY the single task in `.agent/plan.md`.
- Do NOT mark tasks done in `.agent/queue.md` (Judge owns that).
- Prefer small, coherent changes. No big refactors unless the task explicitly requires it.
- All network-dependent logic must be best-effort with timeouts and exception handling.
- Bind server to localhost only.
- Queue must be strictly sequential: one job at a time; no parallel transcription runs.
- Never print secrets. If you need to log config, mask tokens.

## Logging
Ensure `.agent/logs/` exists.
Write/overwrite `.agent/worker_report.md` with:
- task id/title
- what changed (bullets)
- files changed (list)
- commands run + result (pass/fail)
- if failure: include a short excerpt of the error and what you think is next

Also append a WORKER entry to `.agent/progress.md` with:
- timestamp
- CODEX_ITERATION
- task id
- test + lint status summary

## Verification (must do)
Run TEST_CMD (from PROJECT.md). Capture output into a file.

Tip: to preserve exit codes with tee:
- use: `bash -lc "set -o pipefail; <TEST_CMD> 2>&1 | tee .agent/logs/test_${CODEX_ITERATION}.log"`

If LINT_CMD is set and command exists, run similarly and capture output:
- `.agent/logs/lint_${CODEX_ITERATION}.log`

If tests fail and you cannot fix quickly:
- write/update `.agent/BLOCKED.md` with exact errors + next steps
- exit (do not thrash)

## Output
Print a short summary:
- what you implemented
- test status
- pointers to worker_report + log files

mcp startup: no servers

thinking
**Preparing to list agent files**

I'm preparing to read and list agent-related files using a search tool to identify relevant files before proceeding further.
exec
/bin/zsh -lc ls in /Users/ivankhokhlov/code/mlx-ui succeeded in 66ms:
AGENTS.md
Makefile
README.md
data
docs
mlx_ui
poetry.lock
pyproject.toml
scripts
tests

thinking
**Checking .agent directory**
exec
/bin/zsh -lc 'ls -a' in /Users/ivankhokhlov/code/mlx-ui succeeded in 100ms:
.
..
.DS_Store
.agent
.git
.gitignore
.pytest_cache
.python-version
.ruff_cache
.venv
AGENTS.md
Makefile
README.md
data
docs
mlx_ui
poetry.lock
pyproject.toml
scripts
tests

thinking
**Reading instructions files**

I'm planning to read the AGENTS file and related instructions to gather necessary details for the task.
exec
/bin/zsh -lc 'cat AGENTS.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 58ms:
# AGENTS.md

This repo is developed using an autonomous loop (Planner → Worker → Judge) driven by `codex exec`.
Because each run starts with limited context, **durable state MUST be stored in `.agent/`**.

## Source of truth
- `.agent/PROJECT.md` — high-level constraints and commands
- `docs/spec.md` — product requirements
- `.agent/queue.md` — backlog (Judge marks tasks done)

## How to run
- Tests: `make test`
- Lint: `make lint`
- Format: `make fmt`
- Run server: `make run`

If Makefile does not exist yet, create it during bootstrap.

## Safety / security rules
- Never touch anything outside the repo root.

thinking
**Checking project config paths**

I need to read configuration files like `.agent/PROJECT` to proceed.
exec
/bin/zsh -lc 'ls .agent' in /Users/ivankhokhlov/code/mlx-ui succeeded in 75ms:
BLOCKED.md
PROJECT.md
judge.md
judge_feedback.md
last_judge.txt
last_planner.txt
last_worker.txt
logs
plan.md
planner.md
progress.md
queue.md
state.md
worker.md
worker_report.md

thinking
**Planning to verify STOP/DONE flags**

I need to confirm how STOP and DONE conditions are handled and will use testing to validate their behavior.
exec
/bin/zsh -lc 'test -f .agent/STOP && echo STOP || true' in /Users/ivankhokhlov/code/mlx-ui succeeded in 90ms:

exec
/bin/zsh -lc 'test -f .agent/DONE && echo DONE || true' in /Users/ivankhokhlov/code/mlx-ui succeeded in 73ms:


thinking
**Listing key project files**

Planning to read essential files like .agent/PROJECT.md, docs/spec, docs/dev (if present), plus plan, judge_feedback, queue, progress, and state for comprehensive context.
exec
/bin/zsh -lc 'cat .agent/PROJECT.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 100ms:
# PROJECT (single source of truth for the harness)

PROJECT_NAME: "whisper-webui-mlx"
REPO_KIND: "new repo"

## Brief (1–2 paragraphs)
Build a **local macOS app for Apple Silicon (M1+)** that exposes a **Web UI on localhost** to manage **offline transcription** of audio/video files using the engine from `whisper-turbo-mlx` via its CLI `wtm` (MLX). https://github.com/JosefAlbers/whisper-turbo-mlx

Turn the current console workflow (e.g. `wtm ... --any_lang=True`) into a tool that is easy to deploy on another M1+ Mac with **one command**, supports **batch uploads**, a **strictly sequential** processing queue (no parallelism), **job history + downloads**, optional **Telegram delivery of TXT results**, and (in the final phase) **live recording + chunked transcription**.

## Primary stack
Python 3.11+
- Backend/Web: FastAPI + Uvicorn
- Templates/UI: Jinja2 + minimal vanilla JS (no external CDNs; must work offline)
- Storage: SQLite (jobs metadata) + local filesystem (uploads/results/logs)
- Worker: a single sequential worker consuming a persistent queue
- Transcription: subprocess call to `wtm` with explicit language selection

## Commands (choose defaults if unknown)
TEST_CMD: "make test"

thinking
**Noting missing documentation**

The docs/spec.md file and possibly related documentation are missing and need to be added.
exec
/bin/zsh -lc 'cat docs/spec.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 76ms:
# Spec — whisper-webui-mlx

## Goal
Create a **local-only** tool for **macOS Apple Silicon (M1+)** that provides a **Web UI on localhost** to manage **local transcription** of audio/video files using the engine from `whisper-turbo-mlx` via its CLI `wtm` (MLX).

The tool must be easy to deploy to another M1+ Mac (one command), and after the initial setup + model download it must work **fully offline**.

## MVP: Batch file transcription via Web UI
### UX
- User opens Web UI (localhost).
- User uploads **one or multiple files** (audio or video).
- User selects the **language manually** (no auto-detect).
- Files are placed into a **queue** and processed **strictly sequentially** (no parallel jobs).
- UI has:
  - Queue view: current job + pending jobs
  - History view: completed jobs + access to results

### Processing rules
- One worker processes one job at a time (sequential).
- Keep the ML model “warm” behavior in mind: avoid parallelism and avoid reinitialization churn.

thinking
**Checking for docs/dev.md**
exec
/bin/zsh -lc 'test -f docs/dev.md && cat docs/dev.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 103ms:
# Developer guide

## Requirements (target)
- macOS Apple Silicon (M1+)
- Python 3.11+
- Homebrew (for system deps like ffmpeg)

## Quick start (eventual)
```bash
./scripts/setup_and_run.sh
```
Notes:
- Requires Homebrew (for ffmpeg), Python 3.11+, and Poetry (the script installs missing deps via Homebrew).
- First run needs network access to install `whisper-turbo-mlx` and download the default model.
- Set `SKIP_MODEL_DOWNLOAD=1` to skip prefetching weights (not recommended).

## Manual dev loop
```bash
poetry install --with dev


thinking
**Identifying missing plan file**
exec
/bin/zsh -lc 'cat .agent/plan.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 90ms:
# Plan

Task: WUI-050 - Update check at startup
Acceptance: if online, checks for updates with timeout; if offline, no errors and app works

Assumptions:
- Update check can use a GitHub releases endpoint derived from git remote or UPDATE_CHECK_URL override.
- No UI changes are required beyond logging.

Implementation steps:
1) Add mlx_ui/update_check.py with helpers to resolve the update URL, read the local version, and expose check_for_updates(timeout=...).
2) Implement check_for_updates to fetch the latest version with a short timeout, compare to local, and log a concise message; swallow all network errors.
3) Trigger the update check from app startup in a daemon thread; allow disabling via DISABLE_UPDATE_CHECK=1.
4) Add tests for URL resolution, offline/URLError handling (no exception), and update check logging behavior.
5) Update docs to mention the update check and env overrides if missing.

Files likely to touch:
- mlx_ui/update_check.py
- mlx_ui/app.py
- tests/test_update_check.py

thinking
**Requesting judge feedback components**
exec
/bin/zsh -lc 'cat .agent/judge_feedback.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 96ms:
PASS

Notes:
- `make test` passed (rerun).
- Acceptance criteria met for WUI-040.
exec
/bin/zsh -lc 'cat .agent/queue.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 63ms:
# Queue

## Now
- [ ] WUI-050 — Update check at startup (acceptance: if online, checks for updates with timeout; if offline, no errors and app works)

## Next

## Later
- [ ] WUI-090 — Live mode skeleton (acceptance: UI has “Live” page stub + technical plan in docs; no implementation yet)

## Done
- [x] WUI-040 — Telegram delivery (acceptance: when env vars are set, send TXT + message; failures do not break pipeline; secrets masked)
- [x] WUI-030 — One-command setup & run on M1+ macOS (acceptance: `./scripts/setup_and_run.sh` installs deps, downloads models, starts server, and opens browser)
- [x] WUI-021 — Results browsing + download (acceptance: history page shows per-job links to view/download TXT and other generated formats)
- [x] WUI-020 — Integrate `wtm` CLI transcription (acceptance: for a job, system runs `wtm` with chosen language and produces at least `.txt` in `data/results/<job_id>/`)
- [x] WUI-012 — Sequential worker + fake transcriber (acceptance: single worker processes jobs strictly one-at-a-time; tests do not require ML model)
- [x] WUI-011 — Persistent job store (SQLite) (acceptance: jobs survive server restart; history page lists prior jobs)
- [x] WUI-010 — Upload endpoint + local storage (acceptance: user can upload multiple files; files saved under `data/uploads/` and jobs are created)
- [x] WUI-002 — Minimal WebUI shell (acceptance: localhost page renders with tabs: Queue + History, using server-side templates)
- [x] WUI-001A — Fix pytest availability for `make test` (acceptance: `make test` succeeds in a clean env by ensuring pytest is installed or Makefile uses Poetry/venv)
exec
/bin/zsh -lc 'cat .agent/progress.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 84ms:
# Progress Log (append-only)

- 2026-01-21T09:49:08 — INIT — Harness files created. Next: run the 3-phase loop.
- 2026-01-21T10:33:08Z — PLANNER — CODEX_ITERATION=1 — selected WUI-001 (Bootstrap repo skeleton). Queue unchanged.
- 2026-01-21T10:37:23Z — WORKER — CODEX_ITERATION=1 — WUI-001 — tests: failed (pytest missing); lint: not run
- 2026-01-21T10:39:53Z — JUDGE — CODEX_ITERATION=1 — NEEDS_WORK — make test failed (pytest missing in venv); tests: failed (make test)
- 2026-01-21T10:42:24Z — PLANNER — CODEX_ITERATION=2 — selected WUI-001A (Fix pytest availability for `make test`). Queue updated (format fix for WUI-001A).
- 2026-01-21T10:49:11Z — WORKER — CODEX_ITERATION=2 — WUI-001A — tests: passed (make test); lint: passed (make lint)
- 2026-01-21T10:52:47Z — JUDGE — CODEX_ITERATION=2 — PASS — acceptance met; tests: passed (make test); lint: passed (make lint)
- 2026-01-21T10:56:28Z — PLANNER — CODEX_ITERATION=3 — selected WUI-001 (Bootstrap repo skeleton). Queue unchanged.
- 2026-01-21T10:58:25Z — WORKER — CODEX_ITERATION=3 — WUI-001 — tests: passed (make test); lint: passed (make lint)
- 2026-01-21T11:01:51Z — JUDGE — CODEX_ITERATION=3 — PASS — acceptance met; tests: passed (make test); lint: passed (make lint)
- 2026-01-21T11:05:17Z — PLANNER — CODEX_ITERATION=4 — selected WUI-002 (Minimal WebUI shell). Queue unchanged.
- 2026-01-21T11:11:48Z — WORKER — CODEX_ITERATION=4 — WUI-002 — tests: passed (make test); lint: passed (make lint)
- 2026-01-21T11:16:13Z — JUDGE — CODEX_ITERATION=4 — PASS — acceptance met; tests: passed (make test); lint: passed (make lint)
- 2026-01-21T11:23:27Z — PLANNER — CODEX_ITERATION=5 — selected WUI-010 (Upload endpoint + local storage). Queue updated (moved WUI-010 to Now).
- 2026-01-21T11:33:16Z — WORKER — CODEX_ITERATION=5 — WUI-010 — tests: passed (make test); lint: passed (make lint)
- 2026-01-21T11:37:21Z — JUDGE — CODEX_ITERATION=5 — PASS — acceptance met; tests: passed (make test); lint: not rerun (worker reported pass)
- 2026-01-21T11:41:40Z — PLANNER — CODEX_ITERATION=6 — selected WUI-011 (Persistent job store (SQLite)). Queue updated (moved WUI-011 to Now).
- 2026-01-21T11:48:06Z — WORKER — CODEX_ITERATION=6 — WUI-011 — tests: passed (make test); lint: passed (make lint)

thinking
**Identifying need for state management**
exec
/bin/zsh -lc 'cat .agent/state.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 106ms:
last_task_id: WUI-040
last_verdict: PASS
consecutive_failures: 0

thinking
**Inspecting UI package for update check**
exec
/bin/zsh -lc 'rg --files mlx_ui' in /Users/ivankhokhlov/code/mlx-ui succeeded in 71ms:
mlx_ui/templates/index.html
mlx_ui/app.py
mlx_ui/__init__.py
mlx_ui/telegram.py
mlx_ui/transcriber.py
mlx_ui/db.py
mlx_ui/worker.py

thinking
**Opening main application file**
exec
/bin/zsh -lc "sed -n '1,200p' mlx_ui/app.py" in /Users/ivankhokhlov/code/mlx-ui succeeded in 79ms:
from datetime import datetime, timezone
from pathlib import Path
import shutil
from uuid import uuid4

from fastapi import FastAPI, File, HTTPException, Request, UploadFile
from fastapi.responses import FileResponse, HTMLResponse
from fastapi.templating import Jinja2Templates

from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
from mlx_ui.worker import start_worker

app = FastAPI(title="Whisper WebUI (MLX)")
templates = Jinja2Templates(directory=str(Path(__file__).resolve().parent / "templates"))
BASE_DIR = Path(__file__).resolve().parent.parent
DEFAULT_UPLOADS_DIR = BASE_DIR / "data" / "uploads"
DEFAULT_RESULTS_DIR = BASE_DIR / "data" / "results"
DEFAULT_DB_PATH = BASE_DIR / "data" / "jobs.db"
app.state.uploads_dir = DEFAULT_UPLOADS_DIR
app.state.results_dir = DEFAULT_RESULTS_DIR

thinking
**Planning module creation and startup integration**
exec
/bin/zsh -lc "sed -n '1,200p' mlx_ui/worker.py" in /Users/ivankhokhlov/code/mlx-ui succeeded in 74ms:
from __future__ import annotations

import logging
from pathlib import Path
import threading

from mlx_ui.db import claim_next_job, update_job_status
from mlx_ui.telegram import maybe_send_telegram
from mlx_ui.transcriber import Transcriber, WtmTranscriber

logger = logging.getLogger(__name__)

_worker_lock = threading.Lock()
_worker_instance: Worker | None = None


class Worker:
    def __init__(
        self,
        db_path: Path,

thinking
**Scoping update check sources**

I'm identifying the update check module and checking the transcriber and telegram components for relevant patterns to monitor updates.
exec
/bin/zsh -lc "sed -n '1,200p' mlx_ui/transcriber.py" in /Users/ivankhokhlov/code/mlx-ui succeeded in 62ms:
import logging
import os
from pathlib import Path
import subprocess
from typing import Protocol

from mlx_ui.db import JobRecord

logger = logging.getLogger(__name__)


class Transcriber(Protocol):
    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
        raise NotImplementedError


class FakeTranscriber:
    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
        results_dir = Path(results_dir)
        job_dir = results_dir / job.id
exec
/bin/zsh -lc "sed -n '1,200p' mlx_ui/telegram.py" in /Users/ivankhokhlov/code/mlx-ui succeeded in 57ms:
from dataclasses import dataclass
import logging
import mimetypes
import os
from pathlib import Path
import urllib.error
import urllib.parse
import urllib.request
import uuid

from mlx_ui.db import JobRecord

logger = logging.getLogger(__name__)

DEFAULT_TIMEOUT = 10.0


@dataclass(frozen=True)
class TelegramConfig:
    token: str

thinking
**Reviewing network patterns and init**
exec
/bin/zsh -lc "sed -n '1,200p' mlx_ui/__init__.py" in /Users/ivankhokhlov/code/mlx-ui succeeded in 91ms:


thinking
**Planning docs/tree update**

I need to check the docs/tree.md file and update it to reflect the new file since the repo structure is changing. Next, I'll view and edit that file accordingly.
exec
/bin/zsh -lc 'cat docs/tree.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 61ms:
# Project tree (curated)

This file is a human-maintained map of the repo. Update when structure changes.

## Current (bootstrap)
- `.agent/` — durable loop state + prompts
- `data/` — runtime uploads/results/logs/jobs.db (created on demand)
- `docs/` — spec + dev notes + this tree map
- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
- `mlx_ui/templates/` — Jinja2 templates
- `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
- `Makefile` — dev commands
- `pyproject.toml` — dependencies and tooling
- `README.md` — repo overview

thinking
**Noting new file addition**

A new file update_check.py and its test were added in mlx_ui; next step is to review existing tests for pattern consistency.
exec
/bin/zsh -lc 'rg --files tests' in /Users/ivankhokhlov/code/mlx-ui succeeded in 93ms:
tests/test_app.py
tests/test_worker.py
tests/__init__.py
tests/test_transcriber.py
tests/test_telegram.py
exec
/bin/zsh -lc "sed -n '1,200p' tests/test_app.py" in /Users/ivankhokhlov/code/mlx-ui succeeded in 101ms:
from datetime import datetime, timezone
from pathlib import Path

from fastapi.testclient import TestClient

from mlx_ui.app import app
from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs


def _configure_app(tmp_path: Path) -> None:
    app.state.uploads_dir = tmp_path / "uploads"
    app.state.results_dir = tmp_path / "results"
    app.state.db_path = tmp_path / "jobs.db"
    app.state.worker_enabled = False


def test_root_ok(tmp_path: Path) -> None:
    _configure_app(tmp_path)
    with TestClient(app) as client:
        response = client.get("/")

thinking
**Checking test patterns**
exec
/bin/zsh -lc "sed -n '1,200p' tests/test_telegram.py" in /Users/ivankhokhlov/code/mlx-ui succeeded in 74ms:
import logging
from pathlib import Path
import urllib.error
import urllib.request

from mlx_ui.db import JobRecord
from mlx_ui.telegram import maybe_send_telegram, mask_secret


class DummyResponse:
    def __init__(self, status: int = 200, body: bytes | None = None) -> None:
        self._status = status
        self._body = body or b"ok"

    def read(self) -> bytes:
        return self._body

    def getcode(self) -> int:
        return self._status


thinking
**Reviewing test patterns for updates**
exec
/bin/zsh -lc "sed -n '1,200p' tests/test_worker.py" in /Users/ivankhokhlov/code/mlx-ui succeeded in 87ms:
from datetime import datetime, timedelta, timezone
from pathlib import Path
import threading
import time

from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
from mlx_ui.worker import start_worker, stop_worker


class RecordingTranscriber:
    def __init__(self) -> None:
        self._lock = threading.Lock()
        self._active = False
        self.concurrent_detected = False
        self.seen: list[str] = []

    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
        with self._lock:
            if self._active:
                self.concurrent_detected = True

thinking
**Searching for update check logic**
exec
/bin/zsh -lc 'rg -n "version|__version__|update" mlx_ui docs README.md pyproject.toml' in /Users/ivankhokhlov/code/mlx-ui succeeded in 83ms:
pyproject.toml:3:version = "0.1.0"
docs/spec.md:50:- Transcribe in chunks (target ~10s+) and incrementally update UI with plain text.
docs/spec.md:56:- Offline: after initial setup/models, app works offline; network-only features (Telegram/update check) must degrade gracefully.
docs/spec.md:58:- Update check: on startup, if network is available, check for updates (best-effort; must never break offline operation).
mlx_ui/db.py:64:def update_job_status(db_path: Path, job_id: str, status: str) -> None:
docs/dev.md:34:- Keep network usage optional and best-effort (Telegram, update check).
mlx_ui/worker.py:7:from mlx_ui.db import claim_next_job, update_job_status
mlx_ui/worker.py:66:            update_job_status(self.db_path, job.id, "failed")
mlx_ui/worker.py:72:        update_job_status(self.db_path, job.id, "done")

thinking
**Assessing version retrieval method**

I'm weighing using importlib.metadata to read the installed package version versus parsing pyproject.toml directly, noting the app may not always be installed but might be via poetry during development.
exec
/bin/zsh -lc "sed -n '1,200p' pyproject.toml" in /Users/ivankhokhlov/code/mlx-ui succeeded in 93ms:
[tool.poetry]
name = "mlx-ui"
version = "0.1.0"
description = ""
authors = ["Ivan Khokhlov <ivan.s.khokhlov@rt.ru>"]
readme = "README.md"

[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.115.6"
jinja2 = "^3.1.4"
uvicorn = "^0.32.1"
python-multipart = "^0.0.21"

[tool.poetry.group.dev.dependencies]
httpx = "^0.28.1"
pytest = "^8.3.4"
ruff = "^0.14.13"



thinking
**Checking package availability for tests**

I'm considering using `importlib.metadata.version("mlx-ui")` to get the package version but suspect it might not be installed during tests. I'll check the Makefile to confirm if tests run inside poetry, which would ensure the package is available.
exec
/bin/zsh -lc 'cat Makefile' in /Users/ivankhokhlov/code/mlx-ui succeeded in 71ms:
PYTHON ?= python
POETRY ?= poetry
POETRY_RUN ?= $(POETRY) run

.PHONY: test lint fmt run

test:
	$(POETRY_RUN) pytest

lint:
	$(POETRY_RUN) ruff check .

fmt:
	$(POETRY_RUN) ruff format .

run:
	$(POETRY_RUN) uvicorn mlx_ui.app:app --host 127.0.0.1 --port 8000


thinking
**Designing update check module**

I'm planning an update_check module that resolves the update URL (from env or git remote), reads the local version (fallback to pyproject if needed), fetches the latest version with a timeout, compares versions, logs results, and swallows network errors. The check runs on app startup in a daemon thread, can be disabled via environment variable, and will have tests and doc updates.
thinking
**Detailing update check implementation plan**

I mapped out functions to resolve the update URL (env override or parsing git remote), read the local version (importlib.metadata or fallback parsing pyproject.toml), fetch and compare the latest release version from GitHub API with timeout, and log concise update status while swallowing network errors. Tests will cover URL resolution, offline error handling, and logging behavior. The check runs in a daemon thread on app startup, disabled via environment variable. Documentation updates will reflect these features in dev docs.
exec
/bin/zsh -lc "sed -n '1,200p' README.md" in /Users/ivankhokhlov/code/mlx-ui succeeded in 57ms:
# whisper-webui-mlx (agent harness bootstrap)

This repo currently contains the **3-phase Codex harness** (Planner → Worker → Judge) to build a local macOS (M1+) WebUI around `whisper-turbo-mlx` / `wtm`.

## One-command setup (macOS M1+)
```bash
./scripts/setup_and_run.sh
```
Notes: Homebrew is required; first run needs network access to install deps and download the model.

## Quick start (app)
Run the minimal FastAPI app on localhost:
```bash
make run
```

## Tests and lint
```bash
make test
make lint

thinking
**Checking logging setup and docs**

I'm verifying that the `.agent/logs/` directory exists or is created as needed and planning updates to docs and tests for the new update check module. I'll also confirm packaging uses `ruff` and reconsider changes to `__init__`.
exec
/bin/zsh -lc 'ls .agent/logs' in /Users/ivankhokhlov/code/mlx-ui succeeded in 90ms:
judge_1.err
judge_1.out
judge_10.err
judge_10.out
judge_11.err
judge_11.out
judge_2.err
judge_2.out
judge_3.err
judge_3.out
judge_4.err
judge_4.out
judge_5.err
judge_5.out
judge_6.err
judge_6.out
judge_7.err
judge_7.out
judge_8.err
judge_8.out

thinking
**Checking iteration number source**

I'm verifying if the iteration number is set via environment variables like CODEX_ITERATION to use for log file naming, planning to confirm this by inspecting the environment.
exec
/bin/zsh -lc 'echo $CODEX_ITERATION' in /Users/ivankhokhlov/code/mlx-ui succeeded in 61ms:
12


thinking
**Outlining update check design**

Drafting update_check.py to include env-based toggle, resolving update URL by checking env or git remote, extracting GitHub repo info for releases URL, and reading local version via importlib.metadata, with careful subprocess handling and short network timeouts.
thinking
**Designing version reading and update comparison**

Drafted reading local version from package metadata or pyproject.toml, parsing and comparing semantic versions by numeric parts only, and fetching latest GitHub release tag from update URL with short timeout. Also planned concise logging for update status and environment-based disabling of update checks.
exec
/bin/zsh -lc 'git config --get remote.origin.url' in /Users/ivankhokhlov/code/mlx-ui exited 1 in 57ms:




thinking
**Considering update check behavior in tests**

Noting that the update check thread can safely run in tests without network by quickly returning if no update URL is found, and suggesting a short timeout (around 1 second) to keep tests responsive even if the network is blocked.
thinking
**Designing comprehensive update check tests and integration**

Planning detailed tests for update URL resolution, offline handling, and logging behavior using monkeypatch and caplog, while designing update check module functions to accept customizable env and remote inputs for testability, plus integrating a daemon update check thread in app startup guarded by environment and app state flags with a 2-second timeout default.
thinking
**Refining update check tests and documentation updates**

Finalizing concise tests for logging update availability and offline error handling by patching relevant functions, designing resolve_update_url to accept env parameters, and planning to update dev docs with environment variable guidance for controlling update checks.
file update
A /Users/ivankhokhlov/code/mlx-ui/./mlx_ui/update_check.py
from __future__ import annotations

import importlib.metadata
import json
import logging
import os
from pathlib import Path
import re
import subprocess
import urllib.error
import urllib.parse
import urllib.request
from typing import Mapping

import tomllib

logger = logging.getLogger(__name__)

DEFAULT_TIMEOUT = 2.0
UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"

_BASE_DIR = Path(__file__).resolve().parent.parent


def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
    env = env or os.environ
    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
    return value in {"1", "true", "yes", "on"}


def resolve_update_url(
    env: Mapping[str, str] | None = None,
    remote_url: str | None = None,
) -> str | None:
    env = env or os.environ
    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
    if override:
        return override
    if remote_url is None:
        remote_url = get_git_remote_url()
    if not remote_url:
        return None
    return _github_releases_url(remote_url)


def get_git_remote_url() -> str | None:
    try:
        result = subprocess.run(
            ["git", "config", "--get", "remote.origin.url"],
            capture_output=True,
            text=True,
            check=True,
            cwd=_BASE_DIR,
        )
    except (FileNotFoundError, subprocess.CalledProcessError):
        return None
    remote = result.stdout.strip()
    return remote or None


def read_local_version() -> str | None:
    try:
        return importlib.metadata.version("mlx-ui")
    except importlib.metadata.PackageNotFoundError:
        return _read_version_from_pyproject()


def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
    local_version = read_local_version()
    if not local_version:
        logger.debug("Update check skipped: local version unavailable.")
        return

    update_url = resolve_update_url()
    if not update_url:
        logger.debug("Update check skipped: no update URL available.")
        return

    try:
        latest_version = _fetch_latest_version(update_url, timeout)
    except Exception as exc:
        logger.debug("Update check failed: %s", exc.__class__.__name__)
        return

    if not latest_version:
        logger.debug("Update check failed: no version returned.")
        return

    comparison = _compare_versions(local_version, latest_version)
    if comparison is None:
        if _normalize_version(local_version) == _normalize_version(latest_version):
            logger.info(
                "Update check: current version %s is up to date.",
                local_version,
            )
        else:
            logger.info("Update available: %s -> %s", local_version, latest_version)
        return

    if comparison < 0:
        logger.info("Update available: %s -> %s", local_version, latest_version)
    elif comparison == 0:
        logger.info(
            "Update check: current version %s is up to date.",
            local_version,
        )
    else:
        logger.info(
            "Update check: local version %s is newer than latest %s.",
            local_version,
            latest_version,
        )


def _github_releases_url(remote_url: str) -> str | None:
    repo = _extract_github_repo(remote_url)
    if not repo:
        return None
    owner, name = repo
    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"


def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
    remote_url = remote_url.strip()
    if not remote_url:
        return None

    if remote_url.startswith("git@github.com:"):
        path = remote_url.split(":", 1)[1]
    else:
        parsed = urllib.parse.urlparse(remote_url)
        if parsed.netloc != "github.com":
            return None
        path = parsed.path.lstrip("/")

    parts = [part for part in path.split("/") if part]
    if len(parts) < 2:
        return None
    owner = parts[0]
    repo = parts[1]
    if repo.endswith(".git"):
        repo = repo[: -len(".git")]
    if not owner or not repo:
        return None
    return owner, repo


def _read_version_from_pyproject() -> str | None:
    pyproject_path = _BASE_DIR / "pyproject.toml"
    if not pyproject_path.is_file():
        return None
    try:
        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
    except Exception:
        return None
    version = data.get("tool", {}).get("poetry", {}).get("version")
    if not isinstance(version, str):
        return None
    version = version.strip()
    return version or None


def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
    request = urllib.request.Request(
        update_url,
        headers={
            "Accept": "application/vnd.github+json",
            "User-Agent": "mlx-ui-update-check",
        },
    )
    with urllib.request.urlopen(request, timeout=timeout) as response:
        payload = response.read()
    try:
        data = json.loads(payload)
    except json.JSONDecodeError:
        return None
    tag = data.get("tag_name") or data.get("name")
    if not tag:
        return None
    return str(tag).strip()


def _compare_versions(local: str, latest: str) -> int | None:
    local_parts = _parse_version(local)
    latest_parts = _parse_version(latest)
    if local_parts is None or latest_parts is None:
        return None
    max_len = max(len(local_parts), len(latest_parts))
    local_parts += (0,) * (max_len - len(local_parts))
    latest_parts += (0,) * (max_len - len(latest_parts))
    if local_parts < latest_parts:
        return -1
    if local_parts > latest_parts:
        return 1
    return 0


def _parse_version(value: str) -> tuple[int, ...] | None:
    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
    if not match:
        return None
    try:
        return tuple(int(part) for part in match.group(1).split("."))
    except ValueError:
        return None


def _normalize_version(value: str) -> str:
    return value.strip().lstrip("v")
apply_patch(auto_approved=true) exited 0 in 22ms:
Success. Updated the following files:
A mlx_ui/update_check.py
file update:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..302e686fa0a79f8d2821acf4958931379b17edd6
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,210 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.error
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    env = env or os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    env = env or os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")

file update:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..302e686fa0a79f8d2821acf4958931379b17edd6
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,210 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.error
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    env = env or os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    env = env or os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")


thinking
**Removing unused urllib.error import**
file update
M /Users/ivankhokhlov/code/mlx-ui/./mlx_ui/update_check.py
@@ -9,3 +9,2 @@
 import subprocess
-import urllib.error
 import urllib.parse
apply_patch(auto_approved=true) exited 0 in 17ms:
Success. Updated the following files:
M mlx_ui/update_check.py
file update:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..774f01136a95030f2999968a4fced5e11a2090d4
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,209 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    env = env or os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    env = env or os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")

file update:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..774f01136a95030f2999968a4fced5e11a2090d4
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,209 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    env = env or os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    env = env or os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")


thinking
**Integrating update check in app startup**

I'm modifying app.py to import threading and update check utilities, adding an app state flag for update check enabling, and launching the update check thread during app startup after worker initialization.
file update
M /Users/ivankhokhlov/code/mlx-ui/./mlx_ui/app.py
@@ -3,2 +3,3 @@
 import shutil
+import threading
 from uuid import uuid4
@@ -10,2 +11,3 @@
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
@@ -22,2 +24,3 @@
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
@@ -29,2 +32,13 @@
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
apply_patch(auto_approved=true) exited 0 in 26ms:
Success. Updated the following files:
M mlx_ui/app.py
file update:
diff --git a/mlx_ui/app.py b/mlx_ui/app.py
index dd65c6065ad4525881b170522c84bcdb5d063fcf..52ea7856986eae8e4fe8a62616c3e435c80695fd
--- a/mlx_ui/app.py
+++ b/mlx_ui/app.py
@@ -1,6 +1,7 @@
 from datetime import datetime, timezone
 from pathlib import Path
 import shutil
+import threading
 from uuid import uuid4
 
 from fastapi import FastAPI, File, HTTPException, Request, UploadFile
@@ -8,6 +9,7 @@
 from fastapi.templating import Jinja2Templates
 
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
 
 app = FastAPI(title="Whisper WebUI (MLX)")
@@ -20,6 +22,7 @@
 app.state.results_dir = DEFAULT_RESULTS_DIR
 app.state.db_path = DEFAULT_DB_PATH
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
 
 @app.on_event("startup")
@@ -27,6 +30,17 @@
     init_db(get_db_path())
     if getattr(app.state, "worker_enabled", True):
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
 
 def get_job_store() -> list[JobRecord]:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..774f01136a95030f2999968a4fced5e11a2090d4
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,209 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    env = env or os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    env = env or os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")

file update:
diff --git a/mlx_ui/app.py b/mlx_ui/app.py
index dd65c6065ad4525881b170522c84bcdb5d063fcf..52ea7856986eae8e4fe8a62616c3e435c80695fd
--- a/mlx_ui/app.py
+++ b/mlx_ui/app.py
@@ -1,6 +1,7 @@
 from datetime import datetime, timezone
 from pathlib import Path
 import shutil
+import threading
 from uuid import uuid4
 
 from fastapi import FastAPI, File, HTTPException, Request, UploadFile
@@ -8,6 +9,7 @@
 from fastapi.templating import Jinja2Templates
 
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
 
 app = FastAPI(title="Whisper WebUI (MLX)")
@@ -20,6 +22,7 @@
 app.state.results_dir = DEFAULT_RESULTS_DIR
 app.state.db_path = DEFAULT_DB_PATH
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
 
 @app.on_event("startup")
@@ -27,6 +30,17 @@
     init_db(get_db_path())
     if getattr(app.state, "worker_enabled", True):
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
 
 def get_job_store() -> list[JobRecord]:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..774f01136a95030f2999968a4fced5e11a2090d4
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,209 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    env = env or os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    env = env or os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")


thinking
**Disabling update check in tests**

Decided to set update check disabled in app config during tests to avoid unnecessary background network activity, since update check is covered by separate tests. Next, I'll patch tests/test_app.py accordingly.
file update
M /Users/ivankhokhlov/code/mlx-ui/./tests/test_app.py
@@ -14,2 +14,3 @@
     app.state.worker_enabled = False
+    app.state.update_check_enabled = False
 
apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M tests/test_app.py
file update:
diff --git a/mlx_ui/app.py b/mlx_ui/app.py
index dd65c6065ad4525881b170522c84bcdb5d063fcf..52ea7856986eae8e4fe8a62616c3e435c80695fd
--- a/mlx_ui/app.py
+++ b/mlx_ui/app.py
@@ -1,6 +1,7 @@
 from datetime import datetime, timezone
 from pathlib import Path
 import shutil
+import threading
 from uuid import uuid4
 
 from fastapi import FastAPI, File, HTTPException, Request, UploadFile
@@ -8,6 +9,7 @@
 from fastapi.templating import Jinja2Templates
 
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
 
 app = FastAPI(title="Whisper WebUI (MLX)")
@@ -20,6 +22,7 @@
 app.state.results_dir = DEFAULT_RESULTS_DIR
 app.state.db_path = DEFAULT_DB_PATH
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
 
 @app.on_event("startup")
@@ -27,6 +30,17 @@
     init_db(get_db_path())
     if getattr(app.state, "worker_enabled", True):
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
 
 def get_job_store() -> list[JobRecord]:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..774f01136a95030f2999968a4fced5e11a2090d4
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,209 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    env = env or os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    env = env or os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")
diff --git a/tests/test_app.py b/tests/test_app.py
index 21abb10479f7ea2afcf3d372db776286935ecf9b..f763e505a4cec14f1d1e1c03135dde409fd16623
--- a/tests/test_app.py
+++ b/tests/test_app.py
@@ -12,6 +12,7 @@
     app.state.results_dir = tmp_path / "results"
     app.state.db_path = tmp_path / "jobs.db"
     app.state.worker_enabled = False
+    app.state.update_check_enabled = False
 
 
 def test_root_ok(tmp_path: Path) -> None:

file update:
diff --git a/mlx_ui/app.py b/mlx_ui/app.py
index dd65c6065ad4525881b170522c84bcdb5d063fcf..52ea7856986eae8e4fe8a62616c3e435c80695fd
--- a/mlx_ui/app.py
+++ b/mlx_ui/app.py
@@ -1,6 +1,7 @@
 from datetime import datetime, timezone
 from pathlib import Path
 import shutil
+import threading
 from uuid import uuid4
 
 from fastapi import FastAPI, File, HTTPException, Request, UploadFile
@@ -8,6 +9,7 @@
 from fastapi.templating import Jinja2Templates
 
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
 
 app = FastAPI(title="Whisper WebUI (MLX)")
@@ -20,6 +22,7 @@
 app.state.results_dir = DEFAULT_RESULTS_DIR
 app.state.db_path = DEFAULT_DB_PATH
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
 
 @app.on_event("startup")
@@ -27,6 +30,17 @@
     init_db(get_db_path())
     if getattr(app.state, "worker_enabled", True):
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
 
 def get_job_store() -> list[JobRecord]:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..774f01136a95030f2999968a4fced5e11a2090d4
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,209 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    env = env or os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    env = env or os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")
diff --git a/tests/test_app.py b/tests/test_app.py
index 21abb10479f7ea2afcf3d372db776286935ecf9b..f763e505a4cec14f1d1e1c03135dde409fd16623
--- a/tests/test_app.py
+++ b/tests/test_app.py
@@ -12,6 +12,7 @@
     app.state.results_dir = tmp_path / "results"
     app.state.db_path = tmp_path / "jobs.db"
     app.state.worker_enabled = False
+    app.state.update_check_enabled = False
 
 
 def test_root_ok(tmp_path: Path) -> None:



thinking
**Choosing import style for tests**

Decided to import the update_check module using `from mlx_ui import update_check` for clearer patching and function access in the test file.
thinking
**Identifying env default bug in update_check**

Discovered that passing an empty dict as env wrongly falls back to os.environ due to using `env = env or os.environ`. Planning to fix `resolve_update_url` and `is_update_check_disabled` to check `if env is None` instead, preserving empty dict behavior for tests.
file update
M /Users/ivankhokhlov/code/mlx-ui/./mlx_ui/update_check.py
@@ -25,3 +25,4 @@
 def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
-    env = env or os.environ
+    if env is None:
+        env = os.environ
     value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
@@ -34,3 +35,4 @@
 ) -> str | None:
-    env = env or os.environ
+    if env is None:
+        env = os.environ
     override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
apply_patch(auto_approved=true) exited 0 in 36ms:
Success. Updated the following files:
M mlx_ui/update_check.py
file update:
diff --git a/mlx_ui/app.py b/mlx_ui/app.py
index dd65c6065ad4525881b170522c84bcdb5d063fcf..52ea7856986eae8e4fe8a62616c3e435c80695fd
--- a/mlx_ui/app.py
+++ b/mlx_ui/app.py
@@ -1,6 +1,7 @@
 from datetime import datetime, timezone
 from pathlib import Path
 import shutil
+import threading
 from uuid import uuid4
 
 from fastapi import FastAPI, File, HTTPException, Request, UploadFile
@@ -8,6 +9,7 @@
 from fastapi.templating import Jinja2Templates
 
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
 
 app = FastAPI(title="Whisper WebUI (MLX)")
@@ -20,6 +22,7 @@
 app.state.results_dir = DEFAULT_RESULTS_DIR
 app.state.db_path = DEFAULT_DB_PATH
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
 
 @app.on_event("startup")
@@ -27,6 +30,17 @@
     init_db(get_db_path())
     if getattr(app.state, "worker_enabled", True):
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
 
 def get_job_store() -> list[JobRecord]:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..144f1ea22991d258bb315d3270f7e841325e6a56
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,211 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    if env is None:
+        env = os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    if env is None:
+        env = os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")
diff --git a/tests/test_app.py b/tests/test_app.py
index 21abb10479f7ea2afcf3d372db776286935ecf9b..f763e505a4cec14f1d1e1c03135dde409fd16623
--- a/tests/test_app.py
+++ b/tests/test_app.py
@@ -12,6 +12,7 @@
     app.state.results_dir = tmp_path / "results"
     app.state.db_path = tmp_path / "jobs.db"
     app.state.worker_enabled = False
+    app.state.update_check_enabled = False
 
 
 def test_root_ok(tmp_path: Path) -> None:

file update:
diff --git a/mlx_ui/app.py b/mlx_ui/app.py
index dd65c6065ad4525881b170522c84bcdb5d063fcf..52ea7856986eae8e4fe8a62616c3e435c80695fd
--- a/mlx_ui/app.py
+++ b/mlx_ui/app.py
@@ -1,6 +1,7 @@
 from datetime import datetime, timezone
 from pathlib import Path
 import shutil
+import threading
 from uuid import uuid4
 
 from fastapi import FastAPI, File, HTTPException, Request, UploadFile
@@ -8,6 +9,7 @@
 from fastapi.templating import Jinja2Templates
 
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
 
 app = FastAPI(title="Whisper WebUI (MLX)")
@@ -20,6 +22,7 @@
 app.state.results_dir = DEFAULT_RESULTS_DIR
 app.state.db_path = DEFAULT_DB_PATH
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
 
 @app.on_event("startup")
@@ -27,6 +30,17 @@
     init_db(get_db_path())
     if getattr(app.state, "worker_enabled", True):
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
 
 def get_job_store() -> list[JobRecord]:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..144f1ea22991d258bb315d3270f7e841325e6a56
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,211 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    if env is None:
+        env = os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    if env is None:
+        env = os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")
diff --git a/tests/test_app.py b/tests/test_app.py
index 21abb10479f7ea2afcf3d372db776286935ecf9b..f763e505a4cec14f1d1e1c03135dde409fd16623
--- a/tests/test_app.py
+++ b/tests/test_app.py
@@ -12,6 +12,7 @@
     app.state.results_dir = tmp_path / "results"
     app.state.db_path = tmp_path / "jobs.db"
     app.state.worker_enabled = False
+    app.state.update_check_enabled = False
 
 
 def test_root_ok(tmp_path: Path) -> None:


thinking
**Adding test file**

Tests now run successfully with an empty environment configuration, so I'm adding the corresponding test file.
file update
A /Users/ivankhokhlov/code/mlx-ui/./tests/test_update_check.py
import logging
import urllib.error
import urllib.request

from mlx_ui import update_check


def test_resolve_update_url_prefers_override() -> None:
    env = {update_check.UPDATE_CHECK_URL_ENV: "https://example.com/override"}
    url = update_check.resolve_update_url(
        env=env,
        remote_url="https://github.com/example/repo.git",
    )

    assert url == "https://example.com/override"


def test_resolve_update_url_from_github_remote() -> None:
    env: dict[str, str] = {}
    url = update_check.resolve_update_url(
        env=env,
        remote_url="git@github.com:octo/repo.git",
    )

    assert url == "https://api.github.com/repos/octo/repo/releases/latest"


def test_check_for_updates_handles_urlerror(monkeypatch) -> None:
    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
    monkeypatch.setattr(
        update_check,
        "resolve_update_url",
        lambda *args, **kwargs: "https://example.com",
    )

    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
        raise urllib.error.URLError("offline")

    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)

    update_check.check_for_updates(timeout=0.01)


def test_check_for_updates_logs_available(monkeypatch, caplog) -> None:
    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
    monkeypatch.setattr(
        update_check,
        "resolve_update_url",
        lambda *args, **kwargs: "https://example.com",
    )
    monkeypatch.setattr(
        update_check,
        "_fetch_latest_version",
        lambda *args, **kwargs: "0.2.0",
    )

    caplog.set_level(logging.INFO, logger="mlx_ui.update_check")

    update_check.check_for_updates(timeout=0.01)

    assert "Update available" in caplog.text
    assert "0.1.0" in caplog.text
    assert "0.2.0" in caplog.text
apply_patch(auto_approved=true) exited 0 in 43ms:
Success. Updated the following files:
A tests/test_update_check.py
file update:
diff --git a/mlx_ui/app.py b/mlx_ui/app.py
index dd65c6065ad4525881b170522c84bcdb5d063fcf..52ea7856986eae8e4fe8a62616c3e435c80695fd
--- a/mlx_ui/app.py
+++ b/mlx_ui/app.py
@@ -1,6 +1,7 @@
 from datetime import datetime, timezone
 from pathlib import Path
 import shutil
+import threading
 from uuid import uuid4
 
 from fastapi import FastAPI, File, HTTPException, Request, UploadFile
@@ -8,6 +9,7 @@
 from fastapi.templating import Jinja2Templates
 
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
 
 app = FastAPI(title="Whisper WebUI (MLX)")
@@ -20,6 +22,7 @@
 app.state.results_dir = DEFAULT_RESULTS_DIR
 app.state.db_path = DEFAULT_DB_PATH
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
 
 @app.on_event("startup")
@@ -27,6 +30,17 @@
     init_db(get_db_path())
     if getattr(app.state, "worker_enabled", True):
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
 
 def get_job_store() -> list[JobRecord]:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..144f1ea22991d258bb315d3270f7e841325e6a56
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,211 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    if env is None:
+        env = os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    if env is None:
+        env = os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")
diff --git a/tests/test_app.py b/tests/test_app.py
index 21abb10479f7ea2afcf3d372db776286935ecf9b..f763e505a4cec14f1d1e1c03135dde409fd16623
--- a/tests/test_app.py
+++ b/tests/test_app.py
@@ -12,6 +12,7 @@
     app.state.results_dir = tmp_path / "results"
     app.state.db_path = tmp_path / "jobs.db"
     app.state.worker_enabled = False
+    app.state.update_check_enabled = False
 
 
 def test_root_ok(tmp_path: Path) -> None:
diff --git a/tests/test_update_check.py b/tests/test_update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..ab8ee98b6ca62def4341bec4d0697fd401a40049
--- /dev/null
+++ b/tests/test_update_check.py
@@ -0,0 +1,63 @@
+import logging
+import urllib.error
+import urllib.request
+
+from mlx_ui import update_check
+
+
+def test_resolve_update_url_prefers_override() -> None:
+    env = {update_check.UPDATE_CHECK_URL_ENV: "https://example.com/override"}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="https://github.com/example/repo.git",
+    )
+
+    assert url == "https://example.com/override"
+
+
+def test_resolve_update_url_from_github_remote() -> None:
+    env: dict[str, str] = {}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="git@github.com:octo/repo.git",
+    )
+
+    assert url == "https://api.github.com/repos/octo/repo/releases/latest"
+
+
+def test_check_for_updates_handles_urlerror(monkeypatch) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("offline")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    update_check.check_for_updates(timeout=0.01)
+
+
+def test_check_for_updates_logs_available(monkeypatch, caplog) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+    monkeypatch.setattr(
+        update_check,
+        "_fetch_latest_version",
+        lambda *args, **kwargs: "0.2.0",
+    )
+
+    caplog.set_level(logging.INFO, logger="mlx_ui.update_check")
+
+    update_check.check_for_updates(timeout=0.01)
+
+    assert "Update available" in caplog.text
+    assert "0.1.0" in caplog.text
+    assert "0.2.0" in caplog.text

file update:
diff --git a/mlx_ui/app.py b/mlx_ui/app.py
index dd65c6065ad4525881b170522c84bcdb5d063fcf..52ea7856986eae8e4fe8a62616c3e435c80695fd
--- a/mlx_ui/app.py
+++ b/mlx_ui/app.py
@@ -1,6 +1,7 @@
 from datetime import datetime, timezone
 from pathlib import Path
 import shutil
+import threading
 from uuid import uuid4
 
 from fastapi import FastAPI, File, HTTPException, Request, UploadFile
@@ -8,6 +9,7 @@
 from fastapi.templating import Jinja2Templates
 
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
 
 app = FastAPI(title="Whisper WebUI (MLX)")
@@ -20,6 +22,7 @@
 app.state.results_dir = DEFAULT_RESULTS_DIR
 app.state.db_path = DEFAULT_DB_PATH
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
 
 @app.on_event("startup")
@@ -27,6 +30,17 @@
     init_db(get_db_path())
     if getattr(app.state, "worker_enabled", True):
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
 
 def get_job_store() -> list[JobRecord]:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..144f1ea22991d258bb315d3270f7e841325e6a56
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,211 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    if env is None:
+        env = os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    if env is None:
+        env = os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")
diff --git a/tests/test_app.py b/tests/test_app.py
index 21abb10479f7ea2afcf3d372db776286935ecf9b..f763e505a4cec14f1d1e1c03135dde409fd16623
--- a/tests/test_app.py
+++ b/tests/test_app.py
@@ -12,6 +12,7 @@
     app.state.results_dir = tmp_path / "results"
     app.state.db_path = tmp_path / "jobs.db"
     app.state.worker_enabled = False
+    app.state.update_check_enabled = False
 
 
 def test_root_ok(tmp_path: Path) -> None:
diff --git a/tests/test_update_check.py b/tests/test_update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..ab8ee98b6ca62def4341bec4d0697fd401a40049
--- /dev/null
+++ b/tests/test_update_check.py
@@ -0,0 +1,63 @@
+import logging
+import urllib.error
+import urllib.request
+
+from mlx_ui import update_check
+
+
+def test_resolve_update_url_prefers_override() -> None:
+    env = {update_check.UPDATE_CHECK_URL_ENV: "https://example.com/override"}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="https://github.com/example/repo.git",
+    )
+
+    assert url == "https://example.com/override"
+
+
+def test_resolve_update_url_from_github_remote() -> None:
+    env: dict[str, str] = {}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="git@github.com:octo/repo.git",
+    )
+
+    assert url == "https://api.github.com/repos/octo/repo/releases/latest"
+
+
+def test_check_for_updates_handles_urlerror(monkeypatch) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("offline")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    update_check.check_for_updates(timeout=0.01)
+
+
+def test_check_for_updates_logs_available(monkeypatch, caplog) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+    monkeypatch.setattr(
+        update_check,
+        "_fetch_latest_version",
+        lambda *args, **kwargs: "0.2.0",
+    )
+
+    caplog.set_level(logging.INFO, logger="mlx_ui.update_check")
+
+    update_check.check_for_updates(timeout=0.01)
+
+    assert "Update available" in caplog.text
+    assert "0.1.0" in caplog.text
+    assert "0.2.0" in caplog.text


thinking
**Updating docs with update check note**

I'll add a bullet to the "Notes" section in docs/dev.md describing the update check change and ensure linting catches any unused imports after modifications.
file update
M /Users/ivankhokhlov/code/mlx-ui/./docs/dev.md
@@ -34,2 +34,3 @@
 - Keep network usage optional and best-effort (Telegram, update check).
+- Update check runs at startup; set `DISABLE_UPDATE_CHECK=1` to skip or `UPDATE_CHECK_URL` to override the releases endpoint.
 - Prefer tests that do not require the real ML model; mock `wtm` execution.
apply_patch(auto_approved=true) exited 0 in 44ms:
Success. Updated the following files:
M docs/dev.md
file update:
diff --git a/docs/dev.md b/docs/dev.md
index 2d90cc01c5e94c77008a87189476a0dbb6a217d0..821cd61662fde764a1e220f187e2160b21a966df
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -32,4 +32,5 @@
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
+- Update check runs at startup; set `DISABLE_UPDATE_CHECK=1` to skip or `UPDATE_CHECK_URL` to override the releases endpoint.
 - Prefer tests that do not require the real ML model; mock `wtm` execution.
diff --git a/mlx_ui/app.py b/mlx_ui/app.py
index dd65c6065ad4525881b170522c84bcdb5d063fcf..52ea7856986eae8e4fe8a62616c3e435c80695fd
--- a/mlx_ui/app.py
+++ b/mlx_ui/app.py
@@ -1,6 +1,7 @@
 from datetime import datetime, timezone
 from pathlib import Path
 import shutil
+import threading
 from uuid import uuid4
 
 from fastapi import FastAPI, File, HTTPException, Request, UploadFile
@@ -8,6 +9,7 @@
 from fastapi.templating import Jinja2Templates
 
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
 
 app = FastAPI(title="Whisper WebUI (MLX)")
@@ -20,6 +22,7 @@
 app.state.results_dir = DEFAULT_RESULTS_DIR
 app.state.db_path = DEFAULT_DB_PATH
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
 
 @app.on_event("startup")
@@ -27,6 +30,17 @@
     init_db(get_db_path())
     if getattr(app.state, "worker_enabled", True):
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
 
 def get_job_store() -> list[JobRecord]:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..144f1ea22991d258bb315d3270f7e841325e6a56
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,211 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    if env is None:
+        env = os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    if env is None:
+        env = os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")
diff --git a/tests/test_app.py b/tests/test_app.py
index 21abb10479f7ea2afcf3d372db776286935ecf9b..f763e505a4cec14f1d1e1c03135dde409fd16623
--- a/tests/test_app.py
+++ b/tests/test_app.py
@@ -12,6 +12,7 @@
     app.state.results_dir = tmp_path / "results"
     app.state.db_path = tmp_path / "jobs.db"
     app.state.worker_enabled = False
+    app.state.update_check_enabled = False
 
 
 def test_root_ok(tmp_path: Path) -> None:
diff --git a/tests/test_update_check.py b/tests/test_update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..ab8ee98b6ca62def4341bec4d0697fd401a40049
--- /dev/null
+++ b/tests/test_update_check.py
@@ -0,0 +1,63 @@
+import logging
+import urllib.error
+import urllib.request
+
+from mlx_ui import update_check
+
+
+def test_resolve_update_url_prefers_override() -> None:
+    env = {update_check.UPDATE_CHECK_URL_ENV: "https://example.com/override"}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="https://github.com/example/repo.git",
+    )
+
+    assert url == "https://example.com/override"
+
+
+def test_resolve_update_url_from_github_remote() -> None:
+    env: dict[str, str] = {}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="git@github.com:octo/repo.git",
+    )
+
+    assert url == "https://api.github.com/repos/octo/repo/releases/latest"
+
+
+def test_check_for_updates_handles_urlerror(monkeypatch) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("offline")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    update_check.check_for_updates(timeout=0.01)
+
+
+def test_check_for_updates_logs_available(monkeypatch, caplog) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+    monkeypatch.setattr(
+        update_check,
+        "_fetch_latest_version",
+        lambda *args, **kwargs: "0.2.0",
+    )
+
+    caplog.set_level(logging.INFO, logger="mlx_ui.update_check")
+
+    update_check.check_for_updates(timeout=0.01)
+
+    assert "Update available" in caplog.text
+    assert "0.1.0" in caplog.text
+    assert "0.2.0" in caplog.text

file update:
diff --git a/docs/dev.md b/docs/dev.md
index 2d90cc01c5e94c77008a87189476a0dbb6a217d0..821cd61662fde764a1e220f187e2160b21a966df
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -32,4 +32,5 @@
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
+- Update check runs at startup; set `DISABLE_UPDATE_CHECK=1` to skip or `UPDATE_CHECK_URL` to override the releases endpoint.
 - Prefer tests that do not require the real ML model; mock `wtm` execution.
diff --git a/mlx_ui/app.py b/mlx_ui/app.py
index dd65c6065ad4525881b170522c84bcdb5d063fcf..52ea7856986eae8e4fe8a62616c3e435c80695fd
--- a/mlx_ui/app.py
+++ b/mlx_ui/app.py
@@ -1,6 +1,7 @@
 from datetime import datetime, timezone
 from pathlib import Path
 import shutil
+import threading
 from uuid import uuid4
 
 from fastapi import FastAPI, File, HTTPException, Request, UploadFile
@@ -8,6 +9,7 @@
 from fastapi.templating import Jinja2Templates
 
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
 
 app = FastAPI(title="Whisper WebUI (MLX)")
@@ -20,6 +22,7 @@
 app.state.results_dir = DEFAULT_RESULTS_DIR
 app.state.db_path = DEFAULT_DB_PATH
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
 
 @app.on_event("startup")
@@ -27,6 +30,17 @@
     init_db(get_db_path())
     if getattr(app.state, "worker_enabled", True):
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
 
 def get_job_store() -> list[JobRecord]:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..144f1ea22991d258bb315d3270f7e841325e6a56
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,211 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    if env is None:
+        env = os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    if env is None:
+        env = os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")
diff --git a/tests/test_app.py b/tests/test_app.py
index 21abb10479f7ea2afcf3d372db776286935ecf9b..f763e505a4cec14f1d1e1c03135dde409fd16623
--- a/tests/test_app.py
+++ b/tests/test_app.py
@@ -12,6 +12,7 @@
     app.state.results_dir = tmp_path / "results"
     app.state.db_path = tmp_path / "jobs.db"
     app.state.worker_enabled = False
+    app.state.update_check_enabled = False
 
 
 def test_root_ok(tmp_path: Path) -> None:
diff --git a/tests/test_update_check.py b/tests/test_update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..ab8ee98b6ca62def4341bec4d0697fd401a40049
--- /dev/null
+++ b/tests/test_update_check.py
@@ -0,0 +1,63 @@
+import logging
+import urllib.error
+import urllib.request
+
+from mlx_ui import update_check
+
+
+def test_resolve_update_url_prefers_override() -> None:
+    env = {update_check.UPDATE_CHECK_URL_ENV: "https://example.com/override"}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="https://github.com/example/repo.git",
+    )
+
+    assert url == "https://example.com/override"
+
+
+def test_resolve_update_url_from_github_remote() -> None:
+    env: dict[str, str] = {}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="git@github.com:octo/repo.git",
+    )
+
+    assert url == "https://api.github.com/repos/octo/repo/releases/latest"
+
+
+def test_check_for_updates_handles_urlerror(monkeypatch) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("offline")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    update_check.check_for_updates(timeout=0.01)
+
+
+def test_check_for_updates_logs_available(monkeypatch, caplog) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+    monkeypatch.setattr(
+        update_check,
+        "_fetch_latest_version",
+        lambda *args, **kwargs: "0.2.0",
+    )
+
+    caplog.set_level(logging.INFO, logger="mlx_ui.update_check")
+
+    update_check.check_for_updates(timeout=0.01)
+
+    assert "Update available" in caplog.text
+    assert "0.1.0" in caplog.text
+    assert "0.2.0" in caplog.text


thinking
**Updating documentation for new file and test**

I'm updating docs/tree.md to add update_check.py under mlx_ui and include test_update_check in the tests list, reflecting the new additions accurately.
file update
M /Users/ivankhokhlov/code/mlx-ui/./docs/tree.md
@@ -8,6 +8,6 @@
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`, `update_check.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`, `test_update_check.py`)
 - `Makefile` — dev commands
apply_patch(auto_approved=true) exited 0 in 55ms:
Success. Updated the following files:
M docs/tree.md
file update:
diff --git a/docs/dev.md b/docs/dev.md
index 2d90cc01c5e94c77008a87189476a0dbb6a217d0..821cd61662fde764a1e220f187e2160b21a966df
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -32,4 +32,5 @@
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
+- Update check runs at startup; set `DISABLE_UPDATE_CHECK=1` to skip or `UPDATE_CHECK_URL` to override the releases endpoint.
 - Prefer tests that do not require the real ML model; mock `wtm` execution.
diff --git a/docs/tree.md b/docs/tree.md
index 958a35c4cc32a984f0ef063c2ddd59b5f976404a..c96333ac02235457d28ca299f84b19a7ba212724
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`, `update_check.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`, `test_update_check.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/app.py b/mlx_ui/app.py
index dd65c6065ad4525881b170522c84bcdb5d063fcf..52ea7856986eae8e4fe8a62616c3e435c80695fd
--- a/mlx_ui/app.py
+++ b/mlx_ui/app.py
@@ -1,6 +1,7 @@
 from datetime import datetime, timezone
 from pathlib import Path
 import shutil
+import threading
 from uuid import uuid4
 
 from fastapi import FastAPI, File, HTTPException, Request, UploadFile
@@ -8,6 +9,7 @@
 from fastapi.templating import Jinja2Templates
 
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
 
 app = FastAPI(title="Whisper WebUI (MLX)")
@@ -20,6 +22,7 @@
 app.state.results_dir = DEFAULT_RESULTS_DIR
 app.state.db_path = DEFAULT_DB_PATH
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
 
 @app.on_event("startup")
@@ -27,6 +30,17 @@
     init_db(get_db_path())
     if getattr(app.state, "worker_enabled", True):
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
 
 def get_job_store() -> list[JobRecord]:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..144f1ea22991d258bb315d3270f7e841325e6a56
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,211 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    if env is None:
+        env = os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    if env is None:
+        env = os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")
diff --git a/tests/test_app.py b/tests/test_app.py
index 21abb10479f7ea2afcf3d372db776286935ecf9b..f763e505a4cec14f1d1e1c03135dde409fd16623
--- a/tests/test_app.py
+++ b/tests/test_app.py
@@ -12,6 +12,7 @@
     app.state.results_dir = tmp_path / "results"
     app.state.db_path = tmp_path / "jobs.db"
     app.state.worker_enabled = False
+    app.state.update_check_enabled = False
 
 
 def test_root_ok(tmp_path: Path) -> None:
diff --git a/tests/test_update_check.py b/tests/test_update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..ab8ee98b6ca62def4341bec4d0697fd401a40049
--- /dev/null
+++ b/tests/test_update_check.py
@@ -0,0 +1,63 @@
+import logging
+import urllib.error
+import urllib.request
+
+from mlx_ui import update_check
+
+
+def test_resolve_update_url_prefers_override() -> None:
+    env = {update_check.UPDATE_CHECK_URL_ENV: "https://example.com/override"}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="https://github.com/example/repo.git",
+    )
+
+    assert url == "https://example.com/override"
+
+
+def test_resolve_update_url_from_github_remote() -> None:
+    env: dict[str, str] = {}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="git@github.com:octo/repo.git",
+    )
+
+    assert url == "https://api.github.com/repos/octo/repo/releases/latest"
+
+
+def test_check_for_updates_handles_urlerror(monkeypatch) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("offline")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    update_check.check_for_updates(timeout=0.01)
+
+
+def test_check_for_updates_logs_available(monkeypatch, caplog) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+    monkeypatch.setattr(
+        update_check,
+        "_fetch_latest_version",
+        lambda *args, **kwargs: "0.2.0",
+    )
+
+    caplog.set_level(logging.INFO, logger="mlx_ui.update_check")
+
+    update_check.check_for_updates(timeout=0.01)
+
+    assert "Update available" in caplog.text
+    assert "0.1.0" in caplog.text
+    assert "0.2.0" in caplog.text

file update:
diff --git a/docs/dev.md b/docs/dev.md
index 2d90cc01c5e94c77008a87189476a0dbb6a217d0..821cd61662fde764a1e220f187e2160b21a966df
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -32,4 +32,5 @@
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
+- Update check runs at startup; set `DISABLE_UPDATE_CHECK=1` to skip or `UPDATE_CHECK_URL` to override the releases endpoint.
 - Prefer tests that do not require the real ML model; mock `wtm` execution.
diff --git a/docs/tree.md b/docs/tree.md
index 958a35c4cc32a984f0ef063c2ddd59b5f976404a..c96333ac02235457d28ca299f84b19a7ba212724
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`, `update_check.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`, `test_update_check.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/app.py b/mlx_ui/app.py
index dd65c6065ad4525881b170522c84bcdb5d063fcf..52ea7856986eae8e4fe8a62616c3e435c80695fd
--- a/mlx_ui/app.py
+++ b/mlx_ui/app.py
@@ -1,6 +1,7 @@
 from datetime import datetime, timezone
 from pathlib import Path
 import shutil
+import threading
 from uuid import uuid4
 
 from fastapi import FastAPI, File, HTTPException, Request, UploadFile
@@ -8,6 +9,7 @@
 from fastapi.templating import Jinja2Templates
 
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
 
 app = FastAPI(title="Whisper WebUI (MLX)")
@@ -20,6 +22,7 @@
 app.state.results_dir = DEFAULT_RESULTS_DIR
 app.state.db_path = DEFAULT_DB_PATH
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
 
 @app.on_event("startup")
@@ -27,6 +30,17 @@
     init_db(get_db_path())
     if getattr(app.state, "worker_enabled", True):
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
 
 def get_job_store() -> list[JobRecord]:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..144f1ea22991d258bb315d3270f7e841325e6a56
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,211 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    if env is None:
+        env = os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    if env is None:
+        env = os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")
diff --git a/tests/test_app.py b/tests/test_app.py
index 21abb10479f7ea2afcf3d372db776286935ecf9b..f763e505a4cec14f1d1e1c03135dde409fd16623
--- a/tests/test_app.py
+++ b/tests/test_app.py
@@ -12,6 +12,7 @@
     app.state.results_dir = tmp_path / "results"
     app.state.db_path = tmp_path / "jobs.db"
     app.state.worker_enabled = False
+    app.state.update_check_enabled = False
 
 
 def test_root_ok(tmp_path: Path) -> None:
diff --git a/tests/test_update_check.py b/tests/test_update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..ab8ee98b6ca62def4341bec4d0697fd401a40049
--- /dev/null
+++ b/tests/test_update_check.py
@@ -0,0 +1,63 @@
+import logging
+import urllib.error
+import urllib.request
+
+from mlx_ui import update_check
+
+
+def test_resolve_update_url_prefers_override() -> None:
+    env = {update_check.UPDATE_CHECK_URL_ENV: "https://example.com/override"}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="https://github.com/example/repo.git",
+    )
+
+    assert url == "https://example.com/override"
+
+
+def test_resolve_update_url_from_github_remote() -> None:
+    env: dict[str, str] = {}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="git@github.com:octo/repo.git",
+    )
+
+    assert url == "https://api.github.com/repos/octo/repo/releases/latest"
+
+
+def test_check_for_updates_handles_urlerror(monkeypatch) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("offline")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    update_check.check_for_updates(timeout=0.01)
+
+
+def test_check_for_updates_logs_available(monkeypatch, caplog) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+    monkeypatch.setattr(
+        update_check,
+        "_fetch_latest_version",
+        lambda *args, **kwargs: "0.2.0",
+    )
+
+    caplog.set_level(logging.INFO, logger="mlx_ui.update_check")
+
+    update_check.check_for_updates(timeout=0.01)
+
+    assert "Update available" in caplog.text
+    assert "0.1.0" in caplog.text
+    assert "0.2.0" in caplog.text



thinking
**Improving GitHub repo URL parsing**

Planning to update the remote URL check to accept any netloc ending with "github.com" (like "git@github.com") to handle SSH URLs more robustly without breaking existing cases.
thinking
**Preparing to run tests and lint**

Planning to run tests and lint using make commands, capturing logs, and verifying the update_check module for style issues before relying on lint results.
exec
/bin/zsh -lc 'bash -lc "set -o pipefail; make test 2>&1 | tee .agent/logs/test_12.log"' in /Users/ivankhokhlov/code/mlx-ui succeeded in 1.30s:
poetry run pytest
============================= test session starts ==============================
platform darwin -- Python 3.12.12, pytest-8.4.2, pluggy-1.6.0
rootdir: /Users/ivankhokhlov/code/mlx-ui
configfile: pyproject.toml
plugins: anyio-4.12.1
collected 13 items

tests/test_app.py ....                                                   [ 30%]
tests/test_telegram.py ...                                               [ 53%]
tests/test_transcriber.py .                                              [ 61%]
tests/test_update_check.py ....                                          [ 92%]
tests/test_worker.py .                                                   [100%]

=============================== warnings summary ===============================
mlx_ui/app.py:28
  /Users/ivankhokhlov/code/mlx-ui/mlx_ui/app.py:28: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
file update:
diff --git a/docs/dev.md b/docs/dev.md
index 2d90cc01c5e94c77008a87189476a0dbb6a217d0..821cd61662fde764a1e220f187e2160b21a966df
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -32,4 +32,5 @@
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
+- Update check runs at startup; set `DISABLE_UPDATE_CHECK=1` to skip or `UPDATE_CHECK_URL` to override the releases endpoint.
 - Prefer tests that do not require the real ML model; mock `wtm` execution.
diff --git a/docs/tree.md b/docs/tree.md
index 958a35c4cc32a984f0ef063c2ddd59b5f976404a..c96333ac02235457d28ca299f84b19a7ba212724
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`, `update_check.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`, `test_update_check.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/app.py b/mlx_ui/app.py
index dd65c6065ad4525881b170522c84bcdb5d063fcf..52ea7856986eae8e4fe8a62616c3e435c80695fd
--- a/mlx_ui/app.py
+++ b/mlx_ui/app.py
@@ -1,6 +1,7 @@
 from datetime import datetime, timezone
 from pathlib import Path
 import shutil
+import threading
 from uuid import uuid4
 
 from fastapi import FastAPI, File, HTTPException, Request, UploadFile
@@ -8,6 +9,7 @@
 from fastapi.templating import Jinja2Templates
 
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
 
 app = FastAPI(title="Whisper WebUI (MLX)")
@@ -20,6 +22,7 @@
 app.state.results_dir = DEFAULT_RESULTS_DIR
 app.state.db_path = DEFAULT_DB_PATH
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
 
 @app.on_event("startup")
@@ -27,6 +30,17 @@
     init_db(get_db_path())
     if getattr(app.state, "worker_enabled", True):
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
 
 def get_job_store() -> list[JobRecord]:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..144f1ea22991d258bb315d3270f7e841325e6a56
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,211 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    if env is None:
+        env = os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    if env is None:
+        env = os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")
diff --git a/tests/test_app.py b/tests/test_app.py
index 21abb10479f7ea2afcf3d372db776286935ecf9b..f763e505a4cec14f1d1e1c03135dde409fd16623
--- a/tests/test_app.py
+++ b/tests/test_app.py
@@ -12,6 +12,7 @@
     app.state.results_dir = tmp_path / "results"
     app.state.db_path = tmp_path / "jobs.db"
     app.state.worker_enabled = False
+    app.state.update_check_enabled = False
 
 
 def test_root_ok(tmp_path: Path) -> None:
diff --git a/tests/test_update_check.py b/tests/test_update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..ab8ee98b6ca62def4341bec4d0697fd401a40049
--- /dev/null
+++ b/tests/test_update_check.py
@@ -0,0 +1,63 @@
+import logging
+import urllib.error
+import urllib.request
+
+from mlx_ui import update_check
+
+
+def test_resolve_update_url_prefers_override() -> None:
+    env = {update_check.UPDATE_CHECK_URL_ENV: "https://example.com/override"}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="https://github.com/example/repo.git",
+    )
+
+    assert url == "https://example.com/override"
+
+
+def test_resolve_update_url_from_github_remote() -> None:
+    env: dict[str, str] = {}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="git@github.com:octo/repo.git",
+    )
+
+    assert url == "https://api.github.com/repos/octo/repo/releases/latest"
+
+
+def test_check_for_updates_handles_urlerror(monkeypatch) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("offline")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    update_check.check_for_updates(timeout=0.01)
+
+
+def test_check_for_updates_logs_available(monkeypatch, caplog) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+    monkeypatch.setattr(
+        update_check,
+        "_fetch_latest_version",
+        lambda *args, **kwargs: "0.2.0",
+    )
+
+    caplog.set_level(logging.INFO, logger="mlx_ui.update_check")
+
+    update_check.check_for_updates(timeout=0.01)
+
+    assert "Update available" in caplog.text
+    assert "0.1.0" in caplog.text
+    assert "0.2.0" in caplog.text


thinking
**Running lint checks**
exec
/bin/zsh -lc 'bash -lc "set -o pipefail; make lint 2>&1 | tee .agent/logs/lint_12.log"' in /Users/ivankhokhlov/code/mlx-ui succeeded in 667ms:
poetry run ruff check .
All checks passed!
file update:
diff --git a/docs/dev.md b/docs/dev.md
index 2d90cc01c5e94c77008a87189476a0dbb6a217d0..821cd61662fde764a1e220f187e2160b21a966df
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -32,4 +32,5 @@
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
+- Update check runs at startup; set `DISABLE_UPDATE_CHECK=1` to skip or `UPDATE_CHECK_URL` to override the releases endpoint.
 - Prefer tests that do not require the real ML model; mock `wtm` execution.
diff --git a/docs/tree.md b/docs/tree.md
index 958a35c4cc32a984f0ef063c2ddd59b5f976404a..c96333ac02235457d28ca299f84b19a7ba212724
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`, `update_check.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`, `test_update_check.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/app.py b/mlx_ui/app.py
index dd65c6065ad4525881b170522c84bcdb5d063fcf..52ea7856986eae8e4fe8a62616c3e435c80695fd
--- a/mlx_ui/app.py
+++ b/mlx_ui/app.py
@@ -1,6 +1,7 @@
 from datetime import datetime, timezone
 from pathlib import Path
 import shutil
+import threading
 from uuid import uuid4
 
 from fastapi import FastAPI, File, HTTPException, Request, UploadFile
@@ -8,6 +9,7 @@
 from fastapi.templating import Jinja2Templates
 
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
 
 app = FastAPI(title="Whisper WebUI (MLX)")
@@ -20,6 +22,7 @@
 app.state.results_dir = DEFAULT_RESULTS_DIR
 app.state.db_path = DEFAULT_DB_PATH
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
 
 @app.on_event("startup")
@@ -27,6 +30,17 @@
     init_db(get_db_path())
     if getattr(app.state, "worker_enabled", True):
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
 
 def get_job_store() -> list[JobRecord]:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..144f1ea22991d258bb315d3270f7e841325e6a56
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,211 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    if env is None:
+        env = os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    if env is None:
+        env = os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")
diff --git a/tests/test_app.py b/tests/test_app.py
index 21abb10479f7ea2afcf3d372db776286935ecf9b..f763e505a4cec14f1d1e1c03135dde409fd16623
--- a/tests/test_app.py
+++ b/tests/test_app.py
@@ -12,6 +12,7 @@
     app.state.results_dir = tmp_path / "results"
     app.state.db_path = tmp_path / "jobs.db"
     app.state.worker_enabled = False
+    app.state.update_check_enabled = False
 
 
 def test_root_ok(tmp_path: Path) -> None:
diff --git a/tests/test_update_check.py b/tests/test_update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..ab8ee98b6ca62def4341bec4d0697fd401a40049
--- /dev/null
+++ b/tests/test_update_check.py
@@ -0,0 +1,63 @@
+import logging
+import urllib.error
+import urllib.request
+
+from mlx_ui import update_check
+
+
+def test_resolve_update_url_prefers_override() -> None:
+    env = {update_check.UPDATE_CHECK_URL_ENV: "https://example.com/override"}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="https://github.com/example/repo.git",
+    )
+
+    assert url == "https://example.com/override"
+
+
+def test_resolve_update_url_from_github_remote() -> None:
+    env: dict[str, str] = {}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="git@github.com:octo/repo.git",
+    )
+
+    assert url == "https://api.github.com/repos/octo/repo/releases/latest"
+
+
+def test_check_for_updates_handles_urlerror(monkeypatch) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("offline")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    update_check.check_for_updates(timeout=0.01)
+
+
+def test_check_for_updates_logs_available(monkeypatch, caplog) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+    monkeypatch.setattr(
+        update_check,
+        "_fetch_latest_version",
+        lambda *args, **kwargs: "0.2.0",
+    )
+
+    caplog.set_level(logging.INFO, logger="mlx_ui.update_check")
+
+    update_check.check_for_updates(timeout=0.01)
+
+    assert "Update available" in caplog.text
+    assert "0.1.0" in caplog.text
+    assert "0.2.0" in caplog.text


thinking
**Reviewing report format**

I'm checking the existing worker_report to confirm the structure and details needed to update it consistently with task ID, changes, files, commands run, and test results.
exec
/bin/zsh -lc 'cat .agent/worker_report.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 96ms:
# Worker Report

Task: WUI-040 — Telegram delivery

What changed:
- Added Telegram delivery helper with config parsing, masking, multipart send, and best-effort error handling.
- Hooked the worker completion path to send the message and transcript after successful jobs.
- Added Telegram delivery tests and documented env vars.

Files changed:
- mlx_ui/telegram.py
- mlx_ui/worker.py
- tests/test_telegram.py
- docs/dev.md
- docs/tree.md

Commands run + result:
- make test (pass)
- make lint (pass)
file update:
diff --git a/docs/dev.md b/docs/dev.md
index 2d90cc01c5e94c77008a87189476a0dbb6a217d0..821cd61662fde764a1e220f187e2160b21a966df
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -32,4 +32,5 @@
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
+- Update check runs at startup; set `DISABLE_UPDATE_CHECK=1` to skip or `UPDATE_CHECK_URL` to override the releases endpoint.
 - Prefer tests that do not require the real ML model; mock `wtm` execution.
diff --git a/docs/tree.md b/docs/tree.md
index 958a35c4cc32a984f0ef063c2ddd59b5f976404a..c96333ac02235457d28ca299f84b19a7ba212724
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`, `update_check.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`, `test_update_check.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/app.py b/mlx_ui/app.py
index dd65c6065ad4525881b170522c84bcdb5d063fcf..52ea7856986eae8e4fe8a62616c3e435c80695fd
--- a/mlx_ui/app.py
+++ b/mlx_ui/app.py
@@ -1,6 +1,7 @@
 from datetime import datetime, timezone
 from pathlib import Path
 import shutil
+import threading
 from uuid import uuid4
 
 from fastapi import FastAPI, File, HTTPException, Request, UploadFile
@@ -8,6 +9,7 @@
 from fastapi.templating import Jinja2Templates
 
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
 
 app = FastAPI(title="Whisper WebUI (MLX)")
@@ -20,6 +22,7 @@
 app.state.results_dir = DEFAULT_RESULTS_DIR
 app.state.db_path = DEFAULT_DB_PATH
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
 
 @app.on_event("startup")
@@ -27,6 +30,17 @@
     init_db(get_db_path())
     if getattr(app.state, "worker_enabled", True):
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
 
 def get_job_store() -> list[JobRecord]:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..144f1ea22991d258bb315d3270f7e841325e6a56
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,211 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    if env is None:
+        env = os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    if env is None:
+        env = os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")
diff --git a/tests/test_app.py b/tests/test_app.py
index 21abb10479f7ea2afcf3d372db776286935ecf9b..f763e505a4cec14f1d1e1c03135dde409fd16623
--- a/tests/test_app.py
+++ b/tests/test_app.py
@@ -12,6 +12,7 @@
     app.state.results_dir = tmp_path / "results"
     app.state.db_path = tmp_path / "jobs.db"
     app.state.worker_enabled = False
+    app.state.update_check_enabled = False
 
 
 def test_root_ok(tmp_path: Path) -> None:
diff --git a/tests/test_update_check.py b/tests/test_update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..ab8ee98b6ca62def4341bec4d0697fd401a40049
--- /dev/null
+++ b/tests/test_update_check.py
@@ -0,0 +1,63 @@
+import logging
+import urllib.error
+import urllib.request
+
+from mlx_ui import update_check
+
+
+def test_resolve_update_url_prefers_override() -> None:
+    env = {update_check.UPDATE_CHECK_URL_ENV: "https://example.com/override"}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="https://github.com/example/repo.git",
+    )
+
+    assert url == "https://example.com/override"
+
+
+def test_resolve_update_url_from_github_remote() -> None:
+    env: dict[str, str] = {}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="git@github.com:octo/repo.git",
+    )
+
+    assert url == "https://api.github.com/repos/octo/repo/releases/latest"
+
+
+def test_check_for_updates_handles_urlerror(monkeypatch) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("offline")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    update_check.check_for_updates(timeout=0.01)
+
+
+def test_check_for_updates_logs_available(monkeypatch, caplog) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+    monkeypatch.setattr(
+        update_check,
+        "_fetch_latest_version",
+        lambda *args, **kwargs: "0.2.0",
+    )
+
+    caplog.set_level(logging.INFO, logger="mlx_ui.update_check")
+
+    update_check.check_for_updates(timeout=0.01)
+
+    assert "Update available" in caplog.text
+    assert "0.1.0" in caplog.text
+    assert "0.2.0" in caplog.text


thinking
**Preparing final report and log entry**

I'm gathering changed files and updating progress with a timestamp in UTC format, matching the existing log style for test and lint results.
exec
/bin/zsh -lc 'date -u +"%Y-%m-%dT%H:%M:%SZ"' in /Users/ivankhokhlov/code/mlx-ui succeeded in 61ms:
2026-01-21T13:31:52Z
file update:
diff --git a/docs/dev.md b/docs/dev.md
index 2d90cc01c5e94c77008a87189476a0dbb6a217d0..821cd61662fde764a1e220f187e2160b21a966df
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -32,4 +32,5 @@
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
+- Update check runs at startup; set `DISABLE_UPDATE_CHECK=1` to skip or `UPDATE_CHECK_URL` to override the releases endpoint.
 - Prefer tests that do not require the real ML model; mock `wtm` execution.
diff --git a/docs/tree.md b/docs/tree.md
index 958a35c4cc32a984f0ef063c2ddd59b5f976404a..c96333ac02235457d28ca299f84b19a7ba212724
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`, `update_check.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`, `test_update_check.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/app.py b/mlx_ui/app.py
index dd65c6065ad4525881b170522c84bcdb5d063fcf..52ea7856986eae8e4fe8a62616c3e435c80695fd
--- a/mlx_ui/app.py
+++ b/mlx_ui/app.py
@@ -1,6 +1,7 @@
 from datetime import datetime, timezone
 from pathlib import Path
 import shutil
+import threading
 from uuid import uuid4
 
 from fastapi import FastAPI, File, HTTPException, Request, UploadFile
@@ -8,6 +9,7 @@
 from fastapi.templating import Jinja2Templates
 
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
 
 app = FastAPI(title="Whisper WebUI (MLX)")
@@ -20,6 +22,7 @@
 app.state.results_dir = DEFAULT_RESULTS_DIR
 app.state.db_path = DEFAULT_DB_PATH
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
 
 @app.on_event("startup")
@@ -27,6 +30,17 @@
     init_db(get_db_path())
     if getattr(app.state, "worker_enabled", True):
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
 
 def get_job_store() -> list[JobRecord]:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..144f1ea22991d258bb315d3270f7e841325e6a56
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,211 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    if env is None:
+        env = os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    if env is None:
+        env = os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")
diff --git a/tests/test_app.py b/tests/test_app.py
index 21abb10479f7ea2afcf3d372db776286935ecf9b..f763e505a4cec14f1d1e1c03135dde409fd16623
--- a/tests/test_app.py
+++ b/tests/test_app.py
@@ -12,6 +12,7 @@
     app.state.results_dir = tmp_path / "results"
     app.state.db_path = tmp_path / "jobs.db"
     app.state.worker_enabled = False
+    app.state.update_check_enabled = False
 
 
 def test_root_ok(tmp_path: Path) -> None:
diff --git a/tests/test_update_check.py b/tests/test_update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..ab8ee98b6ca62def4341bec4d0697fd401a40049
--- /dev/null
+++ b/tests/test_update_check.py
@@ -0,0 +1,63 @@
+import logging
+import urllib.error
+import urllib.request
+
+from mlx_ui import update_check
+
+
+def test_resolve_update_url_prefers_override() -> None:
+    env = {update_check.UPDATE_CHECK_URL_ENV: "https://example.com/override"}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="https://github.com/example/repo.git",
+    )
+
+    assert url == "https://example.com/override"
+
+
+def test_resolve_update_url_from_github_remote() -> None:
+    env: dict[str, str] = {}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="git@github.com:octo/repo.git",
+    )
+
+    assert url == "https://api.github.com/repos/octo/repo/releases/latest"
+
+
+def test_check_for_updates_handles_urlerror(monkeypatch) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("offline")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    update_check.check_for_updates(timeout=0.01)
+
+
+def test_check_for_updates_logs_available(monkeypatch, caplog) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+    monkeypatch.setattr(
+        update_check,
+        "_fetch_latest_version",
+        lambda *args, **kwargs: "0.2.0",
+    )
+
+    caplog.set_level(logging.INFO, logger="mlx_ui.update_check")
+
+    update_check.check_for_updates(timeout=0.01)
+
+    assert "Update available" in caplog.text
+    assert "0.1.0" in caplog.text
+    assert "0.2.0" in caplog.text


thinking
**Updating worker report file**
exec
/bin/zsh -lc "cat <<'EOF' > .agent/worker_report.md
# Worker Report

Task: WUI-050 — Update check at startup

What changed:
- Added update check helper with URL resolution, local version detection, and version comparison logging.
- Triggered update check on startup in a daemon thread with opt-out via env/app state.
- Added update check tests and documented the env overrides.

Files changed:
- mlx_ui/update_check.py
- mlx_ui/app.py
- tests/test_update_check.py
- tests/test_app.py
- docs/dev.md
- docs/tree.md

Commands run + result:
- make test (pass)
- make lint (pass)
EOF" in /Users/ivankhokhlov/code/mlx-ui succeeded in 89ms:

file update:
diff --git a/docs/dev.md b/docs/dev.md
index 2d90cc01c5e94c77008a87189476a0dbb6a217d0..821cd61662fde764a1e220f187e2160b21a966df
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -32,4 +32,5 @@
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
+- Update check runs at startup; set `DISABLE_UPDATE_CHECK=1` to skip or `UPDATE_CHECK_URL` to override the releases endpoint.
 - Prefer tests that do not require the real ML model; mock `wtm` execution.
diff --git a/docs/tree.md b/docs/tree.md
index 958a35c4cc32a984f0ef063c2ddd59b5f976404a..c96333ac02235457d28ca299f84b19a7ba212724
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`, `update_check.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`, `test_update_check.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/app.py b/mlx_ui/app.py
index dd65c6065ad4525881b170522c84bcdb5d063fcf..52ea7856986eae8e4fe8a62616c3e435c80695fd
--- a/mlx_ui/app.py
+++ b/mlx_ui/app.py
@@ -1,6 +1,7 @@
 from datetime import datetime, timezone
 from pathlib import Path
 import shutil
+import threading
 from uuid import uuid4
 
 from fastapi import FastAPI, File, HTTPException, Request, UploadFile
@@ -8,6 +9,7 @@
 from fastapi.templating import Jinja2Templates
 
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
 
 app = FastAPI(title="Whisper WebUI (MLX)")
@@ -20,6 +22,7 @@
 app.state.results_dir = DEFAULT_RESULTS_DIR
 app.state.db_path = DEFAULT_DB_PATH
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
 
 @app.on_event("startup")
@@ -27,6 +30,17 @@
     init_db(get_db_path())
     if getattr(app.state, "worker_enabled", True):
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
 
 def get_job_store() -> list[JobRecord]:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..144f1ea22991d258bb315d3270f7e841325e6a56
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,211 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    if env is None:
+        env = os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    if env is None:
+        env = os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")
diff --git a/tests/test_app.py b/tests/test_app.py
index 21abb10479f7ea2afcf3d372db776286935ecf9b..f763e505a4cec14f1d1e1c03135dde409fd16623
--- a/tests/test_app.py
+++ b/tests/test_app.py
@@ -12,6 +12,7 @@
     app.state.results_dir = tmp_path / "results"
     app.state.db_path = tmp_path / "jobs.db"
     app.state.worker_enabled = False
+    app.state.update_check_enabled = False
 
 
 def test_root_ok(tmp_path: Path) -> None:
diff --git a/tests/test_update_check.py b/tests/test_update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..ab8ee98b6ca62def4341bec4d0697fd401a40049
--- /dev/null
+++ b/tests/test_update_check.py
@@ -0,0 +1,63 @@
+import logging
+import urllib.error
+import urllib.request
+
+from mlx_ui import update_check
+
+
+def test_resolve_update_url_prefers_override() -> None:
+    env = {update_check.UPDATE_CHECK_URL_ENV: "https://example.com/override"}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="https://github.com/example/repo.git",
+    )
+
+    assert url == "https://example.com/override"
+
+
+def test_resolve_update_url_from_github_remote() -> None:
+    env: dict[str, str] = {}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="git@github.com:octo/repo.git",
+    )
+
+    assert url == "https://api.github.com/repos/octo/repo/releases/latest"
+
+
+def test_check_for_updates_handles_urlerror(monkeypatch) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("offline")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    update_check.check_for_updates(timeout=0.01)
+
+
+def test_check_for_updates_logs_available(monkeypatch, caplog) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+    monkeypatch.setattr(
+        update_check,
+        "_fetch_latest_version",
+        lambda *args, **kwargs: "0.2.0",
+    )
+
+    caplog.set_level(logging.INFO, logger="mlx_ui.update_check")
+
+    update_check.check_for_updates(timeout=0.01)
+
+    assert "Update available" in caplog.text
+    assert "0.1.0" in caplog.text
+    assert "0.2.0" in caplog.text

exec
/bin/zsh -lc "cat <<'EOF' >> .agent/progress.md
- 2026-01-21T13:31:52Z — WORKER — CODEX_ITERATION=12 — WUI-050 — tests: passed (make test); lint: passed (make lint)
EOF" in /Users/ivankhokhlov/code/mlx-ui succeeded in 75ms:

file update:
diff --git a/docs/dev.md b/docs/dev.md
index 2d90cc01c5e94c77008a87189476a0dbb6a217d0..821cd61662fde764a1e220f187e2160b21a966df
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -32,4 +32,5 @@
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
+- Update check runs at startup; set `DISABLE_UPDATE_CHECK=1` to skip or `UPDATE_CHECK_URL` to override the releases endpoint.
 - Prefer tests that do not require the real ML model; mock `wtm` execution.
diff --git a/docs/tree.md b/docs/tree.md
index 958a35c4cc32a984f0ef063c2ddd59b5f976404a..c96333ac02235457d28ca299f84b19a7ba212724
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`, `update_check.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`, `test_update_check.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/app.py b/mlx_ui/app.py
index dd65c6065ad4525881b170522c84bcdb5d063fcf..52ea7856986eae8e4fe8a62616c3e435c80695fd
--- a/mlx_ui/app.py
+++ b/mlx_ui/app.py
@@ -1,6 +1,7 @@
 from datetime import datetime, timezone
 from pathlib import Path
 import shutil
+import threading
 from uuid import uuid4
 
 from fastapi import FastAPI, File, HTTPException, Request, UploadFile
@@ -8,6 +9,7 @@
 from fastapi.templating import Jinja2Templates
 
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
 
 app = FastAPI(title="Whisper WebUI (MLX)")
@@ -20,6 +22,7 @@
 app.state.results_dir = DEFAULT_RESULTS_DIR
 app.state.db_path = DEFAULT_DB_PATH
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
 
 @app.on_event("startup")
@@ -27,6 +30,17 @@
     init_db(get_db_path())
     if getattr(app.state, "worker_enabled", True):
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
 
 def get_job_store() -> list[JobRecord]:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..144f1ea22991d258bb315d3270f7e841325e6a56
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,211 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    if env is None:
+        env = os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    if env is None:
+        env = os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")
diff --git a/tests/test_app.py b/tests/test_app.py
index 21abb10479f7ea2afcf3d372db776286935ecf9b..f763e505a4cec14f1d1e1c03135dde409fd16623
--- a/tests/test_app.py
+++ b/tests/test_app.py
@@ -12,6 +12,7 @@
     app.state.results_dir = tmp_path / "results"
     app.state.db_path = tmp_path / "jobs.db"
     app.state.worker_enabled = False
+    app.state.update_check_enabled = False
 
 
 def test_root_ok(tmp_path: Path) -> None:
diff --git a/tests/test_update_check.py b/tests/test_update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..ab8ee98b6ca62def4341bec4d0697fd401a40049
--- /dev/null
+++ b/tests/test_update_check.py
@@ -0,0 +1,63 @@
+import logging
+import urllib.error
+import urllib.request
+
+from mlx_ui import update_check
+
+
+def test_resolve_update_url_prefers_override() -> None:
+    env = {update_check.UPDATE_CHECK_URL_ENV: "https://example.com/override"}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="https://github.com/example/repo.git",
+    )
+
+    assert url == "https://example.com/override"
+
+
+def test_resolve_update_url_from_github_remote() -> None:
+    env: dict[str, str] = {}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="git@github.com:octo/repo.git",
+    )
+
+    assert url == "https://api.github.com/repos/octo/repo/releases/latest"
+
+
+def test_check_for_updates_handles_urlerror(monkeypatch) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("offline")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    update_check.check_for_updates(timeout=0.01)
+
+
+def test_check_for_updates_logs_available(monkeypatch, caplog) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+    monkeypatch.setattr(
+        update_check,
+        "_fetch_latest_version",
+        lambda *args, **kwargs: "0.2.0",
+    )
+
+    caplog.set_level(logging.INFO, logger="mlx_ui.update_check")
+
+    update_check.check_for_updates(timeout=0.01)
+
+    assert "Update available" in caplog.text
+    assert "0.1.0" in caplog.text
+    assert "0.2.0" in caplog.text


thinking
**Confirming log presence and git status check**

I'm verifying that logs exist and deciding that updating `.agent/state` isn't needed since this is a worker, not a judge. I'll run a concise git status to list changed files for the final summary.
exec
/bin/zsh -lc 'git status -sb' in /Users/ivankhokhlov/code/mlx-ui succeeded in 103ms:
## master
 M .agent/last_judge.txt
 M .agent/last_planner.txt
 M .agent/logs/judge_10.err
 M .agent/logs/judge_10.out
 M .agent/logs/judge_11.err
 M .agent/logs/judge_11.out
 M .agent/logs/judge_9.err
 M .agent/logs/judge_9.out
 M .agent/plan.md
 M .agent/progress.md
 M .agent/queue.md
 M .agent/worker_report.md
 M docs/dev.md
 M docs/tree.md
 M mlx_ui/app.py
 M tests/test_app.py
?? .agent/logs/lint_12.log
?? .agent/logs/planner_12.err
?? .agent/logs/planner_12.out
file update:
diff --git a/docs/dev.md b/docs/dev.md
index 2d90cc01c5e94c77008a87189476a0dbb6a217d0..821cd61662fde764a1e220f187e2160b21a966df
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -32,4 +32,5 @@
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
+- Update check runs at startup; set `DISABLE_UPDATE_CHECK=1` to skip or `UPDATE_CHECK_URL` to override the releases endpoint.
 - Prefer tests that do not require the real ML model; mock `wtm` execution.
diff --git a/docs/tree.md b/docs/tree.md
index 958a35c4cc32a984f0ef063c2ddd59b5f976404a..c96333ac02235457d28ca299f84b19a7ba212724
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`, `update_check.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`, `test_update_check.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/app.py b/mlx_ui/app.py
index dd65c6065ad4525881b170522c84bcdb5d063fcf..52ea7856986eae8e4fe8a62616c3e435c80695fd
--- a/mlx_ui/app.py
+++ b/mlx_ui/app.py
@@ -1,6 +1,7 @@
 from datetime import datetime, timezone
 from pathlib import Path
 import shutil
+import threading
 from uuid import uuid4
 
 from fastapi import FastAPI, File, HTTPException, Request, UploadFile
@@ -8,6 +9,7 @@
 from fastapi.templating import Jinja2Templates
 
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
 
 app = FastAPI(title="Whisper WebUI (MLX)")
@@ -20,6 +22,7 @@
 app.state.results_dir = DEFAULT_RESULTS_DIR
 app.state.db_path = DEFAULT_DB_PATH
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
 
 @app.on_event("startup")
@@ -27,6 +30,17 @@
     init_db(get_db_path())
     if getattr(app.state, "worker_enabled", True):
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
 
 def get_job_store() -> list[JobRecord]:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..144f1ea22991d258bb315d3270f7e841325e6a56
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,211 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    if env is None:
+        env = os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    if env is None:
+        env = os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")
diff --git a/tests/test_app.py b/tests/test_app.py
index 21abb10479f7ea2afcf3d372db776286935ecf9b..f763e505a4cec14f1d1e1c03135dde409fd16623
--- a/tests/test_app.py
+++ b/tests/test_app.py
@@ -12,6 +12,7 @@
     app.state.results_dir = tmp_path / "results"
     app.state.db_path = tmp_path / "jobs.db"
     app.state.worker_enabled = False
+    app.state.update_check_enabled = False
 
 
 def test_root_ok(tmp_path: Path) -> None:
diff --git a/tests/test_update_check.py b/tests/test_update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..ab8ee98b6ca62def4341bec4d0697fd401a40049
--- /dev/null
+++ b/tests/test_update_check.py
@@ -0,0 +1,63 @@
+import logging
+import urllib.error
+import urllib.request
+
+from mlx_ui import update_check
+
+
+def test_resolve_update_url_prefers_override() -> None:
+    env = {update_check.UPDATE_CHECK_URL_ENV: "https://example.com/override"}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="https://github.com/example/repo.git",
+    )
+
+    assert url == "https://example.com/override"
+
+
+def test_resolve_update_url_from_github_remote() -> None:
+    env: dict[str, str] = {}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="git@github.com:octo/repo.git",
+    )
+
+    assert url == "https://api.github.com/repos/octo/repo/releases/latest"
+
+
+def test_check_for_updates_handles_urlerror(monkeypatch) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("offline")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    update_check.check_for_updates(timeout=0.01)
+
+
+def test_check_for_updates_logs_available(monkeypatch, caplog) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+    monkeypatch.setattr(
+        update_check,
+        "_fetch_latest_version",
+        lambda *args, **kwargs: "0.2.0",
+    )
+
+    caplog.set_level(logging.INFO, logger="mlx_ui.update_check")
+
+    update_check.check_for_updates(timeout=0.01)
+
+    assert "Update available" in caplog.text
+    assert "0.1.0" in caplog.text
+    assert "0.2.0" in caplog.text



thinking
**Preparing final summary and output**

I'm consolidating the final message to explain implemented changes with brief context and bullets, report test status including log paths, and reference worker_report and log files as required, while avoiding interactive questions and following presentation guidelines strictly.
thinking
**Summarizing implemented update check and tests**

Added a best-effort startup update check with timeout and concise logging, running in a daemon thread optionally disabled via `DISABLE_UPDATE_CHECK=1`. The helper module `mlx_ui/update_check.py` resolves the update URL (env override or GitHub remote), reads the local version, and compares it to the latest release; the startup hook in `mlx_ui/app.py` triggers this check, and tests cover URL resolution, offline handling, and logging, with environment overrides documented in `docs/dev.md`.

- Tests: `make test` (pass) — `.agent/logs/test_12.log`  
- Lint: `make lint` (pass) — `.agent/logs/lint_12.log`  
- Worker report: `.agent/worker_report.md`
codex
Added a best-effort startup update check with timeout and concise logging, running in a daemon thread and opt‑out via `DISABLE_UPDATE_CHECK=1`. The helper in `mlx_ui/update_check.py` resolves the update URL (env override or GitHub remote), reads the local version, and compares against the latest release; `mlx_ui/app.py` wires it into startup (tests can disable via `app.state.update_check_enabled`), new tests cover URL resolution/offline handling/logging, and `docs/dev.md` documents the env overrides.

- Tests: `make test` (pass) — `.agent/logs/test_12.log`
- Lint: `make lint` (pass) — `.agent/logs/lint_12.log`
- Worker report: `.agent/worker_report.md`
file update:
diff --git a/docs/dev.md b/docs/dev.md
index 2d90cc01c5e94c77008a87189476a0dbb6a217d0..821cd61662fde764a1e220f187e2160b21a966df
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -32,4 +32,5 @@
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
+- Update check runs at startup; set `DISABLE_UPDATE_CHECK=1` to skip or `UPDATE_CHECK_URL` to override the releases endpoint.
 - Prefer tests that do not require the real ML model; mock `wtm` execution.
diff --git a/docs/tree.md b/docs/tree.md
index 958a35c4cc32a984f0ef063c2ddd59b5f976404a..c96333ac02235457d28ca299f84b19a7ba212724
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`, `update_check.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`, `test_update_check.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/app.py b/mlx_ui/app.py
index dd65c6065ad4525881b170522c84bcdb5d063fcf..52ea7856986eae8e4fe8a62616c3e435c80695fd
--- a/mlx_ui/app.py
+++ b/mlx_ui/app.py
@@ -1,6 +1,7 @@
 from datetime import datetime, timezone
 from pathlib import Path
 import shutil
+import threading
 from uuid import uuid4
 
 from fastapi import FastAPI, File, HTTPException, Request, UploadFile
@@ -8,6 +9,7 @@
 from fastapi.templating import Jinja2Templates
 
 from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
+from mlx_ui.update_check import DEFAULT_TIMEOUT, check_for_updates, is_update_check_disabled
 from mlx_ui.worker import start_worker
 
 app = FastAPI(title="Whisper WebUI (MLX)")
@@ -20,6 +22,7 @@
 app.state.results_dir = DEFAULT_RESULTS_DIR
 app.state.db_path = DEFAULT_DB_PATH
 app.state.worker_enabled = True
+app.state.update_check_enabled = True
 
 
 @app.on_event("startup")
@@ -27,6 +30,17 @@
     init_db(get_db_path())
     if getattr(app.state, "worker_enabled", True):
         start_worker(get_db_path(), get_results_dir())
+    if (
+        getattr(app.state, "update_check_enabled", True)
+        and not is_update_check_disabled()
+    ):
+        thread = threading.Thread(
+            target=check_for_updates,
+            kwargs={"timeout": DEFAULT_TIMEOUT},
+            name="mlx-ui-update-check",
+            daemon=True,
+        )
+        thread.start()
 
 
 def get_job_store() -> list[JobRecord]:
diff --git a/mlx_ui/update_check.py b/mlx_ui/update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..144f1ea22991d258bb315d3270f7e841325e6a56
--- /dev/null
+++ b/mlx_ui/update_check.py
@@ -0,0 +1,211 @@
+from __future__ import annotations
+
+import importlib.metadata
+import json
+import logging
+import os
+from pathlib import Path
+import re
+import subprocess
+import urllib.parse
+import urllib.request
+from typing import Mapping
+
+import tomllib
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 2.0
+UPDATE_CHECK_URL_ENV = "UPDATE_CHECK_URL"
+DISABLE_UPDATE_CHECK_ENV = "DISABLE_UPDATE_CHECK"
+
+_BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+def is_update_check_disabled(env: Mapping[str, str] | None = None) -> bool:
+    if env is None:
+        env = os.environ
+    value = env.get(DISABLE_UPDATE_CHECK_ENV, "").strip().lower()
+    return value in {"1", "true", "yes", "on"}
+
+
+def resolve_update_url(
+    env: Mapping[str, str] | None = None,
+    remote_url: str | None = None,
+) -> str | None:
+    if env is None:
+        env = os.environ
+    override = env.get(UPDATE_CHECK_URL_ENV, "").strip()
+    if override:
+        return override
+    if remote_url is None:
+        remote_url = get_git_remote_url()
+    if not remote_url:
+        return None
+    return _github_releases_url(remote_url)
+
+
+def get_git_remote_url() -> str | None:
+    try:
+        result = subprocess.run(
+            ["git", "config", "--get", "remote.origin.url"],
+            capture_output=True,
+            text=True,
+            check=True,
+            cwd=_BASE_DIR,
+        )
+    except (FileNotFoundError, subprocess.CalledProcessError):
+        return None
+    remote = result.stdout.strip()
+    return remote or None
+
+
+def read_local_version() -> str | None:
+    try:
+        return importlib.metadata.version("mlx-ui")
+    except importlib.metadata.PackageNotFoundError:
+        return _read_version_from_pyproject()
+
+
+def check_for_updates(timeout: float = DEFAULT_TIMEOUT) -> None:
+    local_version = read_local_version()
+    if not local_version:
+        logger.debug("Update check skipped: local version unavailable.")
+        return
+
+    update_url = resolve_update_url()
+    if not update_url:
+        logger.debug("Update check skipped: no update URL available.")
+        return
+
+    try:
+        latest_version = _fetch_latest_version(update_url, timeout)
+    except Exception as exc:
+        logger.debug("Update check failed: %s", exc.__class__.__name__)
+        return
+
+    if not latest_version:
+        logger.debug("Update check failed: no version returned.")
+        return
+
+    comparison = _compare_versions(local_version, latest_version)
+    if comparison is None:
+        if _normalize_version(local_version) == _normalize_version(latest_version):
+            logger.info(
+                "Update check: current version %s is up to date.",
+                local_version,
+            )
+        else:
+            logger.info("Update available: %s -> %s", local_version, latest_version)
+        return
+
+    if comparison < 0:
+        logger.info("Update available: %s -> %s", local_version, latest_version)
+    elif comparison == 0:
+        logger.info(
+            "Update check: current version %s is up to date.",
+            local_version,
+        )
+    else:
+        logger.info(
+            "Update check: local version %s is newer than latest %s.",
+            local_version,
+            latest_version,
+        )
+
+
+def _github_releases_url(remote_url: str) -> str | None:
+    repo = _extract_github_repo(remote_url)
+    if not repo:
+        return None
+    owner, name = repo
+    return f"https://api.github.com/repos/{owner}/{name}/releases/latest"
+
+
+def _extract_github_repo(remote_url: str) -> tuple[str, str] | None:
+    remote_url = remote_url.strip()
+    if not remote_url:
+        return None
+
+    if remote_url.startswith("git@github.com:"):
+        path = remote_url.split(":", 1)[1]
+    else:
+        parsed = urllib.parse.urlparse(remote_url)
+        if parsed.netloc != "github.com":
+            return None
+        path = parsed.path.lstrip("/")
+
+    parts = [part for part in path.split("/") if part]
+    if len(parts) < 2:
+        return None
+    owner = parts[0]
+    repo = parts[1]
+    if repo.endswith(".git"):
+        repo = repo[: -len(".git")]
+    if not owner or not repo:
+        return None
+    return owner, repo
+
+
+def _read_version_from_pyproject() -> str | None:
+    pyproject_path = _BASE_DIR / "pyproject.toml"
+    if not pyproject_path.is_file():
+        return None
+    try:
+        data = tomllib.loads(pyproject_path.read_text(encoding="utf-8"))
+    except Exception:
+        return None
+    version = data.get("tool", {}).get("poetry", {}).get("version")
+    if not isinstance(version, str):
+        return None
+    version = version.strip()
+    return version or None
+
+
+def _fetch_latest_version(update_url: str, timeout: float) -> str | None:
+    request = urllib.request.Request(
+        update_url,
+        headers={
+            "Accept": "application/vnd.github+json",
+            "User-Agent": "mlx-ui-update-check",
+        },
+    )
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        payload = response.read()
+    try:
+        data = json.loads(payload)
+    except json.JSONDecodeError:
+        return None
+    tag = data.get("tag_name") or data.get("name")
+    if not tag:
+        return None
+    return str(tag).strip()
+
+
+def _compare_versions(local: str, latest: str) -> int | None:
+    local_parts = _parse_version(local)
+    latest_parts = _parse_version(latest)
+    if local_parts is None or latest_parts is None:
+        return None
+    max_len = max(len(local_parts), len(latest_parts))
+    local_parts += (0,) * (max_len - len(local_parts))
+    latest_parts += (0,) * (max_len - len(latest_parts))
+    if local_parts < latest_parts:
+        return -1
+    if local_parts > latest_parts:
+        return 1
+    return 0
+
+
+def _parse_version(value: str) -> tuple[int, ...] | None:
+    match = re.match(r"(\d+(?:\.\d+)*)", _normalize_version(value))
+    if not match:
+        return None
+    try:
+        return tuple(int(part) for part in match.group(1).split("."))
+    except ValueError:
+        return None
+
+
+def _normalize_version(value: str) -> str:
+    return value.strip().lstrip("v")
diff --git a/tests/test_app.py b/tests/test_app.py
index 21abb10479f7ea2afcf3d372db776286935ecf9b..f763e505a4cec14f1d1e1c03135dde409fd16623
--- a/tests/test_app.py
+++ b/tests/test_app.py
@@ -12,6 +12,7 @@
     app.state.results_dir = tmp_path / "results"
     app.state.db_path = tmp_path / "jobs.db"
     app.state.worker_enabled = False
+    app.state.update_check_enabled = False
 
 
 def test_root_ok(tmp_path: Path) -> None:
diff --git a/tests/test_update_check.py b/tests/test_update_check.py
new file mode 100644
index 0000000000000000000000000000000000000000..ab8ee98b6ca62def4341bec4d0697fd401a40049
--- /dev/null
+++ b/tests/test_update_check.py
@@ -0,0 +1,63 @@
+import logging
+import urllib.error
+import urllib.request
+
+from mlx_ui import update_check
+
+
+def test_resolve_update_url_prefers_override() -> None:
+    env = {update_check.UPDATE_CHECK_URL_ENV: "https://example.com/override"}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="https://github.com/example/repo.git",
+    )
+
+    assert url == "https://example.com/override"
+
+
+def test_resolve_update_url_from_github_remote() -> None:
+    env: dict[str, str] = {}
+    url = update_check.resolve_update_url(
+        env=env,
+        remote_url="git@github.com:octo/repo.git",
+    )
+
+    assert url == "https://api.github.com/repos/octo/repo/releases/latest"
+
+
+def test_check_for_updates_handles_urlerror(monkeypatch) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("offline")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    update_check.check_for_updates(timeout=0.01)
+
+
+def test_check_for_updates_logs_available(monkeypatch, caplog) -> None:
+    monkeypatch.setattr(update_check, "read_local_version", lambda: "0.1.0")
+    monkeypatch.setattr(
+        update_check,
+        "resolve_update_url",
+        lambda *args, **kwargs: "https://example.com",
+    )
+    monkeypatch.setattr(
+        update_check,
+        "_fetch_latest_version",
+        lambda *args, **kwargs: "0.2.0",
+    )
+
+    caplog.set_level(logging.INFO, logger="mlx_ui.update_check")
+
+    update_check.check_for_updates(timeout=0.01)
+
+    assert "Update available" in caplog.text
+    assert "0.1.0" in caplog.text
+    assert "0.2.0" in caplog.text

tokens used
65,174
