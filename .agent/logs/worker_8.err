OpenAI Codex v0.87.0 (research preview)
--------
workdir: /Users/ivankhokhlov/code/mlx-ui/.
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: xhigh
reasoning summaries: auto
session id: 019be079-9446-76e2-81fe-7d43b8234224
--------
user
# WORKER AGENT (3-phase harness)

You are the WORKER in a Planner→Worker→Judge pipeline.
Your job: execute `.agent/plan.md` as written, with minimal scope creep.

Non-interactive run (`codex exec`): do not ask questions. If unclear, make the smallest reasonable assumption and log it.

## Stop conditions
- If `.agent/STOP` exists: append “STOP seen” to `.agent/progress.md` and exit.
- If `.agent/DONE` exists: append “DONE seen” to `.agent/progress.md` and exit.

## Inputs you MUST read
- `.agent/PROJECT.md` (authoritative; includes TEST_CMD/LINT_CMD)
- `AGENTS.md` (repo rules)
- `docs/spec.md`
- `docs/dev.md` (if exists)
- `.agent/plan.md`
- `.agent/judge_feedback.md` (if present)
- `.agent/queue.md`
- `.agent/progress.md`
- `.agent/state.md`

## Core rules
- Implement ONLY the single task in `.agent/plan.md`.
- Do NOT mark tasks done in `.agent/queue.md` (Judge owns that).
- Prefer small, coherent changes. No big refactors unless the task explicitly requires it.
- All network-dependent logic must be best-effort with timeouts and exception handling.
- Bind server to localhost only.
- Queue must be strictly sequential: one job at a time; no parallel transcription runs.
- Never print secrets. If you need to log config, mask tokens.

## Logging
Ensure `.agent/logs/` exists.
Write/overwrite `.agent/worker_report.md` with:
- task id/title
- what changed (bullets)
- files changed (list)
- commands run + result (pass/fail)
- if failure: include a short excerpt of the error and what you think is next

Also append a WORKER entry to `.agent/progress.md` with:
- timestamp
- CODEX_ITERATION
- task id
- test + lint status summary

## Verification (must do)
Run TEST_CMD (from PROJECT.md). Capture output into a file.

Tip: to preserve exit codes with tee:
- use: `bash -lc "set -o pipefail; <TEST_CMD> 2>&1 | tee .agent/logs/test_${CODEX_ITERATION}.log"`

If LINT_CMD is set and command exists, run similarly and capture output:
- `.agent/logs/lint_${CODEX_ITERATION}.log`

If tests fail and you cannot fix quickly:
- write/update `.agent/BLOCKED.md` with exact errors + next steps
- exit (do not thrash)

## Output
Print a short summary:
- what you implemented
- test status
- pointers to worker_report + log files

mcp startup: no servers

thinking
**Planning file reading strategy**
exec
/bin/zsh -lc ls in /Users/ivankhokhlov/code/mlx-ui succeeded in 60ms:
AGENTS.md
Makefile
README.md
data
docs
mlx_ui
poetry.lock
pyproject.toml
scripts
tests

thinking
**Preparing to read input files**
exec
/bin/zsh -lc 'cat AGENTS.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 56ms:
# AGENTS.md

This repo is developed using an autonomous loop (Planner → Worker → Judge) driven by `codex exec`.
Because each run starts with limited context, **durable state MUST be stored in `.agent/`**.

## Source of truth
- `.agent/PROJECT.md` — high-level constraints and commands
- `docs/spec.md` — product requirements
- `.agent/queue.md` — backlog (Judge marks tasks done)

## How to run
- Tests: `make test`
- Lint: `make lint`
- Format: `make fmt`
- Run server: `make run`

If Makefile does not exist yet, create it during bootstrap.

## Safety / security rules
- Never touch anything outside the repo root.

thinking
**Checking for project metadata files**
exec
/bin/zsh -lc 'ls .agent' in /Users/ivankhokhlov/code/mlx-ui succeeded in 73ms:
BLOCKED.md
PROJECT.md
judge.md
judge_feedback.md
last_judge.txt
last_planner.txt
last_worker.txt
logs
plan.md
planner.md
progress.md
queue.md
state.md
worker.md
worker_report.md

thinking
**Confirming file reads and stop conditions**

I'm verifying which spec and state files to read and noting that STOP/DONE files aren't present, so I'll proceed to read the required inputs.
exec
/bin/zsh -lc 'cat .agent/PROJECT.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 60ms:
# PROJECT (single source of truth for the harness)

PROJECT_NAME: "whisper-webui-mlx"
REPO_KIND: "new repo"

## Brief (1–2 paragraphs)
Build a **local macOS app for Apple Silicon (M1+)** that exposes a **Web UI on localhost** to manage **offline transcription** of audio/video files using the engine from `whisper-turbo-mlx` via its CLI `wtm` (MLX). https://github.com/JosefAlbers/whisper-turbo-mlx

Turn the current console workflow (e.g. `wtm ... --any_lang=True`) into a tool that is easy to deploy on another M1+ Mac with **one command**, supports **batch uploads**, a **strictly sequential** processing queue (no parallelism), **job history + downloads**, optional **Telegram delivery of TXT results**, and (in the final phase) **live recording + chunked transcription**.

## Primary stack
Python 3.11+
- Backend/Web: FastAPI + Uvicorn
- Templates/UI: Jinja2 + minimal vanilla JS (no external CDNs; must work offline)
- Storage: SQLite (jobs metadata) + local filesystem (uploads/results/logs)
- Worker: a single sequential worker consuming a persistent queue
- Transcription: subprocess call to `wtm` with explicit language selection

## Commands (choose defaults if unknown)
TEST_CMD: "make test"

thinking
**Noting missing docs/spec.md**
exec
/bin/zsh -lc 'cat docs/spec.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 90ms:
# Spec — whisper-webui-mlx

## Goal
Create a **local-only** tool for **macOS Apple Silicon (M1+)** that provides a **Web UI on localhost** to manage **local transcription** of audio/video files using the engine from `whisper-turbo-mlx` via its CLI `wtm` (MLX).

The tool must be easy to deploy to another M1+ Mac (one command), and after the initial setup + model download it must work **fully offline**.

## MVP: Batch file transcription via Web UI
### UX
- User opens Web UI (localhost).
- User uploads **one or multiple files** (audio or video).
- User selects the **language manually** (no auto-detect).
- Files are placed into a **queue** and processed **strictly sequentially** (no parallel jobs).
- UI has:
  - Queue view: current job + pending jobs
  - History view: completed jobs + access to results

### Processing rules
- One worker processes one job at a time (sequential).
- Keep the ML model “warm” behavior in mind: avoid parallelism and avoid reinitialization churn.

thinking
**Checking for docs/dev.md**
exec
/bin/zsh -lc 'ls docs' in /Users/ivankhokhlov/code/mlx-ui succeeded in 83ms:
dev.md
spec.md
tree.md

thinking
**Reviewing development docs**

I’m reading the development documentation to understand setup, workflows, and conventions that will guide implementation and testing.
exec
/bin/zsh -lc 'cat docs/dev.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 73ms:
# Developer guide

## Requirements (target)
- macOS Apple Silicon (M1+)
- Python 3.11+
- Homebrew (for system deps like ffmpeg)

## Quick start (eventual)
```bash
./scripts/setup_and_run.sh
```

## Manual dev loop
```bash
poetry install --with dev

make test
make run
```


thinking
**Reviewing core workflow files**
exec
/bin/zsh -lc 'cat .agent/plan.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 54ms:
# Plan

Task: WUI-020 — Integrate `wtm` CLI transcription

Acceptance: for a job, system runs `wtm` with chosen language and produces at least `.txt` in `data/results/<job_id>/`

Assumptions:
- `wtm` is installed and available on PATH (or a configurable path), and the model has been downloaded.
- Tests should not invoke the real ML model; subprocess calls will be mocked.

Implementation steps:
- Inspect the current transcriber interface and worker flow to locate where to swap the fake transcriber for a CLI-backed implementation.
- Implement a `wtm`-backed transcriber that builds the CLI command with the selected language and output directory, captures errors, and writes results under `data/results/<job_id>/`.
- Ensure the worker uses the new transcriber path and records failures cleanly without breaking the queue.
- Add configuration hooks if needed (e.g., optional `WTM_PATH`) and keep logs readable while avoiding secret exposure.
- Update tests to mock subprocess execution, create a fake `.txt` result, and assert job status/result paths without running the model.

Files likely to touch:
- `mlx_ui/transcriber.py`
- `mlx_ui/worker.py`

thinking
**Investigating judge_feedback necessity**
exec
/bin/zsh -lc 'cat .agent/judge_feedback.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 90ms:
PASS

Notes:
- `make test` passes (rerun).
- `make lint` not rerun; worker reported pass.
- Acceptance criteria met for WUI-012.

thinking
**Reviewing queue and state handling**
exec
/bin/zsh -lc 'cat .agent/queue.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 59ms:
# Queue

## Now
- [ ] WUI-020 — Integrate `wtm` CLI transcription (acceptance: for a job, system runs `wtm` with chosen language and produces at least `.txt` in `data/results/<job_id>/`)

## Next

## Later
- [ ] WUI-021 — Results browsing + download (acceptance: history page shows per-job links to view/download TXT and other generated formats)
- [ ] WUI-030 — One-command setup & run on M1+ macOS (acceptance: `./scripts/setup_and_run.sh` installs deps, downloads models, starts server, and opens browser)
- [ ] WUI-040 — Telegram delivery (acceptance: when env vars are set, send TXT + message; failures do not break pipeline; secrets masked)
- [ ] WUI-050 — Update check at startup (acceptance: if online, checks for updates with timeout; if offline, no errors and app works)
- [ ] WUI-090 — Live mode skeleton (acceptance: UI has “Live” page stub + technical plan in docs; no implementation yet)

## Done
- [x] WUI-012 — Sequential worker + fake transcriber (acceptance: single worker processes jobs strictly one-at-a-time; tests do not require ML model)
- [x] WUI-011 — Persistent job store (SQLite) (acceptance: jobs survive server restart; history page lists prior jobs)
- [x] WUI-010 — Upload endpoint + local storage (acceptance: user can upload multiple files; files saved under `data/uploads/` and jobs are created)
- [x] WUI-002 — Minimal WebUI shell (acceptance: localhost page renders with tabs: Queue + History, using server-side templates)
- [x] WUI-001A — Fix pytest availability for `make test` (acceptance: `make test` succeeds in a clean env by ensuring pytest is installed or Makefile uses Poetry/venv)
exec
/bin/zsh -lc 'cat .agent/progress.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 61ms:
# Progress Log (append-only)

- 2026-01-21T09:49:08 — INIT — Harness files created. Next: run the 3-phase loop.
- 2026-01-21T10:33:08Z — PLANNER — CODEX_ITERATION=1 — selected WUI-001 (Bootstrap repo skeleton). Queue unchanged.
- 2026-01-21T10:37:23Z — WORKER — CODEX_ITERATION=1 — WUI-001 — tests: failed (pytest missing); lint: not run
- 2026-01-21T10:39:53Z — JUDGE — CODEX_ITERATION=1 — NEEDS_WORK — make test failed (pytest missing in venv); tests: failed (make test)
- 2026-01-21T10:42:24Z — PLANNER — CODEX_ITERATION=2 — selected WUI-001A (Fix pytest availability for `make test`). Queue updated (format fix for WUI-001A).
- 2026-01-21T10:49:11Z — WORKER — CODEX_ITERATION=2 — WUI-001A — tests: passed (make test); lint: passed (make lint)
- 2026-01-21T10:52:47Z — JUDGE — CODEX_ITERATION=2 — PASS — acceptance met; tests: passed (make test); lint: passed (make lint)
- 2026-01-21T10:56:28Z — PLANNER — CODEX_ITERATION=3 — selected WUI-001 (Bootstrap repo skeleton). Queue unchanged.
- 2026-01-21T10:58:25Z — WORKER — CODEX_ITERATION=3 — WUI-001 — tests: passed (make test); lint: passed (make lint)
- 2026-01-21T11:01:51Z — JUDGE — CODEX_ITERATION=3 — PASS — acceptance met; tests: passed (make test); lint: passed (make lint)
- 2026-01-21T11:05:17Z — PLANNER — CODEX_ITERATION=4 — selected WUI-002 (Minimal WebUI shell). Queue unchanged.
- 2026-01-21T11:11:48Z — WORKER — CODEX_ITERATION=4 — WUI-002 — tests: passed (make test); lint: passed (make lint)
- 2026-01-21T11:16:13Z — JUDGE — CODEX_ITERATION=4 — PASS — acceptance met; tests: passed (make test); lint: passed (make lint)
- 2026-01-21T11:23:27Z — PLANNER — CODEX_ITERATION=5 — selected WUI-010 (Upload endpoint + local storage). Queue updated (moved WUI-010 to Now).
- 2026-01-21T11:33:16Z — WORKER — CODEX_ITERATION=5 — WUI-010 — tests: passed (make test); lint: passed (make lint)
- 2026-01-21T11:37:21Z — JUDGE — CODEX_ITERATION=5 — PASS — acceptance met; tests: passed (make test); lint: not rerun (worker reported pass)
- 2026-01-21T11:41:40Z — PLANNER — CODEX_ITERATION=6 — selected WUI-011 (Persistent job store (SQLite)). Queue updated (moved WUI-011 to Now).
- 2026-01-21T11:48:06Z — WORKER — CODEX_ITERATION=6 — WUI-011 — tests: passed (make test); lint: passed (make lint)

thinking
**Checking state**
exec
/bin/zsh -lc 'cat .agent/state.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 66ms:
last_task_id: WUI-012
last_verdict: PASS
consecutive_failures: 0

thinking
**Preparing environment and scanning repo**

I'm ensuring necessary directories and files for agent operation exist or not, then using ripgrep to locate key components like transcriber to inform implementing plan WUI-020.
exec
/bin/zsh -lc 'rg -n "transcriber|wtm|worker" mlx_ui tests' in /Users/ivankhokhlov/code/mlx-ui succeeded in 83ms:
tests/test_app.py:13:    app.state.worker_enabled = False
tests/test_worker.py:7:from mlx_ui.worker import start_worker, stop_worker
tests/test_worker.py:61:def test_worker_processes_jobs_sequentially(tmp_path: Path) -> None:
tests/test_worker.py:84:    transcriber = RecordingTranscriber()
tests/test_worker.py:85:    start_worker(
tests/test_worker.py:89:        transcriber=transcriber,
tests/test_worker.py:94:        stop_worker(timeout=1)
tests/test_worker.py:96:    assert transcriber.concurrent_detected is False
tests/test_worker.py:97:    assert transcriber.seen == [job1.id, job2.id]
mlx_ui/app.py:11:from mlx_ui.worker import start_worker
mlx_ui/app.py:22:app.state.worker_enabled = True
mlx_ui/app.py:28:    if getattr(app.state, "worker_enabled", True):
mlx_ui/app.py:29:        start_worker(get_db_path(), get_results_dir())
mlx_ui/templates/index.html:271:          <p>Queue files for offline transcription. Upload and worker controls land here.</p>
mlx_ui/worker.py:8:from mlx_ui.transcriber import FakeTranscriber, Transcriber
mlx_ui/worker.py:12:_worker_lock = threading.Lock()
mlx_ui/worker.py:13:_worker_instance: Worker | None = None
mlx_ui/worker.py:22:        transcriber: Transcriber | None = None,
mlx_ui/worker.py:27:        self.transcriber = transcriber or FakeTranscriber()
mlx_ui/worker.py:37:            name="mlx-ui-worker",

thinking
**Opening transcriber**
exec
/bin/zsh -lc 'cat mlx_ui/transcriber.py' in /Users/ivankhokhlov/code/mlx-ui succeeded in 58ms:
from pathlib import Path
from typing import Protocol

from mlx_ui.db import JobRecord


class Transcriber(Protocol):
    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
        raise NotImplementedError


class FakeTranscriber:
    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
        results_dir = Path(results_dir)
        job_dir = results_dir / job.id
        job_dir.mkdir(parents=True, exist_ok=True)
        result_path = job_dir / "result.txt"
        content = f"Fake transcript for {job.filename} ({job.id})\n"
        result_path.write_text(content, encoding="utf-8")
        return result_path

thinking
**Planning WtmTranscriber integration**

I'm preparing to implement the CLI-based WtmTranscriber and update tests to mock subprocess calls. I also need to check the worker, which currently defaults to FakeTranscriber, to decide if it should switch to WtmTranscriber.
exec
/bin/zsh -lc 'cat mlx_ui/worker.py' in /Users/ivankhokhlov/code/mlx-ui succeeded in 73ms:
from __future__ import annotations

import logging
from pathlib import Path
import threading

from mlx_ui.db import claim_next_job, update_job_status
from mlx_ui.transcriber import FakeTranscriber, Transcriber

logger = logging.getLogger(__name__)

_worker_lock = threading.Lock()
_worker_instance: Worker | None = None


class Worker:
    def __init__(
        self,
        db_path: Path,
        results_dir: Path,

thinking
**Planning default transcriber update**

I'm checking app.py to update the default to use WtmTranscriber as intended.
exec
/bin/zsh -lc 'cat mlx_ui/app.py' in /Users/ivankhokhlov/code/mlx-ui succeeded in 84ms:
from datetime import datetime, timezone
from pathlib import Path
import shutil
from uuid import uuid4

from fastapi import FastAPI, File, Request, UploadFile
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates

from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
from mlx_ui.worker import start_worker

app = FastAPI(title="Whisper WebUI (MLX)")
templates = Jinja2Templates(directory=str(Path(__file__).resolve().parent / "templates"))
BASE_DIR = Path(__file__).resolve().parent.parent
DEFAULT_UPLOADS_DIR = BASE_DIR / "data" / "uploads"
DEFAULT_RESULTS_DIR = BASE_DIR / "data" / "results"
DEFAULT_DB_PATH = BASE_DIR / "data" / "jobs.db"
app.state.uploads_dir = DEFAULT_UPLOADS_DIR
app.state.results_dir = DEFAULT_RESULTS_DIR

thinking
**Checking configuration for WTM path**

I'm searching for environment variables or settings that specify the WTM path to determine where the config should be handled.
exec
/bin/zsh -lc 'rg -n "WTM|transcrib|result" mlx_ui' in /Users/ivankhokhlov/code/mlx-ui succeeded in 56ms:
mlx_ui/app.py:17:DEFAULT_RESULTS_DIR = BASE_DIR / "data" / "results"
mlx_ui/app.py:20:app.state.results_dir = DEFAULT_RESULTS_DIR
mlx_ui/app.py:29:        start_worker(get_db_path(), get_results_dir())
mlx_ui/app.py:44:def get_results_dir() -> Path:
mlx_ui/app.py:45:    return Path(app.state.results_dir)
mlx_ui/transcriber.py:8:    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
mlx_ui/transcriber.py:13:    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
mlx_ui/transcriber.py:14:        results_dir = Path(results_dir)
mlx_ui/transcriber.py:15:        job_dir = results_dir / job.id
mlx_ui/transcriber.py:17:        result_path = job_dir / "result.txt"
mlx_ui/transcriber.py:19:        result_path.write_text(content, encoding="utf-8")
mlx_ui/transcriber.py:20:        return result_path
mlx_ui/worker.py:8:from mlx_ui.transcriber import FakeTranscriber, Transcriber
mlx_ui/worker.py:20:        results_dir: Path,
mlx_ui/worker.py:22:        transcriber: Transcriber | None = None,
mlx_ui/worker.py:25:        self.results_dir = Path(results_dir)
mlx_ui/worker.py:27:        self.transcriber = transcriber or FakeTranscriber()
mlx_ui/worker.py:62:            self.transcriber.transcribe(job, self.results_dir)
mlx_ui/worker.py:64:            logger.exception("Worker failed to transcribe job %s", job.id)
mlx_ui/worker.py:73:    results_dir: Path,

thinking
**Reviewing repo structure for config**
exec
/bin/zsh -lc 'rg -n "env|config|settings" mlx_ui' in /Users/ivankhokhlov/code/mlx-ui exited 1 in 91ms:


thinking
**Considering minimal config setup**

I'm exploring using an environment variable in the transcriber module for configuration and checking existing tests to inform this approach.
exec
/bin/zsh -lc 'cat tests/test_worker.py' in /Users/ivankhokhlov/code/mlx-ui succeeded in 53ms:
from datetime import datetime, timedelta, timezone
from pathlib import Path
import threading
import time

from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
from mlx_ui.worker import start_worker, stop_worker


class RecordingTranscriber:
    def __init__(self) -> None:
        self._lock = threading.Lock()
        self._active = False
        self.concurrent_detected = False
        self.seen: list[str] = []

    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
        with self._lock:
            if self._active:
                self.concurrent_detected = True

thinking
**Reviewing test usage for transcriber**

The existing test uses a custom transcriber, so no changes are needed there; next, I'll check the test_app to see if new tests for the transcriber are required.
exec
/bin/zsh -lc 'cat tests/test_app.py' in /Users/ivankhokhlov/code/mlx-ui succeeded in 60ms:
from pathlib import Path

from fastapi.testclient import TestClient

from mlx_ui.app import app
from mlx_ui.db import list_jobs


def _configure_app(tmp_path: Path) -> None:
    app.state.uploads_dir = tmp_path / "uploads"
    app.state.results_dir = tmp_path / "results"
    app.state.db_path = tmp_path / "jobs.db"
    app.state.worker_enabled = False


def test_root_ok(tmp_path: Path) -> None:
    _configure_app(tmp_path)
    with TestClient(app) as client:
        response = client.get("/")


thinking
**Inspecting database schema**

I'm examining the database and related modules to identify job record fields for language support, preparing to integrate the transcriber and possibly restructure accordingly.
exec
/bin/zsh -lc 'cat mlx_ui/db.py' in /Users/ivankhokhlov/code/mlx-ui succeeded in 78ms:
from dataclasses import dataclass
from pathlib import Path
import sqlite3


@dataclass
class JobRecord:
    id: str
    filename: str
    status: str
    created_at: str
    upload_path: str


SCHEMA = """
CREATE TABLE IF NOT EXISTS jobs (
    id TEXT PRIMARY KEY,
    filename TEXT NOT NULL,
    status TEXT NOT NULL,
    created_at TEXT NOT NULL,

thinking
**Checking language selection implementation**

Noticed the job record doesn't include language selection, though the spec requires user manual choice. Next, I'll inspect templates and the index to verify if this feature is unimplemented.
exec
/bin/zsh -lc 'rg -n "language|lang" mlx_ui/templates/index.html' in /Users/ivankhokhlov/code/mlx-ui succeeded in 64ms:
2:<html lang="en">

thinking
**Assessing language handling**

No current language selection exists in jobs, so adding a language field with a default like "en" or "auto" may be needed to meet the requirement of running the transcriber with a chosen language. Next, I'll search the repo and docs for any existing language settings before modifying the job schema.
exec
/bin/zsh -lc 'rg -n "language" -S .' in /Users/ivankhokhlov/code/mlx-ui succeeded in 90ms:
./docs/spec.md:12:- User selects the **language manually** (no auto-detect).
./docs/spec.md:25:- Persist job metadata (queued/running/done/failed, timestamps, filenames, language, errors) in SQLite.


thinking
**Reconciling spec with minimal plan**

Recognizing job metadata needs language but plan forbids DB changes; deciding to use a default language inside the transcriber to meet the minimal scope without altering the database.
thinking
**Planning minimal transcriber with configurable language**

Deciding to implement the transcriber accepting a language argument set from an environment variable defaulting to "en" without altering job records, aligning with minimal scope. Planning to mock subprocess calls in tests and approximate realistic CLI usage for the `wtm` command.
exec
/bin/zsh -lc 'cat README.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 81ms:
# whisper-webui-mlx (agent harness bootstrap)

This repo currently contains the **3-phase Codex harness** (Planner → Worker → Judge) to build a local macOS (M1+) WebUI around `whisper-turbo-mlx` / `wtm`.

## Quick start (app)
Run the minimal FastAPI app on localhost:
```bash
make run
```

## Tests and lint
```bash
make test
make lint
make fmt
```

## Quick start (agent loop)
```bash
bash scripts/codex_loop_3phase.sh 50


thinking
**Choosing minimal CLI args for wtm**

I'm settling on calling `wtm` with `--output_dir` to specify output location and `--language` for input language, keeping options minimal to ensure output files are generated in the target directory.
thinking
**Designing robust wtm transcriber with testing in mind**

I'm planning to build a wtm transcriber that runs the CLI with minimal plausible options, ensures output directory creation, checks for expected .txt results after running, and raises clear errors if needed. Tests will mock subprocess and simulate outputs to avoid relying on actual wtm installation.
exec
/bin/zsh -lc 'cat docs/tree.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 80ms:
# Project tree (curated)

This file is a human-maintained map of the repo. Update when structure changes.

## Current (bootstrap)
- `.agent/` — durable loop state + prompts
- `data/` — runtime uploads/results/logs/jobs.db (created on demand)
- `docs/` — spec + dev notes + this tree map
- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
- `mlx_ui/templates/` — Jinja2 templates
- `scripts/` — loop scripts + setup/run scripts (to be implemented)
- `tests/` — pytest suite (`test_app.py`, `test_worker.py`)
- `Makefile` — dev commands
- `pyproject.toml` — dependencies and tooling
- `README.md` — repo overview


thinking
**Confirming test setup and logging approach**

I'm planning to add a new test file and ensure logs go to `.agent/logs` with filenames using the `CODEX_ITERATION` env variable, falling back gracefully if unset. I'll run tests with pipefail and tee, and follow instructions to write `.agent/BLOCKED.md` and exit if tests fail and can't fix quickly. I'll avoid auto-committing unless explicitly requested.
thinking
**Designing and planning new transcriber implementation**

I've detailed a robust plan for implementing a `WtmTranscriber` class that runs the CLI tool with configurable paths and language, handles outputs and errors gracefully, and integrates with existing code and tests. The design includes environment-based defaults, subprocess invocation with output checks, and test strategy using mocks for subprocess calls.
file update
M /Users/ivankhokhlov/code/mlx-ui/./mlx_ui/transcriber.py
@@ -1,2 +1,5 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
@@ -5,2 +8,4 @@
 
+logger = logging.getLogger(__name__)
+
 
@@ -20 +25,65 @@
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]
apply_patch(auto_approved=true) exited 0 in 17ms:
Success. Updated the following files:
M mlx_ui/transcriber.py
file update:
diff --git a/mlx_ui/transcriber.py b/mlx_ui/transcriber.py
index 3716a8e4021ce98aeae0fbbd3e4f7411ce26de56..6e3e16f29ba6e0789cc382871fd925270342a799
--- a/mlx_ui/transcriber.py
+++ b/mlx_ui/transcriber.py
@@ -1,8 +1,13 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
 
 from mlx_ui.db import JobRecord
 
+logger = logging.getLogger(__name__)
+
 
 class Transcriber(Protocol):
     def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
@@ -18,3 +23,67 @@
         content = f"Fake transcript for {job.filename} ({job.id})\n"
         result_path.write_text(content, encoding="utf-8")
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]

file update:
diff --git a/mlx_ui/transcriber.py b/mlx_ui/transcriber.py
index 3716a8e4021ce98aeae0fbbd3e4f7411ce26de56..6e3e16f29ba6e0789cc382871fd925270342a799
--- a/mlx_ui/transcriber.py
+++ b/mlx_ui/transcriber.py
@@ -1,8 +1,13 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
 
 from mlx_ui.db import JobRecord
 
+logger = logging.getLogger(__name__)
+
 
 class Transcriber(Protocol):
     def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
@@ -18,3 +23,67 @@
         content = f"Fake transcript for {job.filename} ({job.id})\n"
         result_path.write_text(content, encoding="utf-8")
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]


thinking
**Updating worker to use default transcriber**
file update
M /Users/ivankhokhlov/code/mlx-ui/./mlx_ui/worker.py
@@ -7,3 +7,3 @@
 from mlx_ui.db import claim_next_job, update_job_status
-from mlx_ui.transcriber import FakeTranscriber, Transcriber
+from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
@@ -26,3 +26,3 @@
         self.poll_interval = poll_interval
-        self.transcriber = transcriber or FakeTranscriber()
+        self.transcriber = transcriber or WtmTranscriber()
         self._stop_event = threading.Event()
apply_patch(auto_approved=true) exited 0 in 22ms:
Success. Updated the following files:
M mlx_ui/worker.py
file update:
diff --git a/mlx_ui/transcriber.py b/mlx_ui/transcriber.py
index 3716a8e4021ce98aeae0fbbd3e4f7411ce26de56..6e3e16f29ba6e0789cc382871fd925270342a799
--- a/mlx_ui/transcriber.py
+++ b/mlx_ui/transcriber.py
@@ -1,8 +1,13 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
 
 from mlx_ui.db import JobRecord
 
+logger = logging.getLogger(__name__)
+
 
 class Transcriber(Protocol):
     def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
@@ -18,3 +23,67 @@
         content = f"Fake transcript for {job.filename} ({job.id})\n"
         result_path.write_text(content, encoding="utf-8")
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index ce5d14a31f43e92b2beabf64d377b3f5a08481fc..b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,7 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
-from mlx_ui.transcriber import FakeTranscriber, Transcriber
+from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
 
@@ -24,7 +24,7 @@
         self.db_path = Path(db_path)
         self.results_dir = Path(results_dir)
         self.poll_interval = poll_interval
-        self.transcriber = transcriber or FakeTranscriber()
+        self.transcriber = transcriber or WtmTranscriber()
         self._stop_event = threading.Event()
         self._thread: threading.Thread | None = None
 

file update:
diff --git a/mlx_ui/transcriber.py b/mlx_ui/transcriber.py
index 3716a8e4021ce98aeae0fbbd3e4f7411ce26de56..6e3e16f29ba6e0789cc382871fd925270342a799
--- a/mlx_ui/transcriber.py
+++ b/mlx_ui/transcriber.py
@@ -1,8 +1,13 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
 
 from mlx_ui.db import JobRecord
 
+logger = logging.getLogger(__name__)
+
 
 class Transcriber(Protocol):
     def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
@@ -18,3 +23,67 @@
         content = f"Fake transcript for {job.filename} ({job.id})\n"
         result_path.write_text(content, encoding="utf-8")
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index ce5d14a31f43e92b2beabf64d377b3f5a08481fc..b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,7 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
-from mlx_ui.transcriber import FakeTranscriber, Transcriber
+from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
 
@@ -24,7 +24,7 @@
         self.db_path = Path(db_path)
         self.results_dir = Path(results_dir)
         self.poll_interval = poll_interval
-        self.transcriber = transcriber or FakeTranscriber()
+        self.transcriber = transcriber or WtmTranscriber()
         self._stop_event = threading.Event()
         self._thread: threading.Thread | None = None
 



thinking
**Adding transcriber tests with subprocess patch**

I'm designing tests that patch subprocess.run to intercept the command and simulate output file creation, verifying the transcriber runs and returns the expected text file without relying on the real tool.
thinking
**Confirming environment variable bypass in test**

The test passes an explicit path to avoid relying on the environment variable, and I'll add an assertion to verify the command includes the job's source file path as expected.
file update
A /Users/ivankhokhlov/code/mlx-ui/./tests/test_transcriber.py
from datetime import datetime, timezone
from pathlib import Path
import subprocess

from mlx_ui.db import JobRecord
from mlx_ui.transcriber import WtmTranscriber


def _make_job(tmp_path: Path) -> JobRecord:
    uploads_dir = tmp_path / "uploads" / "job1"
    uploads_dir.mkdir(parents=True, exist_ok=True)
    upload_path = uploads_dir / "sample.wav"
    upload_path.write_text("data", encoding="utf-8")
    return JobRecord(
        id="job1",
        filename="sample.wav",
        status="queued",
        created_at=datetime(2024, 1, 1, tzinfo=timezone.utc).isoformat(timespec="seconds"),
        upload_path=str(upload_path),
    )


def test_wtm_transcriber_runs_and_returns_txt(tmp_path: Path, monkeypatch) -> None:
    job = _make_job(tmp_path)
    results_dir = tmp_path / "results"
    captured: dict[str, list[str]] = {}

    def fake_run(cmd, capture_output, text, check):  # type: ignore[no-untyped-def]
        captured["cmd"] = list(cmd)
        output_dir = Path(cmd[cmd.index("--output_dir") + 1])
        output_dir.mkdir(parents=True, exist_ok=True)
        (output_dir / "sample.txt").write_text("hello", encoding="utf-8")
        return subprocess.CompletedProcess(cmd, 0, stdout="ok", stderr="")

    monkeypatch.setattr(subprocess, "run", fake_run)

    transcriber = WtmTranscriber(wtm_path="wtm", language="fr")
    result_path = transcriber.transcribe(job, results_dir)

    assert result_path.is_file()
    assert result_path.read_text(encoding="utf-8") == "hello"
    assert captured["cmd"][0] == "wtm"
    assert str(Path(job.upload_path)) in captured["cmd"]
    assert "--language" in captured["cmd"]
    assert "fr" in captured["cmd"]
    assert "--output_dir" in captured["cmd"]
    assert str(results_dir / job.id) in captured["cmd"]
apply_patch(auto_approved=true) exited 0 in 33ms:
Success. Updated the following files:
A tests/test_transcriber.py
file update:
diff --git a/mlx_ui/transcriber.py b/mlx_ui/transcriber.py
index 3716a8e4021ce98aeae0fbbd3e4f7411ce26de56..6e3e16f29ba6e0789cc382871fd925270342a799
--- a/mlx_ui/transcriber.py
+++ b/mlx_ui/transcriber.py
@@ -1,8 +1,13 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
 
 from mlx_ui.db import JobRecord
 
+logger = logging.getLogger(__name__)
+
 
 class Transcriber(Protocol):
     def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
@@ -18,3 +23,67 @@
         content = f"Fake transcript for {job.filename} ({job.id})\n"
         result_path.write_text(content, encoding="utf-8")
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index ce5d14a31f43e92b2beabf64d377b3f5a08481fc..b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,7 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
-from mlx_ui.transcriber import FakeTranscriber, Transcriber
+from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
 
@@ -24,7 +24,7 @@
         self.db_path = Path(db_path)
         self.results_dir = Path(results_dir)
         self.poll_interval = poll_interval
-        self.transcriber = transcriber or FakeTranscriber()
+        self.transcriber = transcriber or WtmTranscriber()
         self._stop_event = threading.Event()
         self._thread: threading.Thread | None = None
 
diff --git a/tests/test_transcriber.py b/tests/test_transcriber.py
new file mode 100644
index 0000000000000000000000000000000000000000..b1eac06ae63a7c9c3de707e3dbc1b43da5d86f47
--- /dev/null
+++ b/tests/test_transcriber.py
@@ -0,0 +1,47 @@
+from datetime import datetime, timezone
+from pathlib import Path
+import subprocess
+
+from mlx_ui.db import JobRecord
+from mlx_ui.transcriber import WtmTranscriber
+
+
+def _make_job(tmp_path: Path) -> JobRecord:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    return JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="queued",
+        created_at=datetime(2024, 1, 1, tzinfo=timezone.utc).isoformat(timespec="seconds"),
+        upload_path=str(upload_path),
+    )
+
+
+def test_wtm_transcriber_runs_and_returns_txt(tmp_path: Path, monkeypatch) -> None:
+    job = _make_job(tmp_path)
+    results_dir = tmp_path / "results"
+    captured: dict[str, list[str]] = {}
+
+    def fake_run(cmd, capture_output, text, check):  # type: ignore[no-untyped-def]
+        captured["cmd"] = list(cmd)
+        output_dir = Path(cmd[cmd.index("--output_dir") + 1])
+        output_dir.mkdir(parents=True, exist_ok=True)
+        (output_dir / "sample.txt").write_text("hello", encoding="utf-8")
+        return subprocess.CompletedProcess(cmd, 0, stdout="ok", stderr="")
+
+    monkeypatch.setattr(subprocess, "run", fake_run)
+
+    transcriber = WtmTranscriber(wtm_path="wtm", language="fr")
+    result_path = transcriber.transcribe(job, results_dir)
+
+    assert result_path.is_file()
+    assert result_path.read_text(encoding="utf-8") == "hello"
+    assert captured["cmd"][0] == "wtm"
+    assert str(Path(job.upload_path)) in captured["cmd"]
+    assert "--language" in captured["cmd"]
+    assert "fr" in captured["cmd"]
+    assert "--output_dir" in captured["cmd"]
+    assert str(results_dir / job.id) in captured["cmd"]

file update:
diff --git a/mlx_ui/transcriber.py b/mlx_ui/transcriber.py
index 3716a8e4021ce98aeae0fbbd3e4f7411ce26de56..6e3e16f29ba6e0789cc382871fd925270342a799
--- a/mlx_ui/transcriber.py
+++ b/mlx_ui/transcriber.py
@@ -1,8 +1,13 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
 
 from mlx_ui.db import JobRecord
 
+logger = logging.getLogger(__name__)
+
 
 class Transcriber(Protocol):
     def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
@@ -18,3 +23,67 @@
         content = f"Fake transcript for {job.filename} ({job.id})\n"
         result_path.write_text(content, encoding="utf-8")
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index ce5d14a31f43e92b2beabf64d377b3f5a08481fc..b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,7 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
-from mlx_ui.transcriber import FakeTranscriber, Transcriber
+from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
 
@@ -24,7 +24,7 @@
         self.db_path = Path(db_path)
         self.results_dir = Path(results_dir)
         self.poll_interval = poll_interval
-        self.transcriber = transcriber or FakeTranscriber()
+        self.transcriber = transcriber or WtmTranscriber()
         self._stop_event = threading.Event()
         self._thread: threading.Thread | None = None
 
diff --git a/tests/test_transcriber.py b/tests/test_transcriber.py
new file mode 100644
index 0000000000000000000000000000000000000000..b1eac06ae63a7c9c3de707e3dbc1b43da5d86f47
--- /dev/null
+++ b/tests/test_transcriber.py
@@ -0,0 +1,47 @@
+from datetime import datetime, timezone
+from pathlib import Path
+import subprocess
+
+from mlx_ui.db import JobRecord
+from mlx_ui.transcriber import WtmTranscriber
+
+
+def _make_job(tmp_path: Path) -> JobRecord:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    return JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="queued",
+        created_at=datetime(2024, 1, 1, tzinfo=timezone.utc).isoformat(timespec="seconds"),
+        upload_path=str(upload_path),
+    )
+
+
+def test_wtm_transcriber_runs_and_returns_txt(tmp_path: Path, monkeypatch) -> None:
+    job = _make_job(tmp_path)
+    results_dir = tmp_path / "results"
+    captured: dict[str, list[str]] = {}
+
+    def fake_run(cmd, capture_output, text, check):  # type: ignore[no-untyped-def]
+        captured["cmd"] = list(cmd)
+        output_dir = Path(cmd[cmd.index("--output_dir") + 1])
+        output_dir.mkdir(parents=True, exist_ok=True)
+        (output_dir / "sample.txt").write_text("hello", encoding="utf-8")
+        return subprocess.CompletedProcess(cmd, 0, stdout="ok", stderr="")
+
+    monkeypatch.setattr(subprocess, "run", fake_run)
+
+    transcriber = WtmTranscriber(wtm_path="wtm", language="fr")
+    result_path = transcriber.transcribe(job, results_dir)
+
+    assert result_path.is_file()
+    assert result_path.read_text(encoding="utf-8") == "hello"
+    assert captured["cmd"][0] == "wtm"
+    assert str(Path(job.upload_path)) in captured["cmd"]
+    assert "--language" in captured["cmd"]
+    assert "fr" in captured["cmd"]
+    assert "--output_dir" in captured["cmd"]
+    assert str(results_dir / job.id) in captured["cmd"]


thinking
**Updating docs and test listings**

I'm updating docs/tree.md to include the new test_transcriber.py file in the tests list and applying the necessary patch for accuracy.
file update
M /Users/ivankhokhlov/code/mlx-ui/./docs/tree.md
@@ -11,3 +11,3 @@
 - `scripts/` — loop scripts + setup/run scripts (to be implemented)
-- `tests/` — pytest suite (`test_app.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
 - `Makefile` — dev commands
apply_patch(auto_approved=true) exited 0 in 37ms:
Success. Updated the following files:
M docs/tree.md
file update:
diff --git a/docs/tree.md b/docs/tree.md
index b80b3c53d3b2148d4830121b7bfd9de2a390caec..9ad18896f5ab57fc92a96e6f89c0f4424e206def
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -9,7 +9,7 @@
 - `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run scripts (to be implemented)
-- `tests/` — pytest suite (`test_app.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/transcriber.py b/mlx_ui/transcriber.py
index 3716a8e4021ce98aeae0fbbd3e4f7411ce26de56..6e3e16f29ba6e0789cc382871fd925270342a799
--- a/mlx_ui/transcriber.py
+++ b/mlx_ui/transcriber.py
@@ -1,8 +1,13 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
 
 from mlx_ui.db import JobRecord
 
+logger = logging.getLogger(__name__)
+
 
 class Transcriber(Protocol):
     def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
@@ -18,3 +23,67 @@
         content = f"Fake transcript for {job.filename} ({job.id})\n"
         result_path.write_text(content, encoding="utf-8")
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index ce5d14a31f43e92b2beabf64d377b3f5a08481fc..b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,7 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
-from mlx_ui.transcriber import FakeTranscriber, Transcriber
+from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
 
@@ -24,7 +24,7 @@
         self.db_path = Path(db_path)
         self.results_dir = Path(results_dir)
         self.poll_interval = poll_interval
-        self.transcriber = transcriber or FakeTranscriber()
+        self.transcriber = transcriber or WtmTranscriber()
         self._stop_event = threading.Event()
         self._thread: threading.Thread | None = None
 
diff --git a/tests/test_transcriber.py b/tests/test_transcriber.py
new file mode 100644
index 0000000000000000000000000000000000000000..b1eac06ae63a7c9c3de707e3dbc1b43da5d86f47
--- /dev/null
+++ b/tests/test_transcriber.py
@@ -0,0 +1,47 @@
+from datetime import datetime, timezone
+from pathlib import Path
+import subprocess
+
+from mlx_ui.db import JobRecord
+from mlx_ui.transcriber import WtmTranscriber
+
+
+def _make_job(tmp_path: Path) -> JobRecord:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    return JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="queued",
+        created_at=datetime(2024, 1, 1, tzinfo=timezone.utc).isoformat(timespec="seconds"),
+        upload_path=str(upload_path),
+    )
+
+
+def test_wtm_transcriber_runs_and_returns_txt(tmp_path: Path, monkeypatch) -> None:
+    job = _make_job(tmp_path)
+    results_dir = tmp_path / "results"
+    captured: dict[str, list[str]] = {}
+
+    def fake_run(cmd, capture_output, text, check):  # type: ignore[no-untyped-def]
+        captured["cmd"] = list(cmd)
+        output_dir = Path(cmd[cmd.index("--output_dir") + 1])
+        output_dir.mkdir(parents=True, exist_ok=True)
+        (output_dir / "sample.txt").write_text("hello", encoding="utf-8")
+        return subprocess.CompletedProcess(cmd, 0, stdout="ok", stderr="")
+
+    monkeypatch.setattr(subprocess, "run", fake_run)
+
+    transcriber = WtmTranscriber(wtm_path="wtm", language="fr")
+    result_path = transcriber.transcribe(job, results_dir)
+
+    assert result_path.is_file()
+    assert result_path.read_text(encoding="utf-8") == "hello"
+    assert captured["cmd"][0] == "wtm"
+    assert str(Path(job.upload_path)) in captured["cmd"]
+    assert "--language" in captured["cmd"]
+    assert "fr" in captured["cmd"]
+    assert "--output_dir" in captured["cmd"]
+    assert str(results_dir / job.id) in captured["cmd"]

file update:
diff --git a/docs/tree.md b/docs/tree.md
index b80b3c53d3b2148d4830121b7bfd9de2a390caec..9ad18896f5ab57fc92a96e6f89c0f4424e206def
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -9,7 +9,7 @@
 - `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run scripts (to be implemented)
-- `tests/` — pytest suite (`test_app.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/transcriber.py b/mlx_ui/transcriber.py
index 3716a8e4021ce98aeae0fbbd3e4f7411ce26de56..6e3e16f29ba6e0789cc382871fd925270342a799
--- a/mlx_ui/transcriber.py
+++ b/mlx_ui/transcriber.py
@@ -1,8 +1,13 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
 
 from mlx_ui.db import JobRecord
 
+logger = logging.getLogger(__name__)
+
 
 class Transcriber(Protocol):
     def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
@@ -18,3 +23,67 @@
         content = f"Fake transcript for {job.filename} ({job.id})\n"
         result_path.write_text(content, encoding="utf-8")
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index ce5d14a31f43e92b2beabf64d377b3f5a08481fc..b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,7 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
-from mlx_ui.transcriber import FakeTranscriber, Transcriber
+from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
 
@@ -24,7 +24,7 @@
         self.db_path = Path(db_path)
         self.results_dir = Path(results_dir)
         self.poll_interval = poll_interval
-        self.transcriber = transcriber or FakeTranscriber()
+        self.transcriber = transcriber or WtmTranscriber()
         self._stop_event = threading.Event()
         self._thread: threading.Thread | None = None
 
diff --git a/tests/test_transcriber.py b/tests/test_transcriber.py
new file mode 100644
index 0000000000000000000000000000000000000000..b1eac06ae63a7c9c3de707e3dbc1b43da5d86f47
--- /dev/null
+++ b/tests/test_transcriber.py
@@ -0,0 +1,47 @@
+from datetime import datetime, timezone
+from pathlib import Path
+import subprocess
+
+from mlx_ui.db import JobRecord
+from mlx_ui.transcriber import WtmTranscriber
+
+
+def _make_job(tmp_path: Path) -> JobRecord:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    return JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="queued",
+        created_at=datetime(2024, 1, 1, tzinfo=timezone.utc).isoformat(timespec="seconds"),
+        upload_path=str(upload_path),
+    )
+
+
+def test_wtm_transcriber_runs_and_returns_txt(tmp_path: Path, monkeypatch) -> None:
+    job = _make_job(tmp_path)
+    results_dir = tmp_path / "results"
+    captured: dict[str, list[str]] = {}
+
+    def fake_run(cmd, capture_output, text, check):  # type: ignore[no-untyped-def]
+        captured["cmd"] = list(cmd)
+        output_dir = Path(cmd[cmd.index("--output_dir") + 1])
+        output_dir.mkdir(parents=True, exist_ok=True)
+        (output_dir / "sample.txt").write_text("hello", encoding="utf-8")
+        return subprocess.CompletedProcess(cmd, 0, stdout="ok", stderr="")
+
+    monkeypatch.setattr(subprocess, "run", fake_run)
+
+    transcriber = WtmTranscriber(wtm_path="wtm", language="fr")
+    result_path = transcriber.transcribe(job, results_dir)
+
+    assert result_path.is_file()
+    assert result_path.read_text(encoding="utf-8") == "hello"
+    assert captured["cmd"][0] == "wtm"
+    assert str(Path(job.upload_path)) in captured["cmd"]
+    assert "--language" in captured["cmd"]
+    assert "fr" in captured["cmd"]
+    assert "--output_dir" in captured["cmd"]
+    assert str(results_dir / job.id) in captured["cmd"]


thinking
**Checking lint configuration**

I'm verifying lint rules and type hinting standards in the pyproject file, focusing on subprocess usage and function signature typings to avoid no-untyped-def errors. Next, I'll confirm which lint tool runs with `make lint`.
exec
/bin/zsh -lc 'cat pyproject.toml' in /Users/ivankhokhlov/code/mlx-ui succeeded in 70ms:
[tool.poetry]
name = "mlx-ui"
version = "0.1.0"
description = ""
authors = ["Ivan Khokhlov <ivan.s.khokhlov@rt.ru>"]
readme = "README.md"

[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.115.6"
jinja2 = "^3.1.4"
uvicorn = "^0.32.1"
python-multipart = "^0.0.21"

[tool.poetry.group.dev.dependencies]
httpx = "^0.28.1"
pytest = "^8.3.4"
ruff = "^0.14.13"


file update:
diff --git a/docs/tree.md b/docs/tree.md
index b80b3c53d3b2148d4830121b7bfd9de2a390caec..9ad18896f5ab57fc92a96e6f89c0f4424e206def
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -9,7 +9,7 @@
 - `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run scripts (to be implemented)
-- `tests/` — pytest suite (`test_app.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/transcriber.py b/mlx_ui/transcriber.py
index 3716a8e4021ce98aeae0fbbd3e4f7411ce26de56..6e3e16f29ba6e0789cc382871fd925270342a799
--- a/mlx_ui/transcriber.py
+++ b/mlx_ui/transcriber.py
@@ -1,8 +1,13 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
 
 from mlx_ui.db import JobRecord
 
+logger = logging.getLogger(__name__)
+
 
 class Transcriber(Protocol):
     def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
@@ -18,3 +23,67 @@
         content = f"Fake transcript for {job.filename} ({job.id})\n"
         result_path.write_text(content, encoding="utf-8")
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index ce5d14a31f43e92b2beabf64d377b3f5a08481fc..b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,7 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
-from mlx_ui.transcriber import FakeTranscriber, Transcriber
+from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
 
@@ -24,7 +24,7 @@
         self.db_path = Path(db_path)
         self.results_dir = Path(results_dir)
         self.poll_interval = poll_interval
-        self.transcriber = transcriber or FakeTranscriber()
+        self.transcriber = transcriber or WtmTranscriber()
         self._stop_event = threading.Event()
         self._thread: threading.Thread | None = None
 
diff --git a/tests/test_transcriber.py b/tests/test_transcriber.py
new file mode 100644
index 0000000000000000000000000000000000000000..b1eac06ae63a7c9c3de707e3dbc1b43da5d86f47
--- /dev/null
+++ b/tests/test_transcriber.py
@@ -0,0 +1,47 @@
+from datetime import datetime, timezone
+from pathlib import Path
+import subprocess
+
+from mlx_ui.db import JobRecord
+from mlx_ui.transcriber import WtmTranscriber
+
+
+def _make_job(tmp_path: Path) -> JobRecord:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    return JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="queued",
+        created_at=datetime(2024, 1, 1, tzinfo=timezone.utc).isoformat(timespec="seconds"),
+        upload_path=str(upload_path),
+    )
+
+
+def test_wtm_transcriber_runs_and_returns_txt(tmp_path: Path, monkeypatch) -> None:
+    job = _make_job(tmp_path)
+    results_dir = tmp_path / "results"
+    captured: dict[str, list[str]] = {}
+
+    def fake_run(cmd, capture_output, text, check):  # type: ignore[no-untyped-def]
+        captured["cmd"] = list(cmd)
+        output_dir = Path(cmd[cmd.index("--output_dir") + 1])
+        output_dir.mkdir(parents=True, exist_ok=True)
+        (output_dir / "sample.txt").write_text("hello", encoding="utf-8")
+        return subprocess.CompletedProcess(cmd, 0, stdout="ok", stderr="")
+
+    monkeypatch.setattr(subprocess, "run", fake_run)
+
+    transcriber = WtmTranscriber(wtm_path="wtm", language="fr")
+    result_path = transcriber.transcribe(job, results_dir)
+
+    assert result_path.is_file()
+    assert result_path.read_text(encoding="utf-8") == "hello"
+    assert captured["cmd"][0] == "wtm"
+    assert str(Path(job.upload_path)) in captured["cmd"]
+    assert "--language" in captured["cmd"]
+    assert "fr" in captured["cmd"]
+    assert "--output_dir" in captured["cmd"]
+    assert str(results_dir / job.id) in captured["cmd"]


thinking
**Checking linter configuration**

I'm verifying if Ruff is configured and used in linting by checking for its config presence and inspecting the Makefile to confirm if the lint target uses Ruff.
exec
/bin/zsh -lc 'cat Makefile' in /Users/ivankhokhlov/code/mlx-ui succeeded in 54ms:
PYTHON ?= python
POETRY ?= poetry
POETRY_RUN ?= $(POETRY) run

.PHONY: test lint fmt run

test:
	$(POETRY_RUN) pytest

lint:
	$(POETRY_RUN) ruff check .

fmt:
	$(POETRY_RUN) ruff format .

run:
	$(POETRY_RUN) uvicorn mlx_ui.app:app --host 127.0.0.1 --port 8000
file update:
diff --git a/docs/tree.md b/docs/tree.md
index b80b3c53d3b2148d4830121b7bfd9de2a390caec..9ad18896f5ab57fc92a96e6f89c0f4424e206def
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -9,7 +9,7 @@
 - `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run scripts (to be implemented)
-- `tests/` — pytest suite (`test_app.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/transcriber.py b/mlx_ui/transcriber.py
index 3716a8e4021ce98aeae0fbbd3e4f7411ce26de56..6e3e16f29ba6e0789cc382871fd925270342a799
--- a/mlx_ui/transcriber.py
+++ b/mlx_ui/transcriber.py
@@ -1,8 +1,13 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
 
 from mlx_ui.db import JobRecord
 
+logger = logging.getLogger(__name__)
+
 
 class Transcriber(Protocol):
     def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
@@ -18,3 +23,67 @@
         content = f"Fake transcript for {job.filename} ({job.id})\n"
         result_path.write_text(content, encoding="utf-8")
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index ce5d14a31f43e92b2beabf64d377b3f5a08481fc..b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,7 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
-from mlx_ui.transcriber import FakeTranscriber, Transcriber
+from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
 
@@ -24,7 +24,7 @@
         self.db_path = Path(db_path)
         self.results_dir = Path(results_dir)
         self.poll_interval = poll_interval
-        self.transcriber = transcriber or FakeTranscriber()
+        self.transcriber = transcriber or WtmTranscriber()
         self._stop_event = threading.Event()
         self._thread: threading.Thread | None = None
 
diff --git a/tests/test_transcriber.py b/tests/test_transcriber.py
new file mode 100644
index 0000000000000000000000000000000000000000..b1eac06ae63a7c9c3de707e3dbc1b43da5d86f47
--- /dev/null
+++ b/tests/test_transcriber.py
@@ -0,0 +1,47 @@
+from datetime import datetime, timezone
+from pathlib import Path
+import subprocess
+
+from mlx_ui.db import JobRecord
+from mlx_ui.transcriber import WtmTranscriber
+
+
+def _make_job(tmp_path: Path) -> JobRecord:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    return JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="queued",
+        created_at=datetime(2024, 1, 1, tzinfo=timezone.utc).isoformat(timespec="seconds"),
+        upload_path=str(upload_path),
+    )
+
+
+def test_wtm_transcriber_runs_and_returns_txt(tmp_path: Path, monkeypatch) -> None:
+    job = _make_job(tmp_path)
+    results_dir = tmp_path / "results"
+    captured: dict[str, list[str]] = {}
+
+    def fake_run(cmd, capture_output, text, check):  # type: ignore[no-untyped-def]
+        captured["cmd"] = list(cmd)
+        output_dir = Path(cmd[cmd.index("--output_dir") + 1])
+        output_dir.mkdir(parents=True, exist_ok=True)
+        (output_dir / "sample.txt").write_text("hello", encoding="utf-8")
+        return subprocess.CompletedProcess(cmd, 0, stdout="ok", stderr="")
+
+    monkeypatch.setattr(subprocess, "run", fake_run)
+
+    transcriber = WtmTranscriber(wtm_path="wtm", language="fr")
+    result_path = transcriber.transcribe(job, results_dir)
+
+    assert result_path.is_file()
+    assert result_path.read_text(encoding="utf-8") == "hello"
+    assert captured["cmd"][0] == "wtm"
+    assert str(Path(job.upload_path)) in captured["cmd"]
+    assert "--language" in captured["cmd"]
+    assert "fr" in captured["cmd"]
+    assert "--output_dir" in captured["cmd"]
+    assert str(results_dir / job.id) in captured["cmd"]



thinking
**Reviewing potential Ruff lint concerns**

I'm clarifying that Ruff's default checks include pyflakes and pycodestyle errors but not type hint enforcement, so we can likely remove unnecessary `# type: ignore` comments and untyped function def warnings won't trigger by default. I'm also confirming the use of `Path` and local variables like `captured` won't cause false positives.
thinking
**Preparing test and lint environment**

I'm confirming no immediate code or doc updates are needed besides ensuring `.agent/logs` exists before running tests and lint with output captured properly, while keeping existing transcriber usage and test coverage unchanged.
exec
/bin/zsh -lc 'mkdir -p .agent/logs' in /Users/ivankhokhlov/code/mlx-ui succeeded in 86ms:

file update:
diff --git a/docs/tree.md b/docs/tree.md
index b80b3c53d3b2148d4830121b7bfd9de2a390caec..9ad18896f5ab57fc92a96e6f89c0f4424e206def
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -9,7 +9,7 @@
 - `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run scripts (to be implemented)
-- `tests/` — pytest suite (`test_app.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/transcriber.py b/mlx_ui/transcriber.py
index 3716a8e4021ce98aeae0fbbd3e4f7411ce26de56..6e3e16f29ba6e0789cc382871fd925270342a799
--- a/mlx_ui/transcriber.py
+++ b/mlx_ui/transcriber.py
@@ -1,8 +1,13 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
 
 from mlx_ui.db import JobRecord
 
+logger = logging.getLogger(__name__)
+
 
 class Transcriber(Protocol):
     def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
@@ -18,3 +23,67 @@
         content = f"Fake transcript for {job.filename} ({job.id})\n"
         result_path.write_text(content, encoding="utf-8")
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index ce5d14a31f43e92b2beabf64d377b3f5a08481fc..b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,7 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
-from mlx_ui.transcriber import FakeTranscriber, Transcriber
+from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
 
@@ -24,7 +24,7 @@
         self.db_path = Path(db_path)
         self.results_dir = Path(results_dir)
         self.poll_interval = poll_interval
-        self.transcriber = transcriber or FakeTranscriber()
+        self.transcriber = transcriber or WtmTranscriber()
         self._stop_event = threading.Event()
         self._thread: threading.Thread | None = None
 
diff --git a/tests/test_transcriber.py b/tests/test_transcriber.py
new file mode 100644
index 0000000000000000000000000000000000000000..b1eac06ae63a7c9c3de707e3dbc1b43da5d86f47
--- /dev/null
+++ b/tests/test_transcriber.py
@@ -0,0 +1,47 @@
+from datetime import datetime, timezone
+from pathlib import Path
+import subprocess
+
+from mlx_ui.db import JobRecord
+from mlx_ui.transcriber import WtmTranscriber
+
+
+def _make_job(tmp_path: Path) -> JobRecord:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    return JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="queued",
+        created_at=datetime(2024, 1, 1, tzinfo=timezone.utc).isoformat(timespec="seconds"),
+        upload_path=str(upload_path),
+    )
+
+
+def test_wtm_transcriber_runs_and_returns_txt(tmp_path: Path, monkeypatch) -> None:
+    job = _make_job(tmp_path)
+    results_dir = tmp_path / "results"
+    captured: dict[str, list[str]] = {}
+
+    def fake_run(cmd, capture_output, text, check):  # type: ignore[no-untyped-def]
+        captured["cmd"] = list(cmd)
+        output_dir = Path(cmd[cmd.index("--output_dir") + 1])
+        output_dir.mkdir(parents=True, exist_ok=True)
+        (output_dir / "sample.txt").write_text("hello", encoding="utf-8")
+        return subprocess.CompletedProcess(cmd, 0, stdout="ok", stderr="")
+
+    monkeypatch.setattr(subprocess, "run", fake_run)
+
+    transcriber = WtmTranscriber(wtm_path="wtm", language="fr")
+    result_path = transcriber.transcribe(job, results_dir)
+
+    assert result_path.is_file()
+    assert result_path.read_text(encoding="utf-8") == "hello"
+    assert captured["cmd"][0] == "wtm"
+    assert str(Path(job.upload_path)) in captured["cmd"]
+    assert "--language" in captured["cmd"]
+    assert "fr" in captured["cmd"]
+    assert "--output_dir" in captured["cmd"]
+    assert str(results_dir / job.id) in captured["cmd"]


thinking
**Running tests with logging**
exec
/bin/zsh -lc 'bash -lc "set -o pipefail; make test 2>&1 | tee .agent/logs/test_${CODEX_ITERATION}.log"' in /Users/ivankhokhlov/code/mlx-ui succeeded in 1.57s:
poetry run pytest
============================= test session starts ==============================
platform darwin -- Python 3.12.12, pytest-8.4.2, pluggy-1.6.0
rootdir: /Users/ivankhokhlov/code/mlx-ui
configfile: pyproject.toml
plugins: anyio-4.12.1
collected 5 items

tests/test_app.py ...                                                    [ 60%]
tests/test_transcriber.py .                                              [ 80%]
tests/test_worker.py .                                                   [100%]

=============================== warnings summary ===============================
mlx_ui/app.py:25
  /Users/ivankhokhlov/code/mlx-ui/mlx_ui/app.py:25: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
file update:
diff --git a/docs/tree.md b/docs/tree.md
index b80b3c53d3b2148d4830121b7bfd9de2a390caec..9ad18896f5ab57fc92a96e6f89c0f4424e206def
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -9,7 +9,7 @@
 - `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run scripts (to be implemented)
-- `tests/` — pytest suite (`test_app.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/transcriber.py b/mlx_ui/transcriber.py
index 3716a8e4021ce98aeae0fbbd3e4f7411ce26de56..6e3e16f29ba6e0789cc382871fd925270342a799
--- a/mlx_ui/transcriber.py
+++ b/mlx_ui/transcriber.py
@@ -1,8 +1,13 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
 
 from mlx_ui.db import JobRecord
 
+logger = logging.getLogger(__name__)
+
 
 class Transcriber(Protocol):
     def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
@@ -18,3 +23,67 @@
         content = f"Fake transcript for {job.filename} ({job.id})\n"
         result_path.write_text(content, encoding="utf-8")
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index ce5d14a31f43e92b2beabf64d377b3f5a08481fc..b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,7 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
-from mlx_ui.transcriber import FakeTranscriber, Transcriber
+from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
 
@@ -24,7 +24,7 @@
         self.db_path = Path(db_path)
         self.results_dir = Path(results_dir)
         self.poll_interval = poll_interval
-        self.transcriber = transcriber or FakeTranscriber()
+        self.transcriber = transcriber or WtmTranscriber()
         self._stop_event = threading.Event()
         self._thread: threading.Thread | None = None
 
diff --git a/tests/test_transcriber.py b/tests/test_transcriber.py
new file mode 100644
index 0000000000000000000000000000000000000000..b1eac06ae63a7c9c3de707e3dbc1b43da5d86f47
--- /dev/null
+++ b/tests/test_transcriber.py
@@ -0,0 +1,47 @@
+from datetime import datetime, timezone
+from pathlib import Path
+import subprocess
+
+from mlx_ui.db import JobRecord
+from mlx_ui.transcriber import WtmTranscriber
+
+
+def _make_job(tmp_path: Path) -> JobRecord:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    return JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="queued",
+        created_at=datetime(2024, 1, 1, tzinfo=timezone.utc).isoformat(timespec="seconds"),
+        upload_path=str(upload_path),
+    )
+
+
+def test_wtm_transcriber_runs_and_returns_txt(tmp_path: Path, monkeypatch) -> None:
+    job = _make_job(tmp_path)
+    results_dir = tmp_path / "results"
+    captured: dict[str, list[str]] = {}
+
+    def fake_run(cmd, capture_output, text, check):  # type: ignore[no-untyped-def]
+        captured["cmd"] = list(cmd)
+        output_dir = Path(cmd[cmd.index("--output_dir") + 1])
+        output_dir.mkdir(parents=True, exist_ok=True)
+        (output_dir / "sample.txt").write_text("hello", encoding="utf-8")
+        return subprocess.CompletedProcess(cmd, 0, stdout="ok", stderr="")
+
+    monkeypatch.setattr(subprocess, "run", fake_run)
+
+    transcriber = WtmTranscriber(wtm_path="wtm", language="fr")
+    result_path = transcriber.transcribe(job, results_dir)
+
+    assert result_path.is_file()
+    assert result_path.read_text(encoding="utf-8") == "hello"
+    assert captured["cmd"][0] == "wtm"
+    assert str(Path(job.upload_path)) in captured["cmd"]
+    assert "--language" in captured["cmd"]
+    assert "fr" in captured["cmd"]
+    assert "--output_dir" in captured["cmd"]
+    assert str(results_dir / job.id) in captured["cmd"]


thinking
**Running lint checks**

Tests passed successfully, now proceeding to run lint checks with the same pattern.
exec
/bin/zsh -lc 'bash -lc "set -o pipefail; make lint 2>&1 | tee .agent/logs/lint_${CODEX_ITERATION}.log"' in /Users/ivankhokhlov/code/mlx-ui succeeded in 725ms:
poetry run ruff check .
All checks passed!
file update:
diff --git a/docs/tree.md b/docs/tree.md
index b80b3c53d3b2148d4830121b7bfd9de2a390caec..9ad18896f5ab57fc92a96e6f89c0f4424e206def
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -9,7 +9,7 @@
 - `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run scripts (to be implemented)
-- `tests/` — pytest suite (`test_app.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/transcriber.py b/mlx_ui/transcriber.py
index 3716a8e4021ce98aeae0fbbd3e4f7411ce26de56..6e3e16f29ba6e0789cc382871fd925270342a799
--- a/mlx_ui/transcriber.py
+++ b/mlx_ui/transcriber.py
@@ -1,8 +1,13 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
 
 from mlx_ui.db import JobRecord
 
+logger = logging.getLogger(__name__)
+
 
 class Transcriber(Protocol):
     def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
@@ -18,3 +23,67 @@
         content = f"Fake transcript for {job.filename} ({job.id})\n"
         result_path.write_text(content, encoding="utf-8")
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index ce5d14a31f43e92b2beabf64d377b3f5a08481fc..b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,7 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
-from mlx_ui.transcriber import FakeTranscriber, Transcriber
+from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
 
@@ -24,7 +24,7 @@
         self.db_path = Path(db_path)
         self.results_dir = Path(results_dir)
         self.poll_interval = poll_interval
-        self.transcriber = transcriber or FakeTranscriber()
+        self.transcriber = transcriber or WtmTranscriber()
         self._stop_event = threading.Event()
         self._thread: threading.Thread | None = None
 
diff --git a/tests/test_transcriber.py b/tests/test_transcriber.py
new file mode 100644
index 0000000000000000000000000000000000000000..b1eac06ae63a7c9c3de707e3dbc1b43da5d86f47
--- /dev/null
+++ b/tests/test_transcriber.py
@@ -0,0 +1,47 @@
+from datetime import datetime, timezone
+from pathlib import Path
+import subprocess
+
+from mlx_ui.db import JobRecord
+from mlx_ui.transcriber import WtmTranscriber
+
+
+def _make_job(tmp_path: Path) -> JobRecord:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    return JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="queued",
+        created_at=datetime(2024, 1, 1, tzinfo=timezone.utc).isoformat(timespec="seconds"),
+        upload_path=str(upload_path),
+    )
+
+
+def test_wtm_transcriber_runs_and_returns_txt(tmp_path: Path, monkeypatch) -> None:
+    job = _make_job(tmp_path)
+    results_dir = tmp_path / "results"
+    captured: dict[str, list[str]] = {}
+
+    def fake_run(cmd, capture_output, text, check):  # type: ignore[no-untyped-def]
+        captured["cmd"] = list(cmd)
+        output_dir = Path(cmd[cmd.index("--output_dir") + 1])
+        output_dir.mkdir(parents=True, exist_ok=True)
+        (output_dir / "sample.txt").write_text("hello", encoding="utf-8")
+        return subprocess.CompletedProcess(cmd, 0, stdout="ok", stderr="")
+
+    monkeypatch.setattr(subprocess, "run", fake_run)
+
+    transcriber = WtmTranscriber(wtm_path="wtm", language="fr")
+    result_path = transcriber.transcribe(job, results_dir)
+
+    assert result_path.is_file()
+    assert result_path.read_text(encoding="utf-8") == "hello"
+    assert captured["cmd"][0] == "wtm"
+    assert str(Path(job.upload_path)) in captured["cmd"]
+    assert "--language" in captured["cmd"]
+    assert "fr" in captured["cmd"]
+    assert "--output_dir" in captured["cmd"]
+    assert str(results_dir / job.id) in captured["cmd"]


thinking
**Preparing report updates**

Planning to update `.agent/worker_report.md` with task details and append `.agent/progress.md` with a timestamped summary including iteration, task ID, and test/lint status, using ISO timestamps and environment variables for context.
exec
/bin/zsh -lc 'cat .agent/worker_report.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 96ms:
# Worker Report

Task: WUI-012 - Sequential worker + fake transcriber

What changed:
- Added an atomic job-claim API plus status updates for queued/running/done/failed.
- Implemented a single background worker and fake transcriber that writes deterministic TXT output.
- Wired worker startup into app startup and added a sequential worker test.
- Updated existing app tests to keep the worker disabled during upload checks.
- Updated docs tree to reflect new modules/tests.

Files changed:
- mlx_ui/app.py
- mlx_ui/db.py
- mlx_ui/transcriber.py
- mlx_ui/worker.py
- tests/test_app.py
- tests/test_worker.py
- docs/tree.md

file update:
diff --git a/docs/tree.md b/docs/tree.md
index b80b3c53d3b2148d4830121b7bfd9de2a390caec..9ad18896f5ab57fc92a96e6f89c0f4424e206def
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -9,7 +9,7 @@
 - `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run scripts (to be implemented)
-- `tests/` — pytest suite (`test_app.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/transcriber.py b/mlx_ui/transcriber.py
index 3716a8e4021ce98aeae0fbbd3e4f7411ce26de56..6e3e16f29ba6e0789cc382871fd925270342a799
--- a/mlx_ui/transcriber.py
+++ b/mlx_ui/transcriber.py
@@ -1,8 +1,13 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
 
 from mlx_ui.db import JobRecord
 
+logger = logging.getLogger(__name__)
+
 
 class Transcriber(Protocol):
     def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
@@ -18,3 +23,67 @@
         content = f"Fake transcript for {job.filename} ({job.id})\n"
         result_path.write_text(content, encoding="utf-8")
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index ce5d14a31f43e92b2beabf64d377b3f5a08481fc..b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,7 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
-from mlx_ui.transcriber import FakeTranscriber, Transcriber
+from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
 
@@ -24,7 +24,7 @@
         self.db_path = Path(db_path)
         self.results_dir = Path(results_dir)
         self.poll_interval = poll_interval
-        self.transcriber = transcriber or FakeTranscriber()
+        self.transcriber = transcriber or WtmTranscriber()
         self._stop_event = threading.Event()
         self._thread: threading.Thread | None = None
 
diff --git a/tests/test_transcriber.py b/tests/test_transcriber.py
new file mode 100644
index 0000000000000000000000000000000000000000..b1eac06ae63a7c9c3de707e3dbc1b43da5d86f47
--- /dev/null
+++ b/tests/test_transcriber.py
@@ -0,0 +1,47 @@
+from datetime import datetime, timezone
+from pathlib import Path
+import subprocess
+
+from mlx_ui.db import JobRecord
+from mlx_ui.transcriber import WtmTranscriber
+
+
+def _make_job(tmp_path: Path) -> JobRecord:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    return JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="queued",
+        created_at=datetime(2024, 1, 1, tzinfo=timezone.utc).isoformat(timespec="seconds"),
+        upload_path=str(upload_path),
+    )
+
+
+def test_wtm_transcriber_runs_and_returns_txt(tmp_path: Path, monkeypatch) -> None:
+    job = _make_job(tmp_path)
+    results_dir = tmp_path / "results"
+    captured: dict[str, list[str]] = {}
+
+    def fake_run(cmd, capture_output, text, check):  # type: ignore[no-untyped-def]
+        captured["cmd"] = list(cmd)
+        output_dir = Path(cmd[cmd.index("--output_dir") + 1])
+        output_dir.mkdir(parents=True, exist_ok=True)
+        (output_dir / "sample.txt").write_text("hello", encoding="utf-8")
+        return subprocess.CompletedProcess(cmd, 0, stdout="ok", stderr="")
+
+    monkeypatch.setattr(subprocess, "run", fake_run)
+
+    transcriber = WtmTranscriber(wtm_path="wtm", language="fr")
+    result_path = transcriber.transcribe(job, results_dir)
+
+    assert result_path.is_file()
+    assert result_path.read_text(encoding="utf-8") == "hello"
+    assert captured["cmd"][0] == "wtm"
+    assert str(Path(job.upload_path)) in captured["cmd"]
+    assert "--language" in captured["cmd"]
+    assert "fr" in captured["cmd"]
+    assert "--output_dir" in captured["cmd"]
+    assert str(results_dir / job.id) in captured["cmd"]


thinking
**Writing worker report**

I'm preparing a new worker report for WUI-020 detailing changes, commands run with pass results, and noting no failure errors; will ensure logs directory exists and save this in .agent/worker_report.md.
exec
/bin/zsh -lc "cat <<'EOF' > .agent/worker_report.md
# Worker Report

Task: WUI-020 - Integrate "'`wtm` CLI transcription

What changed:
- Added a WTM-backed transcriber that builds the CLI command with language/output dir and validates TXT output.
- Switched the worker default transcriber to the WTM implementation.
- Added a subprocess-mocked transcriber test to avoid running the real model.
- Updated the project tree docs to include the new test file.

Files changed:
- mlx_ui/transcriber.py
- mlx_ui/worker.py
- tests/test_transcriber.py
- docs/tree.md

Commands run:
- make test (pass)
- make lint (pass)
EOF' in /Users/ivankhokhlov/code/mlx-ui succeeded in 78ms:

file update:
diff --git a/docs/tree.md b/docs/tree.md
index b80b3c53d3b2148d4830121b7bfd9de2a390caec..9ad18896f5ab57fc92a96e6f89c0f4424e206def
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -9,7 +9,7 @@
 - `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run scripts (to be implemented)
-- `tests/` — pytest suite (`test_app.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/transcriber.py b/mlx_ui/transcriber.py
index 3716a8e4021ce98aeae0fbbd3e4f7411ce26de56..6e3e16f29ba6e0789cc382871fd925270342a799
--- a/mlx_ui/transcriber.py
+++ b/mlx_ui/transcriber.py
@@ -1,8 +1,13 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
 
 from mlx_ui.db import JobRecord
 
+logger = logging.getLogger(__name__)
+
 
 class Transcriber(Protocol):
     def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
@@ -18,3 +23,67 @@
         content = f"Fake transcript for {job.filename} ({job.id})\n"
         result_path.write_text(content, encoding="utf-8")
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index ce5d14a31f43e92b2beabf64d377b3f5a08481fc..b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,7 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
-from mlx_ui.transcriber import FakeTranscriber, Transcriber
+from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
 
@@ -24,7 +24,7 @@
         self.db_path = Path(db_path)
         self.results_dir = Path(results_dir)
         self.poll_interval = poll_interval
-        self.transcriber = transcriber or FakeTranscriber()
+        self.transcriber = transcriber or WtmTranscriber()
         self._stop_event = threading.Event()
         self._thread: threading.Thread | None = None
 
diff --git a/tests/test_transcriber.py b/tests/test_transcriber.py
new file mode 100644
index 0000000000000000000000000000000000000000..b1eac06ae63a7c9c3de707e3dbc1b43da5d86f47
--- /dev/null
+++ b/tests/test_transcriber.py
@@ -0,0 +1,47 @@
+from datetime import datetime, timezone
+from pathlib import Path
+import subprocess
+
+from mlx_ui.db import JobRecord
+from mlx_ui.transcriber import WtmTranscriber
+
+
+def _make_job(tmp_path: Path) -> JobRecord:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    return JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="queued",
+        created_at=datetime(2024, 1, 1, tzinfo=timezone.utc).isoformat(timespec="seconds"),
+        upload_path=str(upload_path),
+    )
+
+
+def test_wtm_transcriber_runs_and_returns_txt(tmp_path: Path, monkeypatch) -> None:
+    job = _make_job(tmp_path)
+    results_dir = tmp_path / "results"
+    captured: dict[str, list[str]] = {}
+
+    def fake_run(cmd, capture_output, text, check):  # type: ignore[no-untyped-def]
+        captured["cmd"] = list(cmd)
+        output_dir = Path(cmd[cmd.index("--output_dir") + 1])
+        output_dir.mkdir(parents=True, exist_ok=True)
+        (output_dir / "sample.txt").write_text("hello", encoding="utf-8")
+        return subprocess.CompletedProcess(cmd, 0, stdout="ok", stderr="")
+
+    monkeypatch.setattr(subprocess, "run", fake_run)
+
+    transcriber = WtmTranscriber(wtm_path="wtm", language="fr")
+    result_path = transcriber.transcribe(job, results_dir)
+
+    assert result_path.is_file()
+    assert result_path.read_text(encoding="utf-8") == "hello"
+    assert captured["cmd"][0] == "wtm"
+    assert str(Path(job.upload_path)) in captured["cmd"]
+    assert "--language" in captured["cmd"]
+    assert "fr" in captured["cmd"]
+    assert "--output_dir" in captured["cmd"]
+    assert str(results_dir / job.id) in captured["cmd"]


thinking
**Appending progress with iteration info**

I'll fetch the CODEX_ITERATION environment variable to include a timestamped summary with task ID and test/lint results in .agent/progress.md.
exec
/bin/zsh -lc 'echo $CODEX_ITERATION' in /Users/ivankhokhlov/code/mlx-ui succeeded in 66ms:
8
file update:
diff --git a/docs/tree.md b/docs/tree.md
index b80b3c53d3b2148d4830121b7bfd9de2a390caec..9ad18896f5ab57fc92a96e6f89c0f4424e206def
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -9,7 +9,7 @@
 - `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run scripts (to be implemented)
-- `tests/` — pytest suite (`test_app.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/transcriber.py b/mlx_ui/transcriber.py
index 3716a8e4021ce98aeae0fbbd3e4f7411ce26de56..6e3e16f29ba6e0789cc382871fd925270342a799
--- a/mlx_ui/transcriber.py
+++ b/mlx_ui/transcriber.py
@@ -1,8 +1,13 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
 
 from mlx_ui.db import JobRecord
 
+logger = logging.getLogger(__name__)
+
 
 class Transcriber(Protocol):
     def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
@@ -18,3 +23,67 @@
         content = f"Fake transcript for {job.filename} ({job.id})\n"
         result_path.write_text(content, encoding="utf-8")
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index ce5d14a31f43e92b2beabf64d377b3f5a08481fc..b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,7 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
-from mlx_ui.transcriber import FakeTranscriber, Transcriber
+from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
 
@@ -24,7 +24,7 @@
         self.db_path = Path(db_path)
         self.results_dir = Path(results_dir)
         self.poll_interval = poll_interval
-        self.transcriber = transcriber or FakeTranscriber()
+        self.transcriber = transcriber or WtmTranscriber()
         self._stop_event = threading.Event()
         self._thread: threading.Thread | None = None
 
diff --git a/tests/test_transcriber.py b/tests/test_transcriber.py
new file mode 100644
index 0000000000000000000000000000000000000000..b1eac06ae63a7c9c3de707e3dbc1b43da5d86f47
--- /dev/null
+++ b/tests/test_transcriber.py
@@ -0,0 +1,47 @@
+from datetime import datetime, timezone
+from pathlib import Path
+import subprocess
+
+from mlx_ui.db import JobRecord
+from mlx_ui.transcriber import WtmTranscriber
+
+
+def _make_job(tmp_path: Path) -> JobRecord:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    return JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="queued",
+        created_at=datetime(2024, 1, 1, tzinfo=timezone.utc).isoformat(timespec="seconds"),
+        upload_path=str(upload_path),
+    )
+
+
+def test_wtm_transcriber_runs_and_returns_txt(tmp_path: Path, monkeypatch) -> None:
+    job = _make_job(tmp_path)
+    results_dir = tmp_path / "results"
+    captured: dict[str, list[str]] = {}
+
+    def fake_run(cmd, capture_output, text, check):  # type: ignore[no-untyped-def]
+        captured["cmd"] = list(cmd)
+        output_dir = Path(cmd[cmd.index("--output_dir") + 1])
+        output_dir.mkdir(parents=True, exist_ok=True)
+        (output_dir / "sample.txt").write_text("hello", encoding="utf-8")
+        return subprocess.CompletedProcess(cmd, 0, stdout="ok", stderr="")
+
+    monkeypatch.setattr(subprocess, "run", fake_run)
+
+    transcriber = WtmTranscriber(wtm_path="wtm", language="fr")
+    result_path = transcriber.transcribe(job, results_dir)
+
+    assert result_path.is_file()
+    assert result_path.read_text(encoding="utf-8") == "hello"
+    assert captured["cmd"][0] == "wtm"
+    assert str(Path(job.upload_path)) in captured["cmd"]
+    assert "--language" in captured["cmd"]
+    assert "fr" in captured["cmd"]
+    assert "--output_dir" in captured["cmd"]
+    assert str(results_dir / job.id) in captured["cmd"]


thinking
**Deciding timestamp format**

I'm choosing the UTC timestamp format `date -u +"%Y-%m-%dT%H:%M:%SZ"` for consistent time recording.
exec
/bin/zsh -lc 'date -u "+%Y-%m-%dT%H:%M:%SZ"' in /Users/ivankhokhlov/code/mlx-ui succeeded in 73ms:
2026-01-21T12:19:43Z
file update:
diff --git a/docs/tree.md b/docs/tree.md
index b80b3c53d3b2148d4830121b7bfd9de2a390caec..9ad18896f5ab57fc92a96e6f89c0f4424e206def
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -9,7 +9,7 @@
 - `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run scripts (to be implemented)
-- `tests/` — pytest suite (`test_app.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/transcriber.py b/mlx_ui/transcriber.py
index 3716a8e4021ce98aeae0fbbd3e4f7411ce26de56..6e3e16f29ba6e0789cc382871fd925270342a799
--- a/mlx_ui/transcriber.py
+++ b/mlx_ui/transcriber.py
@@ -1,8 +1,13 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
 
 from mlx_ui.db import JobRecord
 
+logger = logging.getLogger(__name__)
+
 
 class Transcriber(Protocol):
     def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
@@ -18,3 +23,67 @@
         content = f"Fake transcript for {job.filename} ({job.id})\n"
         result_path.write_text(content, encoding="utf-8")
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index ce5d14a31f43e92b2beabf64d377b3f5a08481fc..b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,7 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
-from mlx_ui.transcriber import FakeTranscriber, Transcriber
+from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
 
@@ -24,7 +24,7 @@
         self.db_path = Path(db_path)
         self.results_dir = Path(results_dir)
         self.poll_interval = poll_interval
-        self.transcriber = transcriber or FakeTranscriber()
+        self.transcriber = transcriber or WtmTranscriber()
         self._stop_event = threading.Event()
         self._thread: threading.Thread | None = None
 
diff --git a/tests/test_transcriber.py b/tests/test_transcriber.py
new file mode 100644
index 0000000000000000000000000000000000000000..b1eac06ae63a7c9c3de707e3dbc1b43da5d86f47
--- /dev/null
+++ b/tests/test_transcriber.py
@@ -0,0 +1,47 @@
+from datetime import datetime, timezone
+from pathlib import Path
+import subprocess
+
+from mlx_ui.db import JobRecord
+from mlx_ui.transcriber import WtmTranscriber
+
+
+def _make_job(tmp_path: Path) -> JobRecord:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    return JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="queued",
+        created_at=datetime(2024, 1, 1, tzinfo=timezone.utc).isoformat(timespec="seconds"),
+        upload_path=str(upload_path),
+    )
+
+
+def test_wtm_transcriber_runs_and_returns_txt(tmp_path: Path, monkeypatch) -> None:
+    job = _make_job(tmp_path)
+    results_dir = tmp_path / "results"
+    captured: dict[str, list[str]] = {}
+
+    def fake_run(cmd, capture_output, text, check):  # type: ignore[no-untyped-def]
+        captured["cmd"] = list(cmd)
+        output_dir = Path(cmd[cmd.index("--output_dir") + 1])
+        output_dir.mkdir(parents=True, exist_ok=True)
+        (output_dir / "sample.txt").write_text("hello", encoding="utf-8")
+        return subprocess.CompletedProcess(cmd, 0, stdout="ok", stderr="")
+
+    monkeypatch.setattr(subprocess, "run", fake_run)
+
+    transcriber = WtmTranscriber(wtm_path="wtm", language="fr")
+    result_path = transcriber.transcribe(job, results_dir)
+
+    assert result_path.is_file()
+    assert result_path.read_text(encoding="utf-8") == "hello"
+    assert captured["cmd"][0] == "wtm"
+    assert str(Path(job.upload_path)) in captured["cmd"]
+    assert "--language" in captured["cmd"]
+    assert "fr" in captured["cmd"]
+    assert "--output_dir" in captured["cmd"]
+    assert str(results_dir / job.id) in captured["cmd"]


thinking
**Appending progress entry**

I'm adding a new progress line following the established format with the latest timestamp, iteration, and test/lint results.
exec
/bin/zsh -lc 'echo "- 2026-01-21T12:19:43Z — WORKER — CODEX_ITERATION=8 — WUI-020 — tests: passed (make test); lint: passed (make lint)" >> .agent/progress.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 85ms:

file update:
diff --git a/docs/tree.md b/docs/tree.md
index b80b3c53d3b2148d4830121b7bfd9de2a390caec..9ad18896f5ab57fc92a96e6f89c0f4424e206def
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -9,7 +9,7 @@
 - `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run scripts (to be implemented)
-- `tests/` — pytest suite (`test_app.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/transcriber.py b/mlx_ui/transcriber.py
index 3716a8e4021ce98aeae0fbbd3e4f7411ce26de56..6e3e16f29ba6e0789cc382871fd925270342a799
--- a/mlx_ui/transcriber.py
+++ b/mlx_ui/transcriber.py
@@ -1,8 +1,13 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
 
 from mlx_ui.db import JobRecord
 
+logger = logging.getLogger(__name__)
+
 
 class Transcriber(Protocol):
     def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
@@ -18,3 +23,67 @@
         content = f"Fake transcript for {job.filename} ({job.id})\n"
         result_path.write_text(content, encoding="utf-8")
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index ce5d14a31f43e92b2beabf64d377b3f5a08481fc..b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,7 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
-from mlx_ui.transcriber import FakeTranscriber, Transcriber
+from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
 
@@ -24,7 +24,7 @@
         self.db_path = Path(db_path)
         self.results_dir = Path(results_dir)
         self.poll_interval = poll_interval
-        self.transcriber = transcriber or FakeTranscriber()
+        self.transcriber = transcriber or WtmTranscriber()
         self._stop_event = threading.Event()
         self._thread: threading.Thread | None = None
 
diff --git a/tests/test_transcriber.py b/tests/test_transcriber.py
new file mode 100644
index 0000000000000000000000000000000000000000..b1eac06ae63a7c9c3de707e3dbc1b43da5d86f47
--- /dev/null
+++ b/tests/test_transcriber.py
@@ -0,0 +1,47 @@
+from datetime import datetime, timezone
+from pathlib import Path
+import subprocess
+
+from mlx_ui.db import JobRecord
+from mlx_ui.transcriber import WtmTranscriber
+
+
+def _make_job(tmp_path: Path) -> JobRecord:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    return JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="queued",
+        created_at=datetime(2024, 1, 1, tzinfo=timezone.utc).isoformat(timespec="seconds"),
+        upload_path=str(upload_path),
+    )
+
+
+def test_wtm_transcriber_runs_and_returns_txt(tmp_path: Path, monkeypatch) -> None:
+    job = _make_job(tmp_path)
+    results_dir = tmp_path / "results"
+    captured: dict[str, list[str]] = {}
+
+    def fake_run(cmd, capture_output, text, check):  # type: ignore[no-untyped-def]
+        captured["cmd"] = list(cmd)
+        output_dir = Path(cmd[cmd.index("--output_dir") + 1])
+        output_dir.mkdir(parents=True, exist_ok=True)
+        (output_dir / "sample.txt").write_text("hello", encoding="utf-8")
+        return subprocess.CompletedProcess(cmd, 0, stdout="ok", stderr="")
+
+    monkeypatch.setattr(subprocess, "run", fake_run)
+
+    transcriber = WtmTranscriber(wtm_path="wtm", language="fr")
+    result_path = transcriber.transcribe(job, results_dir)
+
+    assert result_path.is_file()
+    assert result_path.read_text(encoding="utf-8") == "hello"
+    assert captured["cmd"][0] == "wtm"
+    assert str(Path(job.upload_path)) in captured["cmd"]
+    assert "--language" in captured["cmd"]
+    assert "fr" in captured["cmd"]
+    assert "--output_dir" in captured["cmd"]
+    assert str(results_dir / job.id) in captured["cmd"]


thinking
**Checking changed files**

I'm verifying test results for BLOCKED? scenarios and using `git status -sb` to summarize modified files for awareness, though not strictly required.
exec
/bin/zsh -lc 'git status -sb' in /Users/ivankhokhlov/code/mlx-ui succeeded in 89ms:
## master
 M .agent/last_judge.txt
 M .agent/last_planner.txt
 M .agent/logs/judge_7.err
 M .agent/logs/judge_7.out
 M .agent/plan.md
 M .agent/progress.md
 M .agent/queue.md
 M .agent/worker_report.md
 M docs/tree.md
 M mlx_ui/transcriber.py
 M mlx_ui/worker.py
?? .agent/logs/lint_8.log
?? .agent/logs/planner_8.err
?? .agent/logs/planner_8.out
?? .agent/logs/test_8.log
?? .agent/logs/worker_8.err
?? .agent/logs/worker_8.out
?? data/
?? tests/test_transcriber.py
file update:
diff --git a/docs/tree.md b/docs/tree.md
index b80b3c53d3b2148d4830121b7bfd9de2a390caec..9ad18896f5ab57fc92a96e6f89c0f4424e206def
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -9,7 +9,7 @@
 - `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run scripts (to be implemented)
-- `tests/` — pytest suite (`test_app.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/transcriber.py b/mlx_ui/transcriber.py
index 3716a8e4021ce98aeae0fbbd3e4f7411ce26de56..6e3e16f29ba6e0789cc382871fd925270342a799
--- a/mlx_ui/transcriber.py
+++ b/mlx_ui/transcriber.py
@@ -1,8 +1,13 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
 
 from mlx_ui.db import JobRecord
 
+logger = logging.getLogger(__name__)
+
 
 class Transcriber(Protocol):
     def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
@@ -18,3 +23,67 @@
         content = f"Fake transcript for {job.filename} ({job.id})\n"
         result_path.write_text(content, encoding="utf-8")
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index ce5d14a31f43e92b2beabf64d377b3f5a08481fc..b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,7 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
-from mlx_ui.transcriber import FakeTranscriber, Transcriber
+from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
 
@@ -24,7 +24,7 @@
         self.db_path = Path(db_path)
         self.results_dir = Path(results_dir)
         self.poll_interval = poll_interval
-        self.transcriber = transcriber or FakeTranscriber()
+        self.transcriber = transcriber or WtmTranscriber()
         self._stop_event = threading.Event()
         self._thread: threading.Thread | None = None
 
diff --git a/tests/test_transcriber.py b/tests/test_transcriber.py
new file mode 100644
index 0000000000000000000000000000000000000000..b1eac06ae63a7c9c3de707e3dbc1b43da5d86f47
--- /dev/null
+++ b/tests/test_transcriber.py
@@ -0,0 +1,47 @@
+from datetime import datetime, timezone
+from pathlib import Path
+import subprocess
+
+from mlx_ui.db import JobRecord
+from mlx_ui.transcriber import WtmTranscriber
+
+
+def _make_job(tmp_path: Path) -> JobRecord:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    return JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="queued",
+        created_at=datetime(2024, 1, 1, tzinfo=timezone.utc).isoformat(timespec="seconds"),
+        upload_path=str(upload_path),
+    )
+
+
+def test_wtm_transcriber_runs_and_returns_txt(tmp_path: Path, monkeypatch) -> None:
+    job = _make_job(tmp_path)
+    results_dir = tmp_path / "results"
+    captured: dict[str, list[str]] = {}
+
+    def fake_run(cmd, capture_output, text, check):  # type: ignore[no-untyped-def]
+        captured["cmd"] = list(cmd)
+        output_dir = Path(cmd[cmd.index("--output_dir") + 1])
+        output_dir.mkdir(parents=True, exist_ok=True)
+        (output_dir / "sample.txt").write_text("hello", encoding="utf-8")
+        return subprocess.CompletedProcess(cmd, 0, stdout="ok", stderr="")
+
+    monkeypatch.setattr(subprocess, "run", fake_run)
+
+    transcriber = WtmTranscriber(wtm_path="wtm", language="fr")
+    result_path = transcriber.transcribe(job, results_dir)
+
+    assert result_path.is_file()
+    assert result_path.read_text(encoding="utf-8") == "hello"
+    assert captured["cmd"][0] == "wtm"
+    assert str(Path(job.upload_path)) in captured["cmd"]
+    assert "--language" in captured["cmd"]
+    assert "fr" in captured["cmd"]
+    assert "--output_dir" in captured["cmd"]
+    assert str(results_dir / job.id) in captured["cmd"]



thinking
**Confirming existing changes and final summary needs**

The existing changes in `.agent` logs and data appear from prior tests and harness runs, so I’ll keep them intact. Key final steps are updating the worker report and progress, ensuring the transcriber respects offline and sequential-queue requirements, and producing a clear summary of implementations, tests passed, and log/report file locations for the final message.
thinking
**Crafting final summary and next steps**

The final message will start with a concise explanation of integrating the `WtmTranscriber` that runs `wtm` CLI with environment-variable support and offline-safe mocked tests. Then, it will detail file changes including the transcriber class, worker default, new test, and docs update. It will report test and lint pass status with log file paths `.agent/logs/test_8.log` and `.agent/logs/lint_8.log`, plus point to `.agent/worker_report.md`. Finally, it will offer two natural next steps as a numeric list: running `make run` and setting `WTM_PATH` or `WTM_LANGUAGE`. This approach meets formatting instructions and covers all key info clearly without unnecessary warnings or questions.
codex
Integrated a `wtm`-backed transcriber so the worker now runs the CLI with a language/output directory and verifies TXT output, with subprocess mocked in tests to avoid the real model.
- `mlx_ui/transcriber.py`: added `WtmTranscriber` (env `WTM_PATH`, `WTM_LANGUAGE`) plus error handling and TXT discovery.
- `mlx_ui/worker.py`: default transcriber now uses `WtmTranscriber` when none is injected.
- `tests/test_transcriber.py`: new mocked-subprocess test that asserts the CLI command and resulting TXT path.
- `docs/tree.md`: documented the new test file.

Tests: `make test` (pass, log `.agent/logs/test_8.log`); `make lint` (pass, log `.agent/logs/lint_8.log`).
Worker report: `.agent/worker_report.md`.

Next steps (optional):
1) Run `make run` and upload a file to exercise `wtm` end-to-end on your machine.
2) Set `WTM_PATH` or `WTM_LANGUAGE` if your CLI lives outside PATH or you want a different default language.
file update:
diff --git a/docs/tree.md b/docs/tree.md
index b80b3c53d3b2148d4830121b7bfd9de2a390caec..9ad18896f5ab57fc92a96e6f89c0f4424e206def
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -9,7 +9,7 @@
 - `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run scripts (to be implemented)
-- `tests/` — pytest suite (`test_app.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/transcriber.py b/mlx_ui/transcriber.py
index 3716a8e4021ce98aeae0fbbd3e4f7411ce26de56..6e3e16f29ba6e0789cc382871fd925270342a799
--- a/mlx_ui/transcriber.py
+++ b/mlx_ui/transcriber.py
@@ -1,8 +1,13 @@
+import logging
+import os
 from pathlib import Path
+import subprocess
 from typing import Protocol
 
 from mlx_ui.db import JobRecord
 
+logger = logging.getLogger(__name__)
+
 
 class Transcriber(Protocol):
     def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
@@ -18,3 +23,67 @@
         content = f"Fake transcript for {job.filename} ({job.id})\n"
         result_path.write_text(content, encoding="utf-8")
         return result_path
+
+
+class WtmTranscriber:
+    def __init__(
+        self,
+        wtm_path: str | None = None,
+        language: str | None = None,
+    ) -> None:
+        self.wtm_path = wtm_path or os.getenv("WTM_PATH") or "wtm"
+        self.language = (language or os.getenv("WTM_LANGUAGE") or "en").strip() or "en"
+
+    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
+        results_dir = Path(results_dir)
+        results_dir.mkdir(parents=True, exist_ok=True)
+        job_dir = results_dir / job.id
+        job_dir.mkdir(parents=True, exist_ok=True)
+        source_path = Path(job.upload_path)
+        language = getattr(job, "language", None) or self.language
+        command = [
+            self.wtm_path,
+            str(source_path),
+            "--language",
+            language,
+            "--output_dir",
+            str(job_dir),
+        ]
+        logger.info("Running wtm for job %s", job.id)
+        try:
+            subprocess.run(
+                command,
+                capture_output=True,
+                text=True,
+                check=True,
+            )
+        except subprocess.CalledProcessError as exc:
+            message = _format_wtm_error(exc)
+            raise RuntimeError(message) from exc
+
+        txt_results = sorted(job_dir.glob("*.txt"))
+        if not txt_results:
+            raise FileNotFoundError(
+                f"wtm completed but no .txt output found in {job_dir}"
+            )
+        return txt_results[0]
+
+
+def _format_wtm_error(error: subprocess.CalledProcessError) -> str:
+    stdout = _tail_text(error.stdout)
+    stderr = _tail_text(error.stderr)
+    message = f"wtm failed with exit code {error.returncode}"
+    if stderr:
+        message = f"{message}; stderr: {stderr}"
+    if stdout:
+        message = f"{message}; stdout: {stdout}"
+    return message
+
+
+def _tail_text(text: str | None, limit: int = 2000) -> str:
+    if not text:
+        return ""
+    trimmed = text.strip()
+    if len(trimmed) <= limit:
+        return trimmed
+    return trimmed[-limit:]
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index ce5d14a31f43e92b2beabf64d377b3f5a08481fc..b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,7 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
-from mlx_ui.transcriber import FakeTranscriber, Transcriber
+from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
 
@@ -24,7 +24,7 @@
         self.db_path = Path(db_path)
         self.results_dir = Path(results_dir)
         self.poll_interval = poll_interval
-        self.transcriber = transcriber or FakeTranscriber()
+        self.transcriber = transcriber or WtmTranscriber()
         self._stop_event = threading.Event()
         self._thread: threading.Thread | None = None
 
diff --git a/tests/test_transcriber.py b/tests/test_transcriber.py
new file mode 100644
index 0000000000000000000000000000000000000000..b1eac06ae63a7c9c3de707e3dbc1b43da5d86f47
--- /dev/null
+++ b/tests/test_transcriber.py
@@ -0,0 +1,47 @@
+from datetime import datetime, timezone
+from pathlib import Path
+import subprocess
+
+from mlx_ui.db import JobRecord
+from mlx_ui.transcriber import WtmTranscriber
+
+
+def _make_job(tmp_path: Path) -> JobRecord:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    return JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="queued",
+        created_at=datetime(2024, 1, 1, tzinfo=timezone.utc).isoformat(timespec="seconds"),
+        upload_path=str(upload_path),
+    )
+
+
+def test_wtm_transcriber_runs_and_returns_txt(tmp_path: Path, monkeypatch) -> None:
+    job = _make_job(tmp_path)
+    results_dir = tmp_path / "results"
+    captured: dict[str, list[str]] = {}
+
+    def fake_run(cmd, capture_output, text, check):  # type: ignore[no-untyped-def]
+        captured["cmd"] = list(cmd)
+        output_dir = Path(cmd[cmd.index("--output_dir") + 1])
+        output_dir.mkdir(parents=True, exist_ok=True)
+        (output_dir / "sample.txt").write_text("hello", encoding="utf-8")
+        return subprocess.CompletedProcess(cmd, 0, stdout="ok", stderr="")
+
+    monkeypatch.setattr(subprocess, "run", fake_run)
+
+    transcriber = WtmTranscriber(wtm_path="wtm", language="fr")
+    result_path = transcriber.transcribe(job, results_dir)
+
+    assert result_path.is_file()
+    assert result_path.read_text(encoding="utf-8") == "hello"
+    assert captured["cmd"][0] == "wtm"
+    assert str(Path(job.upload_path)) in captured["cmd"]
+    assert "--language" in captured["cmd"]
+    assert "fr" in captured["cmd"]
+    assert "--output_dir" in captured["cmd"]
+    assert str(results_dir / job.id) in captured["cmd"]

tokens used
60,658
