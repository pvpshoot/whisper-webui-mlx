<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Whisper WebUI (MLX)</title>
    <style>
      :root {
        --ink: #1d1b16;
        --ink-muted: #5d5d5d;
        --panel: #fff7ee;
        --accent: #d46a3e;
        --accent-strong: #8b3f1f;
        --shadow: 0 24px 60px rgba(29, 27, 22, 0.12);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Avenir Next", Avenir, "Gill Sans", sans-serif;
        color: var(--ink);
        background: radial-gradient(circle at top left, #f6e6d4, transparent 55%),
          radial-gradient(circle at bottom right, #cfe1f2, transparent 45%),
          #f5f1ea;
      }

      main {
        max-width: 980px;
        margin: 0 auto;
        padding: 48px 24px 64px;
      }

      .hero {
        display: flex;
        flex-wrap: wrap;
        gap: 24px;
        align-items: center;
        justify-content: space-between;
      }

      .eyebrow {
        text-transform: uppercase;
        letter-spacing: 0.18em;
        font-size: 0.72rem;
        color: var(--accent-strong);
      }

      h1 {
        margin: 8px 0 10px;
        font-size: clamp(2rem, 3vw, 3rem);
      }

      h2 {
        margin: 0;
        font-size: clamp(1.5rem, 2.4vw, 2rem);
        letter-spacing: -0.01em;
      }

      p {
        margin: 0;
        color: var(--ink-muted);
        line-height: 1.5;
      }

      .status-card {
        background: var(--panel);
        border: 1px solid #f1e2d2;
        border-radius: 16px;
        padding: 16px 20px;
        min-width: 180px;
        box-shadow: var(--shadow);
      }

      .status-label {
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.14em;
        color: var(--accent-strong);
      }

      .status {
        font-size: 1.4rem;
        font-weight: 700;
        margin: 6px 0;
      }

      .status-meta {
        font-size: 0.85rem;
        color: var(--ink-muted);
        margin: 0;
      }

      .tabs {
        margin-top: 32px;
      }

      .tablist {
        display: flex;
        gap: 12px;
        padding: 8px;
        border-radius: 14px;
        background: rgba(255, 255, 255, 0.7);
        box-shadow: 0 12px 30px rgba(29, 27, 22, 0.08);
      }

      .tab {
        appearance: none;
        border: none;
        background: transparent;
        padding: 10px 18px;
        border-radius: 10px;
        font-size: 1rem;
        font-weight: 600;
        color: var(--ink);
        cursor: pointer;
        text-decoration: none;
      }

      .tab.is-active {
        background: var(--accent);
        color: #fff;
        box-shadow: 0 12px 24px rgba(212, 106, 62, 0.35);
      }

      .tab:focus-visible {
        outline: 2px solid var(--accent-strong);
        outline-offset: 2px;
      }

      .tab-settings {
        margin-left: auto;
      }

      .settings-header {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-bottom: 12px;
      }

      .settings-banner {
        background: #e7f4ec;
        border: 1px solid #c9e4d4;
        color: #2f7d32;
        padding: 10px 14px;
        border-radius: 12px;
        font-weight: 600;
        margin-bottom: 16px;
      }

      .settings-form {
        display: grid;
        gap: 16px;
      }

      .settings-grid {
        display: grid;
        gap: 16px;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      }

      .settings-card {
        background: var(--panel);
        border: 1px solid #f1e2d2;
        border-radius: 16px;
        padding: 18px 20px;
        box-shadow: var(--shadow);
      }

      .settings-card h3 {
        margin: 0 0 12px;
        font-size: 1.05rem;
      }

      .settings-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-bottom: 14px;
      }

      .settings-label {
        font-weight: 600;
        color: var(--ink);
      }

      .settings-input {
        border: 1px solid #e6d3c0;
        border-radius: 10px;
        padding: 10px 12px;
        font-size: 0.95rem;
        font-family: inherit;
        background: #fff;
      }

      .settings-input:focus {
        outline: 2px solid var(--accent-strong);
        outline-offset: 1px;
      }

      .settings-toggle {
        display: flex;
        align-items: center;
        gap: 10px;
        font-weight: 600;
      }

      .settings-checkbox {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.85rem;
        color: var(--ink-muted);
      }

      .settings-hint {
        font-size: 0.85rem;
        color: var(--ink-muted);
        margin: 2px 0 0;
      }

      .settings-actions {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }

      .panels {
        margin-top: 16px;
      }

      .panel {
        display: none;
        background: var(--panel);
        border: 1px solid #f1e2d2;
        border-radius: 18px;
        padding: 24px;
        box-shadow: var(--shadow);
      }

      .panel.is-active {
        display: block;
      }

      .panel > p {
        margin-top: 6px;
        margin-bottom: 18px;
      }

      .upload-card {
        margin-top: 18px;
        padding: 16px;
        border-radius: 14px;
        background: #fff;
        border: 1px solid #f4e6d8;
        display: grid;
        gap: 12px;
      }

      .upload-label {
        font-weight: 600;
      }

      .upload-input {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .upload-select {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .select-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 8px 12px;
        border-radius: 999px;
        border: 1px solid #f0c7b1;
        background: #fff;
        color: var(--accent-strong);
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
      }

      .select-button:hover {
        background: #fbe3d6;
      }

      .select-button.is-secondary {
        background: #fff8f2;
      }

      .dropzone {
        border: 2px dashed #f0c7b1;
        border-radius: 14px;
        padding: 18px;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.8), rgba(255, 245, 238, 0.9));
        display: grid;
        gap: 6px;
        cursor: pointer;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      }

      .dropzone:focus-visible {
        outline: 2px solid var(--accent-strong);
        outline-offset: 2px;
      }

      .dropzone.is-active {
        border-color: var(--accent);
        background: #fff0e1;
        box-shadow: 0 14px 28px rgba(212, 106, 62, 0.18);
      }

      .dropzone.has-files {
        border-color: #e8b090;
      }

      .dropzone-title {
        font-weight: 600;
        font-size: 1rem;
      }

      .dropzone-subtitle {
        font-size: 0.9rem;
        color: var(--ink-muted);
      }

      .dropzone-helper {
        font-size: 0.8rem;
        color: var(--ink-muted);
      }

      .file-summary {
        font-size: 0.85rem;
        color: var(--ink-muted);
      }

      .file-summary-secondary {
        color: #b07456;
      }

      .file-list {
        display: grid;
        gap: 8px;
        margin: 0;
        padding: 0;
      }

      .file-toggle {
        display: none;
        align-items: center;
        gap: 6px;
        padding: 0;
        border: none;
        background: none;
        color: var(--accent-strong);
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
      }

      .file-toggle:hover {
        text-decoration: underline;
      }

      .file-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        background: #fff8f2;
        border: 1px solid #f1e2d2;
        border-radius: 10px;
        padding: 10px 12px;
      }

      .file-meta {
        display: grid;
        gap: 2px;
      }

      .file-name {
        font-weight: 600;
        font-size: 0.95rem;
      }

      .file-size {
        font-size: 0.82rem;
        color: var(--ink-muted);
      }

      .file-remove {
        appearance: none;
        border: 1px solid #f0c7b1;
        background: #fff;
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 0.8rem;
        cursor: pointer;
        color: var(--accent-strong);
      }

      .file-remove:hover {
        background: #fbe3d6;
      }

      .upload-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
        justify-content: space-between;
      }

      .cta {
        appearance: none;
        border: none;
        border-radius: 10px;
        padding: 10px 16px;
        background: var(--accent);
        color: #fff;
        font-weight: 600;
        cursor: pointer;
      }

      .cta:hover {
        background: var(--accent-strong);
      }

      .cta:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        background: #d9c1b6;
      }

      .hint {
        font-size: 0.85rem;
        color: var(--ink-muted);
      }

      .queue-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 16px;
        flex-wrap: wrap;
        margin-bottom: 6px;
      }

      .history-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 16px;
        flex-wrap: wrap;
        margin-bottom: 6px;
      }

      .queue-summary {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .queue-header p {
        margin-top: 6px;
        font-size: 0.98rem;
      }

      .queue-count {
        font-size: 0.82rem;
        color: var(--ink-muted);
        background: #fff;
        border: 1px solid #f1e2d2;
        border-radius: 999px;
        padding: 4px 10px;
        white-space: nowrap;
      }

      .history-controls {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .job-list {
        margin-top: 16px;
        display: grid;
        gap: 10px;
      }

      .history-row {
        display: grid;
        grid-template-columns: minmax(0, 1fr) auto;
        grid-template-areas:
          "main actions"
          "details details";
        gap: 10px 16px;
        padding: 12px 14px;
        border-radius: 12px;
        background: #fff;
        border: 1px solid #f4e6d8;
      }

      .history-main {
        grid-area: main;
        min-width: 0;
        display: grid;
        gap: 4px;
      }

      .history-title {
        display: flex;
        align-items: center;
        gap: 10px;
        min-width: 0;
      }

      .history-filename {
        font-weight: 600;
        font-size: 1rem;
        min-width: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .history-time {
        font-size: 0.8rem;
        color: var(--ink-muted);
      }

      .history-error-summary {
        font-size: 0.82rem;
        color: #8b2f2f;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .status-badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        border-radius: 999px;
        border: 1px solid transparent;
        padding: 3px 8px;
        font-size: 0.7rem;
        font-weight: 700;
        letter-spacing: 0.12em;
        text-transform: uppercase;
      }

      .status-badge.is-done {
        background: #e6f2e8;
        border-color: #cfe6d6;
        color: #2f7d32;
      }

      .status-badge.is-failed {
        background: #fff1f1;
        border-color: #f4d2d2;
        color: #8b2f2f;
      }

      .status-badge.is-running {
        background: #fff0e1;
        border-color: #f0c7b1;
        color: var(--accent-strong);
      }

      .status-badge.is-queued {
        background: #fff8f2;
        border-color: #f1e2d2;
        color: var(--ink-muted);
      }

      .history-actions {
        grid-area: actions;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        justify-content: flex-end;
      }

      .output-chip {
        display: inline-flex;
        align-items: center;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid #f1e2d2;
        background: #fff8f2;
        font-size: 0.7rem;
        font-weight: 700;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--ink-muted);
        text-decoration: none;
        cursor: default;
      }

      .output-chip:hover {
        border-color: #f1e2d2;
        color: var(--ink-muted);
      }

      .job-primary {
        appearance: none;
        border: none;
        border-radius: 8px;
        background: var(--accent);
        color: #fff;
        padding: 6px 10px;
        font-size: 0.78rem;
        font-weight: 600;
        cursor: pointer;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .job-primary:hover {
        background: var(--accent-strong);
      }

      .job-primary.is-secondary {
        background: #fff;
        border: 1px solid #f1cbb8;
        color: var(--accent-strong);
      }

      .job-primary.is-secondary:hover {
        background: #fff3ea;
      }

      .job-primary.is-danger {
        background: #fff1f1;
        border: 1px solid #f4d2d2;
        color: #8b2f2f;
      }

      .job-primary.is-danger:hover {
        background: #ffe3e3;
      }

      .job-primary:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .job-menu {
        position: relative;
      }

      .job-menu > summary {
        list-style: none;
        border: 1px solid #f1e2d2;
        background: #fff;
        border-radius: 8px;
        padding: 6px 8px;
        cursor: pointer;
        font-weight: 700;
        color: var(--accent-strong);
      }

      .job-menu > summary::-webkit-details-marker {
        display: none;
      }

      .job-menu[open] > summary {
        border-color: var(--accent);
        box-shadow: 0 10px 18px rgba(29, 27, 22, 0.12);
      }

      .job-menu-panel {
        position: absolute;
        right: 0;
        top: calc(100% + 6px);
        min-width: 190px;
        background: #fff;
        border: 1px solid #f1e2d2;
        border-radius: 12px;
        padding: 6px;
        box-shadow: var(--shadow);
        display: grid;
        gap: 4px;
        z-index: 20;
      }

      .job-menu-item {
        appearance: none;
        border: none;
        background: transparent;
        text-align: left;
        padding: 8px 10px;
        border-radius: 8px;
        font-size: 0.85rem;
        color: var(--ink);
        text-decoration: none;
        cursor: pointer;
      }

      .job-menu-item:hover {
        background: #fff3ea;
        color: var(--accent-strong);
      }

      .job-menu-divider {
        height: 1px;
        background: #f1e2d2;
        margin: 4px 6px;
      }

      .job-menu-item.is-danger {
        color: #8b2f2f;
      }

      .job-menu-item.is-danger:hover {
        background: #fff1f1;
        color: #8b2f2f;
      }

      .job-details {
        grid-area: details;
        border-top: 1px dashed #e3d2c1;
        padding-top: 8px;
      }

      .job-details > summary {
        list-style: none;
        cursor: pointer;
        font-weight: 600;
        font-size: 0.82rem;
        color: var(--accent-strong);
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .job-details > summary::-webkit-details-marker {
        display: none;
      }

      .details-chevron {
        transition: transform 0.2s ease;
      }

      .job-details[open] .details-chevron {
        transform: rotate(180deg);
      }

      .job-details-body {
        margin-top: 8px;
        display: grid;
        gap: 12px;
      }

      .detail-block {
        display: grid;
        gap: 6px;
      }

      .detail-label {
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--accent-strong);
      }

      .detail-line {
        font-size: 0.82rem;
        color: var(--ink-muted);
      }

      .detail-results {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 6px;
      }

      .detail-result-item {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }

      .detail-result-link {
        color: var(--accent-strong);
        text-decoration: none;
        font-weight: 600;
      }

      .detail-result-link:hover {
        text-decoration: underline;
      }

      .detail-result-action {
        font-size: 0.78rem;
        color: var(--ink-muted);
        text-decoration: none;
        border: 1px solid #f1e2d2;
        padding: 2px 8px;
        border-radius: 999px;
      }

      .detail-result-action:hover {
        color: var(--accent-strong);
        border-color: var(--accent);
      }

      .preview-snippet {
        background: #fff;
        border: 1px solid #f1e2d2;
        border-radius: 8px;
        padding: 8px 10px;
        font-size: 0.82rem;
        color: var(--ink-muted);
        white-space: pre-wrap;
      }

      .preview-snippet.is-loading {
        opacity: 0.7;
      }

      .preview-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .preview-action {
        appearance: none;
        border: 1px solid #f1e2d2;
        background: #fff;
        color: var(--ink-muted);
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 0.78rem;
        cursor: pointer;
        text-decoration: none;
      }

      .preview-action:hover {
        color: var(--accent-strong);
        border-color: var(--accent);
      }

      .detail-log {
        background: #fff1f1;
        border: 1px solid #f4d2d2;
        border-radius: 8px;
        padding: 8px 10px;
        font-size: 0.82rem;
        color: #8b2f2f;
        white-space: pre-wrap;
        max-height: 220px;
        overflow: auto;
      }


      .job-row {
        display: flex;
        justify-content: space-between;
        gap: 16px;
        padding: 14px 16px;
        border-radius: 12px;
        background: #fff;
        border: 1px solid #f4e6d8;
        align-items: flex-start;
      }

      .job-row.is-running {
        border-color: var(--accent);
        background: #fff0e1;
        box-shadow: 0 16px 30px rgba(212, 106, 62, 0.18);
      }

      .job-icon {
        width: 32px;
        height: 32px;
        border-radius: 10px;
        background: #fff6ea;
        border: 1px solid #f1cbb8;
        display: grid;
        place-items: center;
        font-size: 1rem;
        color: var(--accent-strong);
        flex-shrink: 0;
      }

      .job-body {
        flex: 1;
        min-width: 0;
      }

      .job-name {
        font-weight: 600;
        font-size: 1.02rem;
      }

      .job-meta {
        font-size: 0.85rem;
        color: var(--ink-muted);
        margin-top: 2px;
      }

      .job-queue {
        margin-top: 6px;
        font-size: 0.78rem;
        color: var(--ink-muted);
        font-weight: 600;
      }

      .job-status {
        text-transform: uppercase;
        letter-spacing: 0.1em;
        font-size: 0.72rem;
        color: var(--accent-strong);
        align-self: center;
      }

      .job-elapsed {
        font-size: 0.75rem;
        color: var(--ink-muted);
        font-weight: 600;
      }

      .job-actions {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 6px;
        min-width: 92px;
      }

      .job-bin {
        appearance: none;
        border: 1px solid #f1cbb8;
        background: #fff3ea;
        color: #9f4b2a;
        border-radius: 8px;
        padding: 6px 10px;
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        cursor: pointer;
      }

      .job-bin:hover {
        background: #fbe3d6;
      }

      .job-bin:focus-visible {
        outline: 2px solid var(--accent-strong);
        outline-offset: 2px;
      }

      .job-bin:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .job-bin-icon {
        width: 16px;
        height: 16px;
        display: block;
        fill: currentColor;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .job-error {
        margin-top: 8px;
        padding: 8px 10px;
        background: #fff1f1;
        border: 1px solid #f4d2d2;
        border-radius: 8px;
        font-size: 0.82rem;
        color: #8b2f2f;
        white-space: pre-wrap;
      }

      .results {
        margin-top: 10px;
      }

      .result-label {
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--accent-strong);
      }

      .result-list {
        list-style: none;
        margin: 6px 0 0;
        padding: 0;
        display: grid;
        gap: 6px;
      }

      .result-item {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }

      .result-link {
        color: var(--accent-strong);
        text-decoration: none;
        font-weight: 600;
      }

      .result-link:hover {
        text-decoration: underline;
      }

      .result-link.is-text {
        color: var(--accent);
      }

      .result-action {
        font-size: 0.78rem;
        color: var(--ink-muted);
        text-decoration: none;
        border: 1px solid #f1e2d2;
        padding: 2px 8px;
        border-radius: 999px;
      }

      .result-action:hover {
        color: var(--accent-strong);
        border-color: var(--accent);
      }

      .result-empty {
        margin-top: 6px;
        font-size: 0.85rem;
        color: var(--ink-muted);
      }

      .placeholder {
        margin-top: 16px;
        padding-top: 16px;
        border-top: 1px dashed #e3d2c1;
        display: grid;
        gap: 10px;
      }

      .placeholder-row {
        padding: 12px 14px;
        border-radius: 10px;
        background: #fff;
        border: 1px solid #f4e6d8;
        color: var(--ink-muted);
      }

      .toast-stack {
        position: fixed;
        top: max(20px, env(safe-area-inset-top));
        right: max(20px, env(safe-area-inset-right));
        display: grid;
        gap: 10px;
        z-index: 1000;
        pointer-events: none;
      }

      .toast {
        --toast-bg: var(--panel);
        --toast-border: #f1e2d2;
        --toast-accent: var(--accent);
        --toast-muted: var(--ink-muted);

        min-width: min(320px, calc(100vw - 40px));
        max-width: 380px;
        padding: 10px 10px 8px;
        border-radius: 14px;
        border: 1px solid var(--toast-border);
        background: var(--toast-bg);
        box-shadow: var(--shadow);
        pointer-events: auto;
        opacity: 0;
        transform: translateY(-8px);
        transition: opacity 200ms ease, transform 200ms ease;
        display: grid;
        grid-template-columns: 20px 1fr auto;
        grid-template-areas:
          "icon header close"
          "body body body"
          "progress progress progress";
        column-gap: 10px;
        row-gap: 4px;
        align-items: start;
      }

      .toast.is-visible {
        opacity: 1;
        transform: translateY(0);
      }

      .toast.is-done {
        --toast-border: #cfe6d6;
        --toast-accent: #2f7d32;
      }

      .toast.is-failed {
        --toast-border: #f4d2d2;
        --toast-accent: #b3261e;
      }

      .toast__icon {
        grid-area: icon;
        width: 20px;
        height: 20px;
        margin-top: 1px;
        color: var(--toast-accent);
      }

      .toast__header {
        grid-area: header;
        display: flex;
        align-items: baseline;
        gap: 10px;
        min-width: 0;
      }

      .toast__title {
        font-size: 0.72rem;
        text-transform: uppercase;
        letter-spacing: 0.14em;
        font-weight: 700;
        color: var(--toast-accent);
        min-width: 0;
      }

      .toast__meta {
        font-size: 0.72rem;
        color: var(--toast-muted);
        white-space: nowrap;
        flex-shrink: 0;
      }

      .toast__body {
        grid-area: body;
        font-size: 0.88rem;
        font-weight: 600;
        color: var(--ink);
        min-width: 0;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .toast__dismiss {
        grid-area: close;
        appearance: none;
        border: 1px solid rgba(29, 27, 22, 0.12);
        background: rgba(255, 255, 255, 0.65);
        color: var(--ink-muted);
        width: 30px;
        height: 30px;
        border-radius: 10px;
        display: grid;
        place-items: center;
        cursor: pointer;
        justify-self: end;
      }

      .toast__dismiss:hover {
        border-color: var(--toast-accent);
        color: var(--toast-accent);
      }

      .toast__dismiss:focus-visible {
        outline: 2px solid var(--toast-accent);
        outline-offset: 2px;
      }

      .toast__progress {
        grid-area: progress;
        height: 2px;
        background: rgba(29, 27, 22, 0.1);
        border-radius: 999px;
        overflow: hidden;
      }

      .toast__progressBar {
        height: 100%;
        width: 100%;
        background: var(--toast-accent);
        transform-origin: left;
        animation: toastCountdown linear var(--toast-duration, 8000ms) forwards;
      }

      .toast.is-paused .toast__progressBar {
        animation-play-state: paused;
      }

      .toast.is-clickable {
        cursor: pointer;
      }

      .toast.is-clickable:hover {
        border-color: var(--toast-accent);
      }

      .toast.is-clickable:focus-within {
        outline: 2px solid var(--toast-accent);
        outline-offset: 2px;
      }

      @keyframes toastCountdown {
        from {
          transform: scaleX(1);
        }
        to {
          transform: scaleX(0);
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .toast {
          transition: none;
          transform: none;
        }

        .toast__progressBar {
          animation: none;
        }
      }

      @media (max-width: 720px) {
        main {
          padding: 32px 18px 48px;
        }

        .hero {
          flex-direction: column;
          align-items: flex-start;
        }

        .tablist {
          flex-direction: column;
          align-items: stretch;
        }

        .upload-actions {
          flex-direction: column;
          align-items: stretch;
        }

        .queue-header {
          flex-direction: column;
          align-items: flex-start;
        }

        .file-item {
          flex-direction: column;
          align-items: flex-start;
        }

        .file-remove {
          align-self: flex-start;
        }

        .job-row {
          flex-direction: column;
          align-items: flex-start;
        }

        .history-row {
          grid-template-columns: 1fr;
          grid-template-areas:
            "main"
            "actions"
            "details";
        }

        .history-actions {
          justify-content: flex-start;
        }

        .job-menu-panel {
          right: auto;
          left: 0;
        }

        .job-actions {
          flex-direction: row;
          align-items: center;
          justify-content: space-between;
          width: 100%;
        }

        .status-card {
          width: 100%;
        }

        .toast-stack {
          top: auto;
          right: max(16px, env(safe-area-inset-right));
          left: max(16px, env(safe-area-inset-left));
          bottom: max(16px, env(safe-area-inset-bottom));
        }

        .toast {
          min-width: auto;
          max-width: none;
          grid-template-columns: 20px 1fr auto;
          grid-template-areas:
            "icon header close"
            "body body body"
            "progress progress progress";
        }
      }
    </style>
  </head>
  <body>
    <main>
      <header class="hero">
        <div>
          <div class="eyebrow">Local-only transcription</div>
          <h1>Whisper WebUI (MLX)</h1>
          <p>Queue files for offline transcription. Upload and worker controls land here.</p>
        </div>
        <div class="status-card" aria-live="polite">
          <div class="status-label">Worker</div>
          <div class="status" id="worker-status">{{ worker.status }}</div>
          <p id="worker-detail">
            {% if worker.status == "Running" and worker.filename %}
              Running {{ worker.filename }}
            {% else %}
              Sequential queue, one job at a time.
            {% endif %}
          </p>
        </div>
      </header>

      <section class="tabs" aria-label="Main sections">
        <div class="tablist" role="tablist">
          <a
            class="tab is-active"
            role="tab"
            aria-selected="true"
            aria-controls="panel-queue"
            id="tab-queue"
            data-tab="queue"
            href="/?tab=queue"
          >
            Queue
          </a>
          <a
            class="tab"
            role="tab"
            aria-selected="false"
            aria-controls="panel-history"
            id="tab-history"
            data-tab="history"
            href="/?tab=history"
          >
            History
          </a>
          <a
            class="tab tab-settings"
            role="tab"
            aria-selected="false"
            aria-controls="panel-settings"
            id="tab-settings"
            data-tab="settings"
            href="/?tab=settings"
          >
            Settings
          </a>
        </div>

        <div class="panels">
          <section
            class="panel is-active"
            role="tabpanel"
            id="panel-queue"
            aria-labelledby="tab-queue"
            data-panel="queue"
          >
            <div class="queue-header">
              <div>
                <h2>Queue</h2>
                <p>Upload files to start a sequential transcription run.</p>
              </div>
              <div class="queue-summary">
                <div class="queue-count" data-queue-count>
                  {{ queued_count }} {{ "file" if queued_count == 1 else "files" }} queued
                </div>
              </div>
            </div>
            <form class="upload-card" action="/upload" method="post" enctype="multipart/form-data">
              <label class="upload-label" for="file-input">Select audio or video files or folders</label>
              <input
                id="file-input"
                class="upload-input"
                type="file"
                name="files"
                multiple
                required
                accept="audio/*,video/*"
              >
              <input
                id="folder-input"
                class="upload-input"
                type="file"
                multiple
                webkitdirectory
              >
              <div class="upload-select">
                <label class="select-button" for="file-input">Select files</label>
                <label class="select-button is-secondary" for="folder-input">Select folder</label>
              </div>
              <label
                class="dropzone"
                id="dropzone"
                tabindex="0"
                role="button"
                for="file-input"
                aria-describedby="dropzone-hint"
              >
                <div class="dropzone-title">Drag & drop files or folders here</div>
                <div class="dropzone-subtitle" id="dropzone-hint">
                  or click to browse audio/video files
                </div>
                <div class="dropzone-helper">
                  Supported: audio/video files (ffmpeg-readable). Non-media files will be skipped.
                </div>
              </label>
              <div class="file-summary" id="file-summary" aria-live="polite">No files selected yet.</div>
              <div class="file-summary file-summary-secondary" id="file-skipped" aria-live="polite"></div>
              <div class="file-list" id="file-list" aria-live="polite"></div>
              <button class="file-toggle" id="file-list-toggle" type="button">Show all</button>
              <div class="upload-actions">
                <button class="cta" id="upload-submit" type="submit">Queue uploads</button>
                <span class="hint">Files stay local in data/uploads.</span>
              </div>
            </form>
            <div class="job-list" aria-live="polite" id="queue-list">
              {% set offset = 1 if queue_jobs | selectattr("status", "equalto", "running") | list | length > 0 else 0 %}
              {% set queue_index = namespace(value=0) %}
              {% for job in queue_jobs %}
                {% set is_running = job.status == "running" %}
                {% if job.status == "queued" %}
                  {% set queue_index.value = queue_index.value + 1 %}
                {% endif %}
                <div class="job-row{% if is_running %} is-running{% endif %}">
                  {% if is_running %}
                    <div class="job-icon" aria-hidden="true">⏳</div>
                  {% endif %}
                  <div class="job-body">
                    <div class="job-name">{{ job.filename }}</div>
                    <div class="job-meta" data-iso="{{ job.created_at }}" data-label="Added">
                      Added {{ job.created_at }}
                    </div>
                    {% if job.started_at %}
                      <div class="job-meta" data-iso="{{ job.started_at }}" data-label="Started">
                        Started {{ job.started_at }}
                      </div>
                    {% endif %}
                    {% if job.status == "queued" %}
                      {% set queue_position = queue_index.value + offset %}
                      {% set items_ahead = queue_position - 1 %}
                      <div class="job-queue">
                        {{ items_ahead }} {{ "item" if items_ahead == 1 else "items" }} ahead
                      </div>
                    {% endif %}
                  </div>
                  <div class="job-actions">
                    <div class="job-status">{{ job.status }}</div>
                    {% if is_running and job.started_at %}
                      <div class="job-elapsed" data-started-at="{{ job.started_at }}"></div>
                    {% endif %}
                    {% if job.status == "queued" %}
                      <button
                        class="job-bin"
                        type="button"
                        data-job-id="{{ job.id }}"
                        aria-label="Remove from queue"
                        title="Remove from queue"
                      >
                        <svg class="job-bin-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                          <path d="M9 3h6l1 2h5v2H3V5h5l1-2zm-2 6h2v9H7V9zm4 0h2v9h-2V9zm4 0h2v9h-2V9z"></path>
                        </svg>
                        <span class="sr-only">Remove</span>
                      </button>
                    {% endif %}
                  </div>
                </div>
              {% endfor %}
            </div>
          </section>

          <section
            class="panel"
            role="tabpanel"
            id="panel-history"
            aria-labelledby="tab-history"
            data-panel="history"
          >
            <div class="history-header">
              <div>
                <h2>History</h2>
                <p>Completed jobs appear here. Expand a row for timestamps, outputs, and logs.</p>
              </div>
              <div class="history-controls">
                <button
                  class="job-primary is-secondary is-danger"
                  type="button"
                  data-history-clear
                  {% if not history_jobs %}disabled{% endif %}
                >
                  Delete all results
                </button>
              </div>
            </div>
            <div class="job-list" aria-live="polite" id="history-list">
              {% for job in history_jobs %}
                {% set results = results_by_job.get(job.id, []) %}
                {% set result_ns = namespace(default=None) %}
                {% for result in results %}
                  {% if result.endswith('.txt') and result_ns.default is none %}
                    {% set result_ns.default = result %}
                  {% endif %}
                {% endfor %}
                {% if result_ns.default is none and results %}
                  {% set result_ns.default = results[0] %}
                {% endif %}
                <div class="history-row" data-job-id="{{ job.id }}">
                  <div class="history-main">
                    <div class="history-title">
                      <div class="history-filename" title="{{ job.filename }}">{{ job.filename }}</div>
                      <div class="status-badge is-{{ job.status }}">{{ job.status }}</div>
                    </div>
                    <div
                      class="history-time"
                      data-time-meta
                      data-status="{{ job.status }}"
                      data-created-at="{{ job.created_at }}"
                      {% if job.started_at %}data-started-at="{{ job.started_at }}"{% endif %}
                      {% if job.completed_at %}data-completed-at="{{ job.completed_at }}"{% endif %}
                    ></div>
                    {% if job.status == "failed" and job.error_message %}
                      {% set error_summary = job.error_message.splitlines()[0] %}
                      <div class="history-error-summary" title="{{ error_summary }}">{{ error_summary }}</div>
                    {% endif %}
                  </div>
                  <div class="history-actions">
                    {% if results %}
                      <div class="output-chips">
                        {% set chip_ns = namespace(exts=[]) %}
                        {% for result in results %}
                          {% set ext = result.rsplit('.', 1)[-1] | upper %}
                          {% if ext not in chip_ns.exts %}
                            {% set chip_ns.exts = chip_ns.exts + [ext] %}
                            <span class="output-chip">
                              {{ ext }}
                            </span>
                          {% endif %}
                        {% endfor %}
                      </div>
                    {% endif %}
                    {% if job.status == "done" and result_ns.default %}
                      <a
                        class="job-primary"
                        href="/results/{{ job.id }}/{{ result_ns.default }}"
                        download="{{ result_ns.default }}"
                      >
                        Download
                      </a>
                    {% elif job.status == "failed" %}
                      <button class="job-primary is-secondary" type="button" data-action="view-log">
                        View log
                      </button>
                    {% endif %}
                    <details class="job-menu">
                      <summary aria-label="More actions">⋯</summary>
                      <div class="job-menu-panel" role="menu">
                        {% if job.status == "done" and result_ns.default %}
                          <a
                            class="job-menu-item"
                            role="menuitem"
                            href="/results/{{ job.id }}/{{ result_ns.default }}"
                            target="_blank"
                            rel="noopener"
                          >
                            Open transcript
                          </a>
                        {% endif %}
                        {% if results %}
                          {% for result in results %}
                            <a
                              class="job-menu-item"
                              role="menuitem"
                              href="/results/{{ job.id }}/{{ result }}"
                              download="{{ result }}"
                            >
                              Download {{ result.rsplit('.', 1)[-1] | upper }}
                            </a>
                          {% endfor %}
                        {% endif %}
                        {% if job.status == "done" and result_ns.default %}
                          <button
                            class="job-menu-item"
                            type="button"
                            role="menuitem"
                            data-action="copy-preview"
                            data-job-id="{{ job.id }}"
                          >
                            Copy preview
                          </button>
                        {% endif %}
                        <button
                          class="job-menu-item"
                          type="button"
                          role="menuitem"
                          data-action="copy-filename"
                          data-filename="{{ job.filename }}"
                        >
                          Copy filename
                        </button>
                        <div class="job-menu-divider" role="separator"></div>
                        <button
                          class="job-menu-item is-danger"
                          type="button"
                          role="menuitem"
                          data-action="delete-history"
                        >
                          Delete...
                        </button>
                      </div>
                    </details>
                  </div>
                  <details class="job-details" data-job-id="{{ job.id }}">
                    <summary>
                      <span>Details</span>
                      <span class="details-chevron" aria-hidden="true">▾</span>
                    </summary>
                    <div class="job-details-body">
                      <div class="detail-block">
                        <div class="detail-label">Timeline</div>
                        <div class="detail-line" data-iso="{{ job.created_at }}" data-label="Added"></div>
                        {% if job.started_at %}
                          <div class="detail-line" data-iso="{{ job.started_at }}" data-label="Started"></div>
                        {% endif %}
                        {% if job.completed_at %}
                          <div
                            class="detail-line"
                            data-iso="{{ job.completed_at }}"
                            data-label="{{ 'Failed' if job.status == 'failed' else 'Completed' }}"
                          ></div>
                        {% endif %}
                      </div>
                      {% if job.status == "done" and result_ns.default %}
                        <div
                          class="detail-block"
                          data-preview-block
                          data-preview-url="/api/jobs/{{ job.id }}/preview?chars=300"
                        >
                          <div class="detail-label">Preview</div>
                          <div class="preview-snippet is-loading" data-preview-snippet>
                            Preview will load when expanded.
                          </div>
                          <div class="preview-actions">
                            <button
                              class="preview-action"
                              type="button"
                              data-action="copy-preview"
                              data-job-id="{{ job.id }}"
                            >
                              Copy preview
                            </button>
                            <a
                              class="preview-action"
                              href="/results/{{ job.id }}/{{ result_ns.default }}"
                              target="_blank"
                              rel="noopener"
                            >
                              Open
                            </a>
                          </div>
                        </div>
                      {% endif %}
                      {% if results %}
                        <div class="detail-block">
                          <div class="detail-label">Outputs</div>
                          <ul class="detail-results">
                            {% for result in results %}
                              <li class="detail-result-item">
                                <a
                                  class="detail-result-link"
                                  href="/results/{{ job.id }}/{{ result }}"
                                  target="_blank"
                                  rel="noopener"
                                >
                                  {{ result }}
                                </a>
                              </li>
                            {% endfor %}
                          </ul>
                        </div>
                      {% endif %}
                      {% if job.status == "failed" and job.error_message %}
                        <div class="detail-block">
                          <div class="detail-label">Log</div>
                          <div class="detail-log" data-log>{{ job.error_message }}</div>
                        </div>
                      {% endif %}
                    </div>
                  </details>
                </div>
              {% endfor %}
            </div>
            <div class="placeholder" id="history-placeholder"{% if history_jobs %} style="display: none;"{% endif %}>
              <div class="placeholder-row">No completed jobs yet.</div>
              <div class="placeholder-row">Check back after a run.</div>
            </div>
          </section>

          <section
            class="panel"
            role="tabpanel"
            id="panel-settings"
            aria-labelledby="tab-settings"
            data-panel="settings"
          >
            <div class="settings-header">
              <h2>Settings</h2>
              <p>Default transcription settings and delivery preferences.</p>
            </div>
            {% if settings_saved %}
              <div class="settings-banner">Settings saved.</div>
            {% endif %}
            <form class="settings-form" action="/settings" method="post">
              <div class="settings-grid">
                <div class="settings-card">
                  <h3>Transcription defaults</h3>
                  <div class="settings-field">
                    <label class="settings-label" for="whisper-model">Default model</label>
                    <input
                      class="settings-input"
                      id="whisper-model"
                      name="whisper_model"
                      type="text"
                      list="downloaded-models"
                      value="{{ settings_snapshot.settings.whisper_model }}"
                    >
                    <datalist id="downloaded-models">
                      {% for model in downloaded_models %}
                        <option value="{{ model }}"></option>
                      {% endfor %}
                    </datalist>
                    <p class="settings-hint">
                      Source: {{ settings_snapshot.sources.whisper_model }}.
                      {% if downloaded_models %}
                        Downloaded: {{ downloaded_models | join(", ") }}.
                      {% else %}
                        No downloaded models detected yet.
                      {% endif %}
                    </p>
                    <p class="settings-hint">
                      Applies to the Whisper backend; MLX uses its bundled model.
                    </p>
                  </div>
                  <div class="settings-field">
                    <label class="settings-toggle" for="wtm-quick">
                      <input
                        id="wtm-quick"
                        type="checkbox"
                        name="wtm_quick"
                        value="1"
                        {% if settings_snapshot.settings.wtm_quick %}checked{% endif %}
                      >
                      Quick mode (WTM)
                    </label>
                    <p class="settings-hint">
                      Faster runs, lower accuracy. Source: {{ settings_snapshot.sources.wtm_quick }}.
                    </p>
                  </div>
                  <p class="settings-hint">Changes apply after restarting the app/worker.</p>
                </div>

                <div class="settings-card">
                  <h3>Telegram delivery</h3>
                  <div class="settings-field">
                    <label class="settings-label" for="telegram-token">Bot token</label>
                    <input
                      class="settings-input"
                      id="telegram-token"
                      name="telegram_token"
                      type="password"
                      autocomplete="new-password"
                      placeholder="123456:ABC..."
                    >
                    <p class="settings-hint">
                      {% if telegram_snapshot.configured %}
                        Current: {{ telegram_snapshot.token_masked }} ({{ telegram_snapshot.source }})
                      {% else %}
                        Not configured.
                      {% endif %}
                    </p>
                    <label class="settings-checkbox">
                      <input type="checkbox" name="clear_telegram_token" value="1">
                      Clear saved token
                    </label>
                  </div>
                  <div class="settings-field">
                    <label class="settings-label" for="telegram-chat-id">Chat ID</label>
                    <input
                      class="settings-input"
                      id="telegram-chat-id"
                      name="telegram_chat_id"
                      type="password"
                      autocomplete="new-password"
                      placeholder="-1001234567890"
                    >
                    <p class="settings-hint">
                      {% if telegram_snapshot.configured %}
                        Current: {{ telegram_snapshot.chat_id_masked }} ({{ telegram_snapshot.source }})
                      {% else %}
                        Not configured.
                      {% endif %}
                    </p>
                    <label class="settings-checkbox">
                      <input type="checkbox" name="clear_telegram_chat_id" value="1">
                      Clear saved chat ID
                    </label>
                  </div>
                  <p class="settings-hint">Environment variables override saved values.</p>
                </div>
              </div>
              <div class="settings-actions">
                <button class="cta" type="submit">Save settings</button>
                <span class="hint">Saved locally in data/settings.json</span>
              </div>
            </form>
          </section>
        </div>
      </section>
    </main>
    <div
      class="toast-stack"
      id="toast-stack"
      aria-live="polite"
      aria-atomic="false"
      aria-relevant="additions"
    ></div>

    <script>
      (function () {
        const tabs = Array.from(document.querySelectorAll("[data-tab]"));
        const panels = document.querySelectorAll("[data-panel]");
        if (!tabs.length) {
          return;
        }
        const tabNames = new Set(tabs.map((tab) => tab.dataset.tab));
        const TAB_STORAGE_KEY = "mlx-ui:last-tab";

        function updateUrl(tabName, replace) {
          const url = new URL(window.location.href);
          url.searchParams.set("tab", tabName);
          if (!replace && url.toString() === window.location.href) {
            return;
          }
          const state = { tab: tabName };
          if (replace) {
            history.replaceState(state, "", url);
          } else {
            history.pushState(state, "", url);
          }
        }

        function activate(tabName, options = {}) {
          const { updateHistory = false, replaceHistory = false } = options;
          if (!tabNames.has(tabName)) {
            return;
          }
          tabs.forEach((tab) => {
            const isActive = tab.dataset.tab === tabName;
            tab.classList.toggle("is-active", isActive);
            tab.setAttribute("aria-selected", isActive ? "true" : "false");
          });

          panels.forEach((panel) => {
            panel.classList.toggle("is-active", panel.dataset.panel === tabName);
          });

          try {
            localStorage.setItem(TAB_STORAGE_KEY, tabName);
          } catch (error) {
            // localStorage may be disabled; UI should still work.
          }

          if (updateHistory) {
            updateUrl(tabName, replaceHistory);
          }
        }

        function tabFromUrl() {
          const initialTab = new URLSearchParams(window.location.search).get("tab");
          return tabNames.has(initialTab) ? initialTab : null;
        }

        let storedTab = null;
        try {
          const candidate = localStorage.getItem(TAB_STORAGE_KEY);
          storedTab = tabNames.has(candidate) ? candidate : null;
        } catch (error) {
          storedTab = null;
        }

        const initialFromUrl = tabFromUrl();
        const initialTab = initialFromUrl || storedTab || "queue";
        activate(initialTab, {
          updateHistory: !initialFromUrl,
          replaceHistory: true
        });

        tabs.forEach((tab) => {
          tab.addEventListener("click", (event) => {
            if (
              event.defaultPrevented ||
              event.button !== 0 ||
              event.metaKey ||
              event.ctrlKey ||
              event.shiftKey ||
              event.altKey
            ) {
              return;
            }
            event.preventDefault();
            activate(tab.dataset.tab, { updateHistory: true });
          });
        });

        window.addEventListener("popstate", () => {
          const tabName = tabFromUrl() || "queue";
          activate(tabName);
        });

        const queueList = document.getElementById("queue-list");
        const historyList = document.getElementById("history-list");
        const historyPlaceholder = document.getElementById("history-placeholder");
        const historyClearButton = document.querySelector("[data-history-clear]");
        const workerStatus = document.getElementById("worker-status");
        const workerDetail = document.getElementById("worker-detail");
        const queueCountEls = document.querySelectorAll("[data-queue-count]");
        const toastStack = document.getElementById("toast-stack");
        const uploadForm = document.querySelector(".upload-card");
        const fileInput = document.getElementById("file-input");
        const folderInput = document.getElementById("folder-input");
        const dropzone = document.getElementById("dropzone");
        const fileList = document.getElementById("file-list");
        const fileSummary = document.getElementById("file-summary");
        const fileSkipped = document.getElementById("file-skipped");
        const fileListToggle = document.getElementById("file-list-toggle");
        const uploadSubmit = document.getElementById("upload-submit");
        const notifiedJobIds = new Set();
        let notificationsSeeded = false;
        const previewCache = new Map();
        const ICON_CHECK = `
          <svg viewBox="0 0 24 24" width="22" height="22" aria-hidden="true" focusable="false">
            <path fill="currentColor" d="M9.2 16.6 4.9 12.3l1.4-1.4 2.9 2.9 8.6-8.6 1.4 1.4z"></path>
          </svg>
        `;
        const ICON_ERROR = `
          <svg viewBox="0 0 24 24" width="22" height="22" aria-hidden="true" focusable="false">
            <path fill="currentColor" d="M12 2 1 21h22L12 2zm1 15h-2v-2h2v2zm0-4h-2V9h2v4z"></path>
          </svg>
        `;
        const ICON_X = `
          <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true" focusable="false">
            <path fill="currentColor" d="M18.3 5.7 12 12l6.3 6.3-1.4 1.4L10.6 13.4 4.3 19.7 2.9 18.3 9.2 12 2.9 5.7 4.3 4.3l6.3 6.3 6.3-6.3z"></path>
          </svg>
        `;
        const relativeFormatter =
          typeof Intl !== "undefined" && Intl.RelativeTimeFormat
            ? new Intl.RelativeTimeFormat(undefined, { numeric: "auto", style: "short" })
            : null;
        const MAX_VISIBLE_FILES = 50;
        const ESTIMATE_MB_PER_MIN_FAST = 12;
        const ESTIMATE_MB_PER_MIN_SLOW = 4;
        const ESTIMATE_PER_FILE_MIN = 0.25;
        const MEDIA_EXTENSIONS = new Set([
          "mp3",
          "wav",
          "m4a",
          "flac",
          "ogg",
          "opus",
          "aac",
          "wma",
          "alac",
          "aiff",
          "amr",
          "mp4",
          "mov",
          "mkv",
          "webm",
          "m4v",
          "avi",
          "mpg",
          "mpeg",
          "3gp",
        ]);
        const SKIP_PATH_PARTS = new Set(["__MACOSX"]);

        function escapeHtml(value) {
          return String(value)
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#39;");
        }

        const pendingItems = [];
        let skippedCount = 0;
        let showAllFiles = false;
        let scanningFolder = false;
        let syncingInput = false;
        let dragDepth = 0;
        let uploadInFlight = false;

        function formatBytes(bytes) {
          if (!Number.isFinite(bytes) || bytes <= 0) {
            return "0 B";
          }
          const units = ["B", "KB", "MB", "GB", "TB"];
          let value = bytes;
          let unitIndex = 0;
          while (value >= 1024 && unitIndex < units.length - 1) {
            value /= 1024;
            unitIndex += 1;
          }
          const precision = value >= 10 || unitIndex === 0 ? 0 : 1;
          return `${value.toFixed(precision)} ${units[unitIndex]}`;
        }

        function normalizeDisplayPath(value) {
          return String(value || "").replace(/\\/g, "/");
        }

        function getExtension(value) {
          const normalized = String(value || "");
          const lastDot = normalized.lastIndexOf(".");
          if (lastDot <= 0 || lastDot === normalized.length - 1) {
            return "";
          }
          return normalized.slice(lastDot + 1).toLowerCase();
        }

        function isHiddenPath(displayPath) {
          const normalized = normalizeDisplayPath(displayPath);
          return normalized.split("/").some((part) => {
            if (!part) {
              return true;
            }
            if (SKIP_PATH_PARTS.has(part)) {
              return true;
            }
            return part.startsWith(".");
          });
        }

        function isAcceptedMedia(file, displayPath) {
          if (isHiddenPath(displayPath)) {
            return false;
          }
          const type = String(file.type || "").toLowerCase();
          if (type.startsWith("audio/") || type.startsWith("video/")) {
            return true;
          }
          const ext = getExtension(displayPath);
          return MEDIA_EXTENSIONS.has(ext);
        }

        function buildItemKey(item) {
          return `${item.displayPath}::${item.file.size}::${item.file.lastModified}`;
        }

        function prepareItems(rawItems) {
          const items = [];
          let skipped = 0;
          rawItems.forEach(({ file, displayPath }) => {
            const normalized =
              normalizeDisplayPath(displayPath) ||
              normalizeDisplayPath(file.webkitRelativePath) ||
              normalizeDisplayPath(file.name);
            if (!normalized || !isAcceptedMedia(file, normalized)) {
              skipped += 1;
              return;
            }
            items.push({ file, displayPath: normalized });
          });
          return { items, skipped };
        }

        function estimateRangeMinutes(totalBytes, count) {
          const totalMb = totalBytes / (1024 * 1024);
          const fast = totalMb / ESTIMATE_MB_PER_MIN_FAST + count * ESTIMATE_PER_FILE_MIN;
          const slow = totalMb / ESTIMATE_MB_PER_MIN_SLOW + count * ESTIMATE_PER_FILE_MIN;
          return { fast, slow };
        }

        function formatEstimateRange(fastMinutes, slowMinutes) {
          if (!Number.isFinite(fastMinutes) || !Number.isFinite(slowMinutes)) {
            return "";
          }
          const low = Math.max(1, Math.round(fastMinutes));
          const high = Math.max(low, Math.round(slowMinutes));
          return `${low}-${high} min`;
        }

        function syncInputFiles(items) {
          if (!fileInput) {
            return;
          }
          if (typeof DataTransfer === "undefined") {
            return;
          }
          const transfer = new DataTransfer();
          items.forEach((item) => transfer.items.add(item.file));
          syncingInput = true;
          fileInput.files = transfer.files;
          syncingInput = false;
        }

        function renderFileItems() {
          if (!fileList) {
            return;
          }
          fileList.innerHTML = "";
          if (pendingItems.length === 0) {
            if (fileListToggle) {
              fileListToggle.style.display = "none";
            }
            return;
          }
          const visibleCount = showAllFiles
            ? pendingItems.length
            : Math.min(MAX_VISIBLE_FILES, pendingItems.length);
          const fragment = document.createDocumentFragment();
          pendingItems.slice(0, visibleCount).forEach((item, index) => {
            const row = document.createElement("div");
            row.className = "file-item";

            const meta = document.createElement("div");
            meta.className = "file-meta";

            const name = document.createElement("div");
            name.className = "file-name";
            name.textContent = item.displayPath || "Untitled file";

            const size = document.createElement("div");
            size.className = "file-size";
            size.textContent = formatBytes(item.file.size || 0);

            meta.appendChild(name);
            meta.appendChild(size);

            const remove = document.createElement("button");
            remove.className = "file-remove";
            remove.type = "button";
            remove.dataset.removeIndex = String(index);
            remove.setAttribute("aria-label", `Remove ${item.displayPath || "file"}`);
            remove.textContent = "Remove";

            row.appendChild(meta);
            row.appendChild(remove);
            fragment.appendChild(row);
          });
          fileList.appendChild(fragment);
          if (fileListToggle) {
            if (pendingItems.length > MAX_VISIBLE_FILES) {
              fileListToggle.style.display = "inline-flex";
              fileListToggle.textContent = showAllFiles ? "Show first 50" : "Show all";
            } else {
              fileListToggle.style.display = "none";
            }
          }
        }

        function renderFileList() {
          if (!fileList || !fileSummary || !uploadSubmit || !dropzone) {
            return;
          }
          if (scanningFolder) {
            fileSummary.textContent = "Scanning folder...";
            uploadSubmit.disabled = true;
            if (fileSkipped) {
              fileSkipped.textContent = "";
            }
            if (pendingItems.length === 0) {
              dropzone.classList.remove("has-files");
              renderFileItems();
            } else {
              dropzone.classList.add("has-files");
              renderFileItems();
            }
            return;
          }
          if (pendingItems.length === 0) {
            fileSummary.textContent = "No files selected yet.";
            uploadSubmit.disabled = true;
            dropzone.classList.remove("has-files");
            if (fileSkipped) {
              fileSkipped.textContent =
                skippedCount > 0 ? `Skipped ${skippedCount} items (non-media/hidden)` : "";
            }
            renderFileItems();
            return;
          }
          const totalBytes = pendingItems.reduce(
            (sum, item) => sum + (item.file.size || 0),
            0
          );
          const label = pendingItems.length === 1 ? "file" : "files";
          const { fast, slow } = estimateRangeMinutes(totalBytes, pendingItems.length);
          const estimate = formatEstimateRange(fast, slow);
          const estimateText = estimate ? ` · Est. ${estimate}` : "";
          fileSummary.textContent = `${pendingItems.length} ${label} ready · ${formatBytes(
            totalBytes
          )}${estimateText}`;
          if (fileSkipped && skippedCount > 0) {
            fileSkipped.textContent = `Skipped ${skippedCount} items (non-media/hidden)`;
          } else if (fileSkipped) {
            fileSkipped.textContent = "";
          }
          uploadSubmit.disabled = false;
          dropzone.classList.add("has-files");
          renderFileItems();
        }

        function setPendingItems(nextItems, nextSkipped = 0) {
          pendingItems.splice(0, pendingItems.length, ...nextItems);
          skippedCount = nextSkipped;
          showAllFiles = false;
          syncInputFiles(pendingItems);
          renderFileList();
        }

        function mergeItems(existing, incoming) {
          const merged = [...existing];
          const seen = new Set(existing.map(buildItemKey));
          incoming.forEach((item) => {
            const key = buildItemKey(item);
            if (!seen.has(key)) {
              merged.push(item);
              seen.add(key);
            }
          });
          return merged;
        }

        function readDirectoryEntries(directoryEntry) {
          const reader = directoryEntry.createReader();
          return new Promise((resolve) => {
            const entries = [];
            const readBatch = () => {
              reader.readEntries(
                (batch) => {
                  if (!batch.length) {
                    resolve(entries);
                    return;
                  }
                  entries.push(...batch);
                  readBatch();
                },
                () => resolve(entries)
              );
            };
            readBatch();
          });
        }

        async function traverseEntry(entry, pathPrefix) {
          if (!entry) {
            return [];
          }
          if (entry.isFile) {
            return new Promise((resolve) => {
              entry.file(
                (file) => resolve([{ file, displayPath: `${pathPrefix}${file.name}` }]),
                () => resolve([])
              );
            });
          }
          if (entry.isDirectory) {
            const nextPrefix = `${pathPrefix}${entry.name}/`;
            const children = await readDirectoryEntries(entry);
            const nested = await Promise.all(
              children.map((child) => traverseEntry(child, nextPrefix))
            );
            return nested.flat();
          }
          return [];
        }

        async function collectDroppedItems(dataTransfer) {
          if (!dataTransfer) {
            return { items: [], skipped: 0, usedEntries: false };
          }
          const dataItems = Array.from(dataTransfer.items || []);
          const entries = dataItems
            .map((item) =>
              typeof item.webkitGetAsEntry === "function" ? item.webkitGetAsEntry() : null
            )
            .filter(Boolean);
          if (entries.length > 0) {
            const collected = await Promise.all(entries.map((entry) => traverseEntry(entry, "")));
            const rawItems = collected.flat();
            const prepared = prepareItems(rawItems);
            return { ...prepared, usedEntries: true };
          }
          const files = Array.from(dataTransfer.files || []);
          const rawItems = files.map((file) => ({ file, displayPath: file.name }));
          const prepared = prepareItems(rawItems);
          return { ...prepared, usedEntries: false };
        }

        function isFileDrag(event) {
          if (!event.dataTransfer) {
            return false;
          }
          const types = Array.from(event.dataTransfer.types || []);
          if (types.includes("Files") || types.includes("public.file-url")) {
            return true;
          }
          if (event.dataTransfer.files && event.dataTransfer.files.length > 0) {
            return true;
          }
          if (event.dataTransfer.items && event.dataTransfer.items.length > 0) {
            return true;
          }
          return false;
        }

        function formatRelative(date) {
          if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
            return "";
          }
          const diffMs = date.getTime() - Date.now();
          const absMs = Math.abs(diffMs);
          if (absMs < 45000) {
            return "just now";
          }
          const units = [
            ["year", 31536000000],
            ["month", 2592000000],
            ["day", 86400000],
            ["hour", 3600000],
            ["minute", 60000],
          ];
          for (const [unit, unitMs] of units) {
            if (absMs >= unitMs) {
              const value = Math.round(diffMs / unitMs);
              if (relativeFormatter) {
                return relativeFormatter.format(value, unit);
              }
              const rounded = Math.abs(value);
              return `${rounded} ${unit}${rounded === 1 ? "" : "s"} ${
                value < 0 ? "ago" : "from now"
              }`;
            }
          }
          const seconds = Math.round(diffMs / 1000);
          if (relativeFormatter) {
            return relativeFormatter.format(seconds, "second");
          }
          const absSeconds = Math.abs(seconds);
          return `${absSeconds} sec ${seconds < 0 ? "ago" : "from now"}`;
        }

        function formatTimestamp(isoString) {
          if (!isoString) {
            return { absolute: "", relative: "" };
          }
          const date = new Date(isoString);
          if (Number.isNaN(date.getTime())) {
            return { absolute: isoString, relative: "" };
          }
          let absolute = "";
          try {
            absolute = date.toLocaleString([], {
              year: "numeric",
              month: "short",
              day: "numeric",
              hour: "2-digit",
              minute: "2-digit",
            });
          } catch (error) {
            absolute = date.toLocaleString();
          }
          return { absolute, relative: formatRelative(date) };
        }

        function formatDuration(ms) {
          const totalSeconds = Math.max(0, Math.floor(ms / 1000));
          const hours = Math.floor(totalSeconds / 3600);
          const minutes = Math.floor((totalSeconds % 3600) / 60);
          const seconds = totalSeconds % 60;
          const paddedMinutes = String(minutes).padStart(2, "0");
          const paddedSeconds = String(seconds).padStart(2, "0");
          if (hours > 0) {
            return `${String(hours).padStart(2, "0")}:${paddedMinutes}:${paddedSeconds}`;
          }
          return `${paddedMinutes}:${paddedSeconds}`;
        }

        function formatElapsed(isoString) {
          if (!isoString) {
            return "";
          }
          const startedAt = new Date(isoString);
          if (Number.isNaN(startedAt.getTime())) {
            return "";
          }
          return formatDuration(Date.now() - startedAt.getTime());
        }

        function calculateDuration(startIso, endIso) {
          if (!startIso || !endIso) {
            return "";
          }
          const start = new Date(startIso);
          const end = new Date(endIso);
          if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime())) {
            return "";
          }
          const diff = Math.max(0, end.getTime() - start.getTime());
          if (!diff) {
            return "";
          }
          return formatDuration(diff);
        }

        function formatTimeMeta(status, createdAt, startedAt, completedAt) {
          const normalized = String(status || "").toLowerCase();
          let label = "Updated";
          if (normalized === "done") {
            label = "Completed";
          } else if (normalized === "failed") {
            label = "Failed";
          } else if (normalized === "running") {
            label = "Running";
          } else if (normalized === "queued") {
            label = "Queued";
          }
          const anchorIso =
            normalized === "done" || normalized === "failed"
              ? completedAt || startedAt || createdAt
              : normalized === "running"
                ? startedAt || createdAt
                : createdAt || startedAt || completedAt;
          const { absolute, relative } = formatTimestamp(anchorIso);
          const timeText = relative || absolute;
          if (!timeText) {
            return { text: "", title: "" };
          }
          let text = `${label} ${timeText}`;
          if ((normalized === "done" || normalized === "failed") && completedAt) {
            const duration = calculateDuration(startedAt || createdAt, completedAt);
            if (duration) {
              text += ` · ${duration}`;
            }
          }
          return { text, title: absolute };
        }

        function hydrateTimeMeta(root) {
          const scope = root || document;
          scope.querySelectorAll("[data-time-meta]").forEach((element) => {
            const status = element.getAttribute("data-status") || "";
            const createdAt = element.getAttribute("data-created-at") || "";
            const startedAt = element.getAttribute("data-started-at") || "";
            const completedAt = element.getAttribute("data-completed-at") || "";
            const meta = formatTimeMeta(status, createdAt, startedAt, completedAt);
            if (!meta.text) {
              return;
            }
            element.textContent = meta.text;
            if (meta.title) {
              element.setAttribute("title", meta.title);
            }
          });
        }

        function hydrateTimestamps(root) {
          const scope = root || document;
          scope.querySelectorAll("[data-iso][data-label]").forEach((element) => {
            const isoString = element.getAttribute("data-iso");
            const label = element.getAttribute("data-label") || "";
            const { absolute, relative } = formatTimestamp(isoString);
            if (!absolute) {
              return;
            }
            const relativeText = relative ? ` · ${relative}` : "";
            element.textContent = `${label} ${absolute}${relativeText}`;
          });
        }

        function hydrateElapsed(root) {
          const scope = root || document;
          scope.querySelectorAll("[data-started-at]").forEach((element) => {
            const isoString = element.getAttribute("data-started-at");
            const elapsed = formatElapsed(isoString);
            element.textContent = elapsed ? `Running ${elapsed}` : "";
          });
        }

        function updateQueueCount(count) {
          const label = count === 1 ? "file" : "files";
          queueCountEls.forEach((element) => {
            element.textContent = `${count} ${label} queued`;
          });
        }

        function updateHistoryClearState(count) {
          if (!historyClearButton) {
            return;
          }
          historyClearButton.disabled = !count;
        }

        function getHistoryRowSummary(row) {
          const filenameEl = row ? row.querySelector(".history-filename") : null;
          const filename = filenameEl ? filenameEl.textContent.trim() : "Untitled file";
          const timeEl = row ? row.querySelector("[data-time-meta]") : null;
          const createdAt = timeEl ? timeEl.getAttribute("data-created-at") || "" : "";
          const startedAt = timeEl ? timeEl.getAttribute("data-started-at") || "" : "";
          const completedAt = timeEl ? timeEl.getAttribute("data-completed-at") || "" : "";
          const anchorIso = completedAt || startedAt || createdAt;
          const { absolute } = formatTimestamp(anchorIso);
          const duration = calculateDuration(startedAt || createdAt, completedAt);
          const chips = row ? Array.from(row.querySelectorAll(".output-chip")) : [];
          const outputs = chips
            .map((chip) => chip.textContent.trim())
            .filter((text) => Boolean(text));
          return {
            filename,
            absoluteTime: absolute,
            duration,
            outputs,
          };
        }

        function buildHistoryDeleteMessage(summary) {
          const timeParts = [];
          if (summary.absoluteTime) {
            timeParts.push(summary.absoluteTime);
          }
          if (summary.duration) {
            timeParts.push(summary.duration);
          }
          const timeText = timeParts.length ? ` (${timeParts.join(" · ")})` : "";
          const lines = [
            `Delete "${summary.filename}"${timeText}?`,
            "This removes the job from History and deletes its stored outputs (transcripts/logs) from disk.",
          ];
          if (summary.outputs.length) {
            lines.push(`Outputs: ${summary.outputs.join(", ")}`);
          }
          lines.push("Downloaded files, clipboard contents, and Telegram copies aren't removed.");
          return lines.join("\n");
        }

        function buildHistoryClearMessage(count) {
          const label = count === 1 ? "item" : "items";
          return [
            "Delete all results?",
            `This will delete ${count} completed ${label} and remove their stored outputs (transcripts/logs) from disk.`,
            "This can't be undone.",
            "Downloaded files, clipboard contents, and Telegram copies aren't removed.",
          ].join("\n");
        }

        if (uploadForm && fileInput && dropzone && fileList && fileSummary && uploadSubmit) {
          renderFileList();

          fileInput.addEventListener("change", () => {
            if (syncingInput) {
              return;
            }
            const rawItems = Array.from(fileInput.files || []).map((file) => ({
              file,
              displayPath: file.webkitRelativePath || file.name,
            }));
            const prepared = prepareItems(rawItems);
            setPendingItems(prepared.items, prepared.skipped);
          });

          if (folderInput) {
            folderInput.addEventListener("change", () => {
              const rawItems = Array.from(folderInput.files || []).map((file) => ({
                file,
                displayPath: file.webkitRelativePath || file.name,
              }));
              const prepared = prepareItems(rawItems);
              setPendingItems(prepared.items, prepared.skipped);
            });
          }

          if (fileListToggle) {
            fileListToggle.addEventListener("click", () => {
              showAllFiles = !showAllFiles;
              renderFileList();
            });
          }

          dropzone.addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              fileInput.click();
            }
          });

          dropzone.addEventListener("dragenter", (event) => {
            if (!isFileDrag(event)) {
              return;
            }
            event.preventDefault();
            dragDepth += 1;
            dropzone.classList.add("is-active");
          });

          dropzone.addEventListener("dragover", (event) => {
            if (!isFileDrag(event)) {
              return;
            }
            event.preventDefault();
          });

          dropzone.addEventListener("dragleave", (event) => {
            if (!isFileDrag(event)) {
              return;
            }
            dragDepth = Math.max(0, dragDepth - 1);
            if (dragDepth === 0) {
              dropzone.classList.remove("is-active");
            }
          });

          dropzone.addEventListener("drop", async (event) => {
            if (!isFileDrag(event)) {
              return;
            }
            event.preventDefault();
            dragDepth = 0;
            dropzone.classList.remove("is-active");
            if (!event.dataTransfer) {
              return;
            }
            const shouldScan = Array.from(event.dataTransfer.items || []).some((item) => {
              if (typeof item.webkitGetAsEntry !== "function") {
                return false;
              }
              const entry = item.webkitGetAsEntry();
              return entry && entry.isDirectory;
            });
            if (shouldScan) {
              scanningFolder = true;
              renderFileList();
            }
            let prepared;
            try {
              prepared = await collectDroppedItems(event.dataTransfer);
            } finally {
              if (shouldScan) {
                scanningFolder = false;
              }
            }
            if (!prepared) {
              renderFileList();
              return;
            }
            const nextSkipped = skippedCount + prepared.skipped;
            if (prepared.items.length === 0) {
              skippedCount = nextSkipped;
              renderFileList();
              return;
            }
            const merged = mergeItems(pendingItems, prepared.items);
            setPendingItems(merged, nextSkipped);
          });

          fileList.addEventListener("click", (event) => {
            const target = event.target.closest("[data-remove-index]");
            if (!target) {
              return;
            }
            const index = Number(target.dataset.removeIndex);
            if (Number.isNaN(index)) {
              return;
            }
            const nextItems = pendingItems.slice();
            nextItems.splice(index, 1);
            setPendingItems(nextItems, skippedCount);
          });

          uploadForm.addEventListener("submit", async (event) => {
            event.preventDefault();
            if (uploadInFlight || pendingItems.length === 0) {
              return;
            }
            uploadInFlight = true;
            uploadSubmit.disabled = true;
            try {
              const formData = new FormData();
              pendingItems.forEach((item) => {
                formData.append("files", item.file, item.displayPath || item.file.name);
              });
              const response = await fetch("/upload", {
                method: "POST",
                body: formData,
              });
              if (response.ok) {
                window.location = "/?tab=queue";
                return;
              }
              const message = await response.text();
              console.error("Upload failed", response.status, message);
              alert("Upload failed. Check the console for details.");
            } catch (error) {
              console.error("Upload failed", error);
              alert("Upload failed. Check the console for details.");
            } finally {
              uploadInFlight = false;
              uploadSubmit.disabled = pendingItems.length === 0;
            }
          });
        }

        function pickDefaultResult(results) {
          if (!results || results.length === 0) {
            return "";
          }
          const preferred = results.find((result) => result.toLowerCase().endsWith(".txt"));
          return preferred || results[0];
        }

        function summarizeError(message, limit = 160) {
          if (!message) {
            return "";
          }
          const firstLine = String(message).split(/\r?\n/)[0].trim();
          if (!firstLine) {
            return "";
          }
          const condensed = firstLine.replace(/\s+/g, " ");
          if (condensed.length <= limit) {
            return condensed;
          }
          return `${condensed.slice(0, Math.max(limit - 1, 0))}…`;
        }

        function buildOutputChips(jobId, results) {
          if (!results || results.length === 0) {
            return "";
          }
          const seen = new Set();
          const chips = [];
          results.forEach((result) => {
            const parts = String(result).split(".");
            const ext = parts.length > 1 ? parts[parts.length - 1] : "file";
            const label = ext.toUpperCase();
            if (seen.has(label)) {
              return;
            }
            seen.add(label);
            chips.push(
              `<span class="output-chip">${escapeHtml(label)}</span>`
            );
          });
          if (chips.length === 0) {
            return "";
          }
          return `<div class="output-chips">${chips.join("")}</div>`;
        }

        function buildOutputList(jobId, results) {
          if (!results || results.length === 0) {
            return "";
          }
          const encodedJobId = encodeURIComponent(jobId);
          const items = results
            .map((result) => {
              const encodedResult = encodeURIComponent(result);
              const safeResult = escapeHtml(result);
              return `
                <li class="detail-result-item">
                  <a
                    class="detail-result-link"
                    href="/results/${encodedJobId}/${encodedResult}"
                    target="_blank"
                    rel="noopener"
                  >
                    ${safeResult}
                  </a>
                </li>
              `;
            })
            .join("");
          return `
            <div class="detail-block">
              <div class="detail-label">Outputs</div>
              <ul class="detail-results">${items}</ul>
            </div>
          `;
        }

        function buildMetaLine(label, isoString, className) {
          if (!isoString) {
            return "";
          }
          const classLabel = className || "job-meta";
          return `
            <div class="${classLabel}" data-iso="${escapeHtml(isoString)}" data-label="${escapeHtml(
              label
            )}"></div>
          `;
        }

        function buildMetaLines(job) {
          const lines = [buildMetaLine("Added", job.created_at, "job-meta")];
          if (job.started_at) {
            lines.push(buildMetaLine("Started", job.started_at, "job-meta"));
          }
          if (job.completed_at) {
            lines.push(buildMetaLine("Completed", job.completed_at, "job-meta"));
          }
          return lines.join("");
        }

        function buildQueueActions(job, extra) {
          const status = `<div class="job-status">${escapeHtml(job.status)}</div>`;
          const extraBlock = extra || "";
          const canDelete = job.status === "queued";
          const binButton = canDelete
            ? `
              <button
                class="job-bin"
                type="button"
                data-job-id="${escapeHtml(job.id)}"
                aria-label="Remove from queue"
                title="Remove from queue"
              >
                <svg class="job-bin-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M9 3h6l1 2h5v2H3V5h5l1-2zm-2 6h2v9H7V9zm4 0h2v9h-2V9zm4 0h2v9h-2V9z"></path>
                </svg>
                <span class="sr-only">Remove</span>
              </button>
            `
            : "";
          return `<div class="job-actions">${status}${extraBlock}${binButton}</div>`;
        }

        function buildQueueLine(position) {
          if (!position) {
            return "";
          }
          const itemsAhead = Math.max(position - 1, 0);
          const label = itemsAhead === 1 ? "item" : "items";
          return `<div class="job-queue">${itemsAhead} ${label} ahead</div>`;
        }

        function buildQueueRow(job, options) {
          const opts = options || {};
          const isRunning = Boolean(opts.isRunning);
          const queuePosition = opts.queuePosition || 0;
          const icon = isRunning ? '<div class="job-icon" aria-hidden="true">⏳</div>' : "";
          const metaLines = buildMetaLines(job);
          const queueLine = buildQueueLine(queuePosition);
          const elapsed =
            isRunning && job.started_at
              ? `<div class="job-elapsed" data-started-at="${escapeHtml(job.started_at)}"></div>`
              : "";
          const actions = buildQueueActions(job, elapsed);
          return `
            <div class="job-row${isRunning ? " is-running" : ""}">
              ${icon}
              <div class="job-body">
                <div class="job-name">${escapeHtml(job.filename)}</div>
                ${metaLines}
                ${queueLine}
              </div>
              ${actions}
            </div>
          `;
        }

        function buildHistoryMenu(job, results, defaultResult, isOpen) {
          const status = (job.status || "").toLowerCase();
          const encodedJobId = encodeURIComponent(job.id);
          const safeFilename = escapeHtml(job.filename || "Untitled file");
          const openAttr = isOpen ? " open" : "";
          const items = [];
          if (status === "done" && defaultResult) {
            const encodedResult = encodeURIComponent(defaultResult);
            items.push(`
              <a
                class="job-menu-item"
                role="menuitem"
                href="/results/${encodedJobId}/${encodedResult}"
                target="_blank"
                rel="noopener"
              >
                Open transcript
              </a>
            `);
          }
          if (results && results.length > 0) {
            results.forEach((result) => {
              const encodedResult = encodeURIComponent(result);
              const parts = String(result).split(".");
              const ext = parts.length > 1 ? parts[parts.length - 1].toUpperCase() : "FILE";
              items.push(`
                <a
                  class="job-menu-item"
                  role="menuitem"
                  href="/results/${encodedJobId}/${encodedResult}"
                  download="${escapeHtml(result)}"
                >
                  Download ${escapeHtml(ext)}
                </a>
              `);
            });
          }
          if (status === "done" && defaultResult) {
            items.push(`
              <button
                class="job-menu-item"
                type="button"
                role="menuitem"
                data-action="copy-preview"
                data-job-id="${escapeHtml(job.id)}"
              >
                Copy preview
              </button>
            `);
          }
          items.push(`
            <button
              class="job-menu-item"
              type="button"
              role="menuitem"
              data-action="copy-filename"
              data-filename="${safeFilename}"
            >
              Copy filename
            </button>
          `);
          items.push('<div class="job-menu-divider" role="separator"></div>');
          items.push(`
            <button
              class="job-menu-item is-danger"
              type="button"
              role="menuitem"
              data-action="delete-history"
            >
              Delete...
            </button>
          `);
          return `
            <details class="job-menu"${openAttr}>
              <summary aria-label="More actions">⋯</summary>
              <div class="job-menu-panel" role="menu">
                ${items.join("")}
              </div>
            </details>
          `;
        }

        function buildHistoryDetails(job, results, defaultResult, isOpen) {
          const status = (job.status || "").toLowerCase();
          const encodedJobId = encodeURIComponent(job.id);
          const openAttr = isOpen ? " open" : "";
          const timelineLines = [
            buildMetaLine("Added", job.created_at, "detail-line"),
            job.started_at ? buildMetaLine("Started", job.started_at, "detail-line") : "",
            job.completed_at
              ? buildMetaLine(status === "failed" ? "Failed" : "Completed", job.completed_at, "detail-line")
              : "",
          ].join("");

          const previewBlock =
            status === "done" && defaultResult
              ? `
                <div
                  class="detail-block"
                  data-preview-block
                  data-preview-url="/api/jobs/${encodedJobId}/preview?chars=300"
                >
                  <div class="detail-label">Preview</div>
                  <div class="preview-snippet is-loading" data-preview-snippet>
                    Preview will load when expanded.
                  </div>
                  <div class="preview-actions">
                    <button
                      class="preview-action"
                      type="button"
                      data-action="copy-preview"
                      data-job-id="${escapeHtml(job.id)}"
                    >
                      Copy preview
                    </button>
                    <a
                      class="preview-action"
                      href="/results/${encodeURIComponent(job.id)}/${encodeURIComponent(defaultResult)}"
                      target="_blank"
                      rel="noopener"
                    >
                      Open
                    </a>
                  </div>
                </div>
              `
              : "";

          const outputsBlock = buildOutputList(job.id, results);
          const logBlock =
            status === "failed" && job.error_message
              ? `
                <div class="detail-block">
                  <div class="detail-label">Log</div>
                  <div class="detail-log" data-log>${escapeHtml(job.error_message)}</div>
                </div>
              `
              : "";

          return `
            <details class="job-details" data-job-id="${escapeHtml(job.id)}"${openAttr}>
              <summary>
                <span>Details</span>
                <span class="details-chevron" aria-hidden="true">▾</span>
              </summary>
              <div class="job-details-body">
                <div class="detail-block">
                  <div class="detail-label">Timeline</div>
                  ${timelineLines}
                </div>
                ${previewBlock}
                ${outputsBlock}
                ${logBlock}
              </div>
            </details>
          `;
        }

        function buildHistoryRow(job, resultsByJob, openJobs, openMenus) {
          const results = (resultsByJob || {})[job.id] || [];
          const defaultResult = pickDefaultResult(results);
          const safeFilename = escapeHtml(job.filename || "Untitled file");
          const status = (job.status || "unknown").toLowerCase();
          const statusClass = `is-${escapeHtml(status)}`;
          const errorSummaryText =
            status === "failed" && job.error_message ? summarizeError(job.error_message) : "";
          const isOpen = openJobs ? openJobs.has(job.id) : false;
          const isMenuOpen = openMenus ? openMenus.has(job.id) : false;
          const timeMeta = `
            <div
              class="history-time"
              data-time-meta
              data-status="${escapeHtml(status)}"
              data-created-at="${escapeHtml(job.created_at || "")}"
              data-started-at="${escapeHtml(job.started_at || "")}"
              data-completed-at="${escapeHtml(job.completed_at || "")}"
            ></div>
          `;
          const errorSummary =
            errorSummaryText
              ? `
                <div class="history-error-summary" title="${escapeHtml(errorSummaryText)}">
                  ${escapeHtml(errorSummaryText)}
                </div>
              `
              : "";
          const chips = buildOutputChips(job.id, results);
          const primaryAction =
            status === "done" && defaultResult
              ? `
                <a
                  class="job-primary"
                  href="/results/${encodeURIComponent(job.id)}/${encodeURIComponent(defaultResult)}"
                  download="${escapeHtml(defaultResult)}"
                >
                  Download
                </a>
              `
              : status === "failed"
                ? `
                  <button class="job-primary is-secondary" type="button" data-action="view-log">
                    View log
                  </button>
                `
                : "";

          return `
            <div class="history-row" data-job-id="${escapeHtml(job.id)}">
              <div class="history-main">
                <div class="history-title">
                  <div class="history-filename" title="${safeFilename}">${safeFilename}</div>
                  <div class="status-badge ${statusClass}">${escapeHtml(status)}</div>
                </div>
                ${timeMeta}
                ${errorSummary}
              </div>
              <div class="history-actions">
                ${chips}
                ${primaryAction}
                ${buildHistoryMenu(job, results, defaultResult, isMenuOpen)}
              </div>
              ${buildHistoryDetails(job, results, defaultResult, isOpen)}
            </div>
          `;
        }

        function buildToast(job, resultsByJob, opts) {
          if (!toastStack) {
            return;
          }
          const options = opts || {};
          const isFailed = job.status === "failed";
          const duration = options.duration || (isFailed ? 14000 : 9000);

          const toast = document.createElement("div");
          toast.className = `toast ${isFailed ? "is-failed" : "is-done"}`;
          toast.style.setProperty("--toast-duration", `${duration}ms`);
          toast.setAttribute("role", isFailed ? "alert" : "status");
          toast.setAttribute("aria-atomic", "true");
          if (options.clickable) {
            toast.classList.add("is-clickable");
            toast.setAttribute("tabindex", "0");
          }

          const icon = document.createElement("div");
          icon.className = "toast__icon";
          icon.innerHTML = isFailed ? ICON_ERROR : ICON_CHECK;

          const header = document.createElement("div");
          header.className = "toast__header";

          const title = document.createElement("div");
          title.className = "toast__title";
          title.textContent =
            options.title ||
            (isFailed ? "Transcription failed" : "Transcription complete");

          const meta = document.createElement("div");
          meta.className = "toast__meta";
          if (job.completed_at && options.showTime !== false) {
            try {
              meta.textContent = new Date(job.completed_at).toLocaleTimeString([], {
                hour: "2-digit",
                minute: "2-digit",
              });
            } catch (error) {
              meta.textContent = "";
            }
          }

          header.appendChild(title);
          if (meta.textContent) {
            header.appendChild(meta);
          }

          const body = document.createElement("div");
          body.className = "toast__body";
          const bodyText = options.body || job.filename || "Unknown file";
          body.textContent = bodyText;
          body.title = bodyText;

          const dismiss = document.createElement("button");
          dismiss.className = "toast__dismiss";
          dismiss.type = "button";
          dismiss.setAttribute("aria-label", "Dismiss notification");
          dismiss.innerHTML = ICON_X;

          const progress = document.createElement("div");
          progress.className = "toast__progress";
          const bar = document.createElement("div");
          bar.className = "toast__progressBar";
          progress.appendChild(bar);

          const toastLimit = 4;
          while (toastStack.children.length >= toastLimit) {
            toastStack.removeChild(toastStack.firstElementChild);
          }

          toast.appendChild(icon);
          toast.appendChild(header);
          toast.appendChild(dismiss);
          toast.appendChild(body);
          toast.appendChild(progress);
          toastStack.appendChild(toast);
          requestAnimationFrame(() => {
            toast.classList.add("is-visible");
          });

          let timeoutId = null;
          let remaining = duration;
          let startedAt = performance.now();

          function cleanup() {
            window.removeEventListener("keydown", onKeyDown);
          }

          function dismissToast() {
            window.clearTimeout(timeoutId);
            timeoutId = null;
            toast.classList.remove("is-visible");
            cleanup();
            window.setTimeout(() => toast.remove(), 200);
          }

          function schedule(ms) {
            window.clearTimeout(timeoutId);
            startedAt = performance.now();
            timeoutId = window.setTimeout(dismissToast, ms);
          }

          function pause() {
            if (!timeoutId) {
              return;
            }
            const elapsed = performance.now() - startedAt;
            remaining = Math.max(0, remaining - elapsed);
            window.clearTimeout(timeoutId);
            timeoutId = null;
            toast.classList.add("is-paused");
          }

          function resume() {
            if (timeoutId) {
              return;
            }
            toast.classList.remove("is-paused");
            if (remaining <= 0) {
              dismissToast();
              return;
            }
            schedule(remaining);
          }

          function onKeyDown(event) {
            if (event.key === "Escape") {
              if (toastStack && toastStack.lastElementChild === toast) {
                dismissToast();
              }
            }
          }

          dismiss.addEventListener("click", (event) => {
            event.stopPropagation();
            dismissToast();
          });
          toast.addEventListener("mouseenter", pause);
          toast.addEventListener("mouseleave", resume);
          toast.addEventListener("focusin", pause);
          toast.addEventListener("focusout", resume);
          window.addEventListener("keydown", onKeyDown);

          toast.addEventListener("click", () => {
            if (!options.clickable) {
              return;
            }
            window.location.href = options.link || "/?tab=history";
          });

          toast.addEventListener("keydown", (event) => {
            if (!options.clickable) {
              return;
            }
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              window.location.href = options.link || "/?tab=history";
            }
          });

          schedule(remaining);
        }

        function handleNotifications(history, resultsByJob) {
          const completed = (history || []).filter(
            (job) => job.status === "done" || job.status === "failed"
          );
          if (!notificationsSeeded) {
            completed.forEach((job) => notifiedJobIds.add(job.id));
            notificationsSeeded = true;
            return;
          }
          completed.forEach((job) => {
            if (!notifiedJobIds.has(job.id)) {
              notifiedJobIds.add(job.id);
              buildToast(job, resultsByJob, { clickable: true });
            }
          });
        }

        function notifySystem(titleText, bodyText, kind) {
          const isError = kind === "error";
          buildToast(
            {
              id: `system-${Date.now()}`,
              status: isError ? "failed" : "done",
              filename: bodyText,
              completed_at: new Date().toISOString(),
            },
            {},
            {
              title: titleText,
              body: bodyText,
              duration: isError ? 14000 : 8000,
              showTime: false,
              clickable: false,
            }
          );
        }

        async function copyToClipboard(text) {
          if (!text) {
            return false;
          }
          try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(text);
              return true;
            }
          } catch (error) {
            // Fall back to execCommand below.
          }
          try {
            const textarea = document.createElement("textarea");
            textarea.value = text;
            textarea.setAttribute("readonly", "");
            textarea.style.position = "absolute";
            textarea.style.left = "-9999px";
            document.body.appendChild(textarea);
            textarea.select();
            const success = document.execCommand("copy");
            document.body.removeChild(textarea);
            return success;
          } catch (error) {
            return false;
          }
        }

        async function fetchPreviewSnippet(jobId, url) {
          if (previewCache.has(jobId)) {
            return previewCache.get(jobId);
          }
          const response = await fetch(url, { cache: "no-store" });
          if (!response.ok) {
            throw new Error("Failed to load preview.");
          }
          const payload = await response.json();
          const data = {
            snippet: payload.snippet || "",
            truncated: Boolean(payload.truncated),
            filename: payload.filename || "",
          };
          previewCache.set(jobId, data);
          return data;
        }

        function updatePreviewBlock(block, payload) {
          if (!block) {
            return;
          }
          const snippetEl = block.querySelector("[data-preview-snippet]");
          if (!snippetEl) {
            return;
          }
          let text = payload.snippet || "";
          if (!text) {
            text = "No preview available.";
          } else if (payload.truncated) {
            text = `${text}…`;
          }
          snippetEl.textContent = text;
          snippetEl.classList.remove("is-loading");
          block.dataset.previewState = "loaded";
        }

        async function loadPreviewBlock(block) {
          if (!block || block.dataset.previewState === "loading" || block.dataset.previewState === "loaded") {
            return;
          }
          const row = block.closest(".history-row");
          const jobId = row ? row.getAttribute("data-job-id") : "";
          const url = block.getAttribute("data-preview-url") || "";
          if (!jobId || !url) {
            return;
          }
          block.dataset.previewState = "loading";
          const snippetEl = block.querySelector("[data-preview-snippet]");
          if (snippetEl) {
            snippetEl.textContent = "Loading preview…";
            snippetEl.classList.add("is-loading");
          }
          try {
            const payload = await fetchPreviewSnippet(jobId, url);
            updatePreviewBlock(block, payload);
          } catch (error) {
            console.warn("Failed to load preview", error);
            if (snippetEl) {
              snippetEl.textContent = "Preview unavailable.";
              snippetEl.classList.remove("is-loading");
            }
            block.dataset.previewState = "";
          }
        }

        async function copyPreviewForJob(jobId, row) {
          const block = row ? row.querySelector("[data-preview-block]") : null;
          if (!block) {
            notifySystem("Preview unavailable", "No preview available.", "error");
            return;
          }
          const url = block.getAttribute("data-preview-url") || "";
          if (!url) {
            notifySystem("Preview unavailable", "No preview available.", "error");
            return;
          }
          try {
            const payload = await fetchPreviewSnippet(jobId, url);
            updatePreviewBlock(block, payload);
            const text = payload.snippet
              ? payload.truncated
                ? `${payload.snippet}…`
                : payload.snippet
              : "";
            if (!text) {
              notifySystem("Preview unavailable", "No preview available.", "error");
              return;
            }
            const success = await copyToClipboard(text);
            if (success) {
              notifySystem("Copied to clipboard", "Preview copied.", "success");
            } else {
              throw new Error("Copy failed");
            }
          } catch (error) {
            console.warn("Failed to copy preview", error);
            notifySystem("Copy failed", "Unable to copy preview.", "error");
          }
        }

        function wireHistoryDetails(listEl) {
          if (!listEl) {
            return;
          }
          listEl.querySelectorAll(".job-details").forEach((details) => {
            details.addEventListener("toggle", () => {
              if (!details.open) {
                return;
              }
              const previewBlock = details.querySelector("[data-preview-block]");
              if (previewBlock) {
                void loadPreviewBlock(previewBlock);
              }
            });
            if (details.open) {
              const previewBlock = details.querySelector("[data-preview-block]");
              if (previewBlock) {
                void loadPreviewBlock(previewBlock);
              }
            }
          });
        }

        function renderQueue(listEl, placeholderEl, jobs) {
          if (!listEl) {
            return;
          }
          if (!jobs || jobs.length === 0) {
            listEl.innerHTML = "";
            if (placeholderEl) {
              placeholderEl.style.display = "none";
            }
            return;
          }
          if (placeholderEl) {
            placeholderEl.style.display = "none";
          }
          const hasRunning = jobs.some((job) => job.status === "running");
          let queuedIndex = 0;
          const rendered = [];
          for (const job of jobs) {
            const isRunning = job.status === "running";
            let queuePosition = 0;
            if (job.status === "queued") {
              queuedIndex += 1;
              queuePosition = queuedIndex + (hasRunning ? 1 : 0);
            }
            rendered.push(
              buildQueueRow(job, {
                queuePosition,
                isRunning,
              })
            );
          }
          listEl.innerHTML = rendered.join("");
          hydrateTimestamps(listEl);
          hydrateElapsed(listEl);
        }

        function renderHistory(listEl, placeholderEl, jobs, resultsByJob) {
          if (!listEl || !placeholderEl) {
            return;
          }
          if (!jobs || jobs.length === 0) {
            listEl.innerHTML = "";
            placeholderEl.style.display = "grid";
            updateHistoryClearState(0);
            return;
          }
          const openJobs = new Set();
          const openMenus = new Set();
          listEl.querySelectorAll(".job-details[open]").forEach((details) => {
            const row = details.closest(".history-row");
            const jobId = row ? row.getAttribute("data-job-id") : "";
            if (jobId) {
              openJobs.add(jobId);
            }
          });
          listEl.querySelectorAll(".job-menu[open]").forEach((menu) => {
            const row = menu.closest(".history-row");
            const jobId = row ? row.getAttribute("data-job-id") : "";
            if (jobId) {
              openMenus.add(jobId);
            }
          });
          placeholderEl.style.display = "none";
          listEl.innerHTML = jobs
            .map((job) => buildHistoryRow(job, resultsByJob, openJobs, openMenus))
            .join("");
          hydrateTimestamps(listEl);
          hydrateTimeMeta(listEl);
          wireHistoryDetails(listEl);
          updateHistoryClearState(jobs.length);
        }

        async function refreshState() {
          try {
            const response = await fetch("/api/state", { cache: "no-store" });
            if (!response.ok) {
              return;
            }
            const payload = await response.json();
            const resultsByJob = payload.results_by_job || {};
            const queue = payload.queue || [];
            const workerState =
              payload.worker && payload.worker.status ? payload.worker.status : "Idle";
            renderQueue(queueList, null, queue);
            renderHistory(historyList, historyPlaceholder, payload.history || [], resultsByJob);
            handleNotifications(payload.history || [], resultsByJob);
            updateQueueCount(queue.filter((job) => job.status === "queued").length);
            if (payload.worker && workerStatus && workerDetail) {
              workerStatus.textContent = workerState || "Idle";
              if (workerState === "Running" && payload.worker.filename) {
                const elapsed = formatElapsed(payload.worker.started_at);
                const suffix = elapsed ? ` · ${elapsed}` : "";
                workerDetail.textContent = `Running ${payload.worker.filename}${suffix}`;
              } else {
                workerDetail.textContent = "Sequential queue, one job at a time.";
              }
            }
          } catch (error) {
            console.warn("Failed to refresh state", error);
          }
        }

        async function deleteQueuedJob(jobId) {
          const response = await fetch(`/api/jobs/${encodeURIComponent(jobId)}`, {
            method: "DELETE",
          });
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(errorText || "Failed to remove job.");
          }
        }

        async function deleteHistoryJob(jobId) {
          const response = await fetch(`/api/history/${encodeURIComponent(jobId)}`, {
            method: "DELETE",
          });
          let payload = {};
          try {
            payload = await response.json();
          } catch (error) {
            payload = {};
          }
          if (!response.ok) {
            const message = payload && payload.detail ? payload.detail : "Failed to delete history item.";
            throw new Error(message);
          }
          return payload;
        }

        async function clearHistoryJobs() {
          const response = await fetch("/api/history/clear", {
            method: "POST",
          });
          let payload = {};
          try {
            payload = await response.json();
          } catch (error) {
            payload = {};
          }
          if (!response.ok) {
            const message = payload && payload.detail ? payload.detail : "Failed to clear history.";
            throw new Error(message);
          }
          return payload;
        }

        if (queueList) {
          queueList.addEventListener("click", async (event) => {
            const target = event.target;
            if (!(target instanceof Element)) {
              return;
            }
            const button = target.closest(".job-bin");
            if (!button) {
              return;
            }
            const jobId = button.getAttribute("data-job-id");
            if (!jobId) {
              return;
            }
            if (!window.confirm("Remove this job from the queue?")) {
              return;
            }
            button.setAttribute("disabled", "disabled");
            try {
              await deleteQueuedJob(jobId);
            } catch (error) {
              console.warn("Failed to remove queued job", error);
              notifySystem("Action failed", "Failed to remove queued job.", "error");
            } finally {
              await refreshState();
            }
          });
        }

        if (historyClearButton) {
          historyClearButton.addEventListener("click", async () => {
            if (historyClearButton.disabled) {
              return;
            }
            const count = historyList ? historyList.querySelectorAll(".history-row").length : 0;
            if (!count) {
              updateHistoryClearState(0);
              return;
            }
            if (!window.confirm(buildHistoryClearMessage(count))) {
              return;
            }
            historyClearButton.setAttribute("disabled", "disabled");
            try {
              const payload = await clearHistoryJobs();
              if (payload && payload.failed_results) {
                const failedCount = payload.failed_results;
                const deletedCount = payload.deleted_jobs || 0;
                notifySystem(
                  "Cleanup incomplete",
                  `Deleted ${deletedCount} items. ${failedCount} folders couldn't be removed.`,
                  "error"
                );
              } else {
                const deletedCount = payload && payload.deleted_jobs ? payload.deleted_jobs : count;
                notifySystem("History cleared", `Deleted ${deletedCount} items.`, "success");
              }
            } catch (error) {
              console.warn("Failed to clear history", error);
              const message = error instanceof Error ? error.message : "Failed to clear history.";
              notifySystem("Action failed", message, "error");
            } finally {
              await refreshState();
            }
          });
        }

        if (historyList) {
          historyList.addEventListener("click", async (event) => {
            const target = event.target;
            if (!(target instanceof Element)) {
              return;
            }
            const actionEl = target.closest("[data-action]");
            if (!actionEl) {
              return;
            }
            const action = actionEl.getAttribute("data-action");
            const row = actionEl.closest(".history-row");
            if (!row || !action) {
              return;
            }
            if (action === "view-log") {
              const details = row.querySelector(".job-details");
              if (details && !details.open) {
                details.open = true;
              }
              const log = row.querySelector("[data-log]");
              if (log) {
                log.scrollIntoView({ behavior: "smooth", block: "nearest" });
              }
            }
            if (action === "copy-filename") {
              const filename = actionEl.getAttribute("data-filename") || "";
              if (!filename) {
                return;
              }
              const success = await copyToClipboard(filename);
              if (success) {
                notifySystem("Copied to clipboard", "Filename copied.", "success");
              } else {
                notifySystem("Copy failed", "Unable to copy filename.", "error");
              }
            }
            if (action === "copy-preview") {
              const jobId = actionEl.getAttribute("data-job-id") || row.getAttribute("data-job-id");
              if (!jobId) {
                return;
              }
              await copyPreviewForJob(jobId, row);
            }
            if (action === "delete-history") {
              const jobId = row.getAttribute("data-job-id");
              if (!jobId) {
                return;
              }
              const summary = getHistoryRowSummary(row);
              if (!window.confirm(buildHistoryDeleteMessage(summary))) {
                return;
              }
              actionEl.setAttribute("disabled", "disabled");
              try {
                await deleteHistoryJob(jobId);
                notifySystem("History item deleted", "The history entry was removed.", "success");
              } catch (error) {
                console.warn("Failed to delete history item", error);
                const message = error instanceof Error ? error.message : "Failed to delete history item.";
                notifySystem("Action failed", message, "error");
              } finally {
                await refreshState();
              }
            }
            const menu = actionEl.closest(".job-menu");
            if (menu) {
              menu.removeAttribute("open");
            }
          });
        }

        function closeHistoryMenus(exceptMenu) {
          if (!historyList) {
            return;
          }
          historyList.querySelectorAll(".job-menu[open]").forEach((menu) => {
            if (exceptMenu && menu === exceptMenu) {
              return;
            }
            menu.removeAttribute("open");
          });
        }

        document.addEventListener("click", (event) => {
          const target = event.target;
          if (!(target instanceof Element)) {
            return;
          }
          const menu = target.closest(".job-menu");
          if (menu) {
            closeHistoryMenus(menu);
            return;
          }
          closeHistoryMenus(null);
        });

        hydrateTimestamps(document);
        hydrateElapsed(document);
        hydrateTimeMeta(document);
        wireHistoryDetails(historyList);

        setInterval(refreshState, 2500);
        refreshState();
      })();
    </script>
  </body>
</html>
