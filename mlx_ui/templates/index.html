<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Whisper WebUI (MLX)</title>
    <style>
      :root {
        --ink: #1d1b16;
        --ink-muted: #5d5d5d;
        --panel: #fff7ee;
        --accent: #d46a3e;
        --accent-strong: #8b3f1f;
        --shadow: 0 24px 60px rgba(29, 27, 22, 0.12);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Avenir Next", Avenir, "Gill Sans", sans-serif;
        color: var(--ink);
        background: radial-gradient(circle at top left, #f6e6d4, transparent 55%),
          radial-gradient(circle at bottom right, #cfe1f2, transparent 45%),
          #f5f1ea;
      }

      main {
        max-width: 980px;
        margin: 0 auto;
        padding: 48px 24px 64px;
      }

      .hero {
        display: flex;
        flex-wrap: wrap;
        gap: 24px;
        align-items: center;
        justify-content: space-between;
      }

      .eyebrow {
        text-transform: uppercase;
        letter-spacing: 0.18em;
        font-size: 0.72rem;
        color: var(--accent-strong);
      }

      h1 {
        margin: 8px 0 10px;
        font-size: clamp(2rem, 3vw, 3rem);
      }

      h2 {
        margin: 0;
        font-size: clamp(1.5rem, 2.4vw, 2rem);
        letter-spacing: -0.01em;
      }

      p {
        margin: 0;
        color: var(--ink-muted);
        line-height: 1.5;
      }

      .status-card {
        background: var(--panel);
        border: 1px solid #f1e2d2;
        border-radius: 16px;
        padding: 16px 20px;
        min-width: 180px;
        box-shadow: var(--shadow);
      }

      .status-label {
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.14em;
        color: var(--accent-strong);
      }

      .status {
        font-size: 1.4rem;
        font-weight: 700;
        margin: 6px 0;
      }

      .status-meta {
        font-size: 0.85rem;
        color: var(--ink-muted);
        margin: 0;
      }

      .tabs {
        margin-top: 32px;
      }

      .tablist {
        display: flex;
        gap: 12px;
        padding: 8px;
        border-radius: 14px;
        background: rgba(255, 255, 255, 0.7);
        box-shadow: 0 12px 30px rgba(29, 27, 22, 0.08);
      }

      .tab {
        appearance: none;
        border: none;
        background: transparent;
        padding: 10px 18px;
        border-radius: 10px;
        font-size: 1rem;
        font-weight: 600;
        color: var(--ink);
        cursor: pointer;
        text-decoration: none;
      }

      .tab.is-active {
        background: var(--accent);
        color: #fff;
        box-shadow: 0 12px 24px rgba(212, 106, 62, 0.35);
      }

      .tab:focus-visible {
        outline: 2px solid var(--accent-strong);
        outline-offset: 2px;
      }

      .panels {
        margin-top: 16px;
      }

      .panel {
        display: none;
        background: var(--panel);
        border: 1px solid #f1e2d2;
        border-radius: 18px;
        padding: 24px;
        box-shadow: var(--shadow);
      }

      .panel.is-active {
        display: block;
      }

      .panel > p {
        margin-top: 6px;
        margin-bottom: 18px;
      }

      .upload-card {
        margin-top: 18px;
        padding: 16px;
        border-radius: 14px;
        background: #fff;
        border: 1px solid #f4e6d8;
        display: grid;
        gap: 12px;
      }

      .upload-label {
        font-weight: 600;
      }

      .upload-input {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .upload-select {
        display: block;
        width: 100%;
      }

      .dropzone {
        border: 2px dashed #f0c7b1;
        border-radius: 14px;
        padding: 18px;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.8), rgba(255, 245, 238, 0.9));
        display: grid;
        gap: 6px;
        cursor: pointer;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      }

      .dropzone:focus-visible {
        outline: 2px solid var(--accent-strong);
        outline-offset: 2px;
      }

      .dropzone.is-active {
        border-color: var(--accent);
        background: #fff0e1;
        box-shadow: 0 14px 28px rgba(212, 106, 62, 0.18);
      }

      .dropzone.has-files {
        border-color: #e8b090;
      }

      .dropzone-title {
        font-weight: 600;
        font-size: 1rem;
      }

      .dropzone-subtitle {
        font-size: 0.9rem;
        color: var(--ink-muted);
      }

      .file-summary {
        font-size: 0.85rem;
        color: var(--ink-muted);
      }

      .file-list {
        display: grid;
        gap: 8px;
        margin: 0;
        padding: 0;
      }

      .file-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        background: #fff8f2;
        border: 1px solid #f1e2d2;
        border-radius: 10px;
        padding: 10px 12px;
      }

      .file-meta {
        display: grid;
        gap: 2px;
      }

      .file-name {
        font-weight: 600;
        font-size: 0.95rem;
      }

      .file-size {
        font-size: 0.82rem;
        color: var(--ink-muted);
      }

      .file-remove {
        appearance: none;
        border: 1px solid #f0c7b1;
        background: #fff;
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 0.8rem;
        cursor: pointer;
        color: var(--accent-strong);
      }

      .file-remove:hover {
        background: #fbe3d6;
      }

      .upload-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
        justify-content: space-between;
      }

      .cta {
        appearance: none;
        border: none;
        border-radius: 10px;
        padding: 10px 16px;
        background: var(--accent);
        color: #fff;
        font-weight: 600;
        cursor: pointer;
      }

      .cta:hover {
        background: var(--accent-strong);
      }

      .cta:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        background: #d9c1b6;
      }

      .hint {
        font-size: 0.85rem;
        color: var(--ink-muted);
      }

      .queue-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 16px;
        flex-wrap: wrap;
        margin-bottom: 6px;
      }

      .queue-summary {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .queue-header p {
        margin-top: 6px;
        font-size: 0.98rem;
      }

      .queue-count {
        font-size: 0.82rem;
        color: var(--ink-muted);
        background: #fff;
        border: 1px solid #f1e2d2;
        border-radius: 999px;
        padding: 4px 10px;
        white-space: nowrap;
      }

      .job-list {
        margin-top: 16px;
        display: grid;
        gap: 10px;
      }


      .job-row {
        display: flex;
        justify-content: space-between;
        gap: 16px;
        padding: 14px 16px;
        border-radius: 12px;
        background: #fff;
        border: 1px solid #f4e6d8;
        align-items: flex-start;
      }

      .job-row.is-running {
        border-color: var(--accent);
        background: #fff0e1;
        box-shadow: 0 16px 30px rgba(212, 106, 62, 0.18);
      }

      .job-icon {
        width: 32px;
        height: 32px;
        border-radius: 10px;
        background: #fff6ea;
        border: 1px solid #f1cbb8;
        display: grid;
        place-items: center;
        font-size: 1rem;
        color: var(--accent-strong);
        flex-shrink: 0;
      }

      .job-body {
        flex: 1;
        min-width: 0;
      }

      .job-name {
        font-weight: 600;
        font-size: 1.02rem;
      }

      .job-meta {
        font-size: 0.85rem;
        color: var(--ink-muted);
        margin-top: 2px;
      }

      .job-queue {
        margin-top: 6px;
        font-size: 0.78rem;
        color: var(--ink-muted);
        font-weight: 600;
      }

      .job-status {
        text-transform: uppercase;
        letter-spacing: 0.1em;
        font-size: 0.72rem;
        color: var(--accent-strong);
        align-self: center;
      }

      .job-elapsed {
        font-size: 0.75rem;
        color: var(--ink-muted);
        font-weight: 600;
      }

      .job-actions {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 6px;
        min-width: 92px;
      }

      .job-bin {
        appearance: none;
        border: 1px solid #f1cbb8;
        background: #fff3ea;
        color: #9f4b2a;
        border-radius: 8px;
        padding: 6px 10px;
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        cursor: pointer;
      }

      .job-bin:hover {
        background: #fbe3d6;
      }

      .job-bin:focus-visible {
        outline: 2px solid var(--accent-strong);
        outline-offset: 2px;
      }

      .job-bin:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .job-bin-icon {
        width: 16px;
        height: 16px;
        display: block;
        fill: currentColor;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .job-error {
        margin-top: 8px;
        padding: 8px 10px;
        background: #fff1f1;
        border: 1px solid #f4d2d2;
        border-radius: 8px;
        font-size: 0.82rem;
        color: #8b2f2f;
        white-space: pre-wrap;
      }

      .results {
        margin-top: 10px;
      }

      .result-label {
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--accent-strong);
      }

      .result-list {
        list-style: none;
        margin: 6px 0 0;
        padding: 0;
        display: grid;
        gap: 6px;
      }

      .result-item {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }

      .result-link {
        color: var(--accent-strong);
        text-decoration: none;
        font-weight: 600;
      }

      .result-link:hover {
        text-decoration: underline;
      }

      .result-link.is-text {
        color: var(--accent);
      }

      .result-action {
        font-size: 0.78rem;
        color: var(--ink-muted);
        text-decoration: none;
        border: 1px solid #f1e2d2;
        padding: 2px 8px;
        border-radius: 999px;
      }

      .result-action:hover {
        color: var(--accent-strong);
        border-color: var(--accent);
      }

      .result-empty {
        margin-top: 6px;
        font-size: 0.85rem;
        color: var(--ink-muted);
      }

      .placeholder {
        margin-top: 16px;
        padding-top: 16px;
        border-top: 1px dashed #e3d2c1;
        display: grid;
        gap: 10px;
      }

      .placeholder-row {
        padding: 12px 14px;
        border-radius: 10px;
        background: #fff;
        border: 1px solid #f4e6d8;
        color: var(--ink-muted);
      }

      .toast-stack {
        position: fixed;
        top: max(20px, env(safe-area-inset-top));
        right: max(20px, env(safe-area-inset-right));
        display: grid;
        gap: 10px;
        z-index: 1000;
        pointer-events: none;
      }

      .toast {
        --toast-bg: var(--panel);
        --toast-border: #f1e2d2;
        --toast-accent: var(--accent);
        --toast-muted: var(--ink-muted);

        min-width: min(320px, calc(100vw - 40px));
        max-width: 380px;
        padding: 10px 10px 8px;
        border-radius: 14px;
        border: 1px solid var(--toast-border);
        background: var(--toast-bg);
        box-shadow: var(--shadow);
        pointer-events: auto;
        opacity: 0;
        transform: translateY(-8px);
        transition: opacity 200ms ease, transform 200ms ease;
        display: grid;
        grid-template-columns: 20px 1fr auto;
        grid-template-areas:
          "icon header close"
          "body body body"
          "progress progress progress";
        column-gap: 10px;
        row-gap: 4px;
        align-items: start;
      }

      .toast.is-visible {
        opacity: 1;
        transform: translateY(0);
      }

      .toast.is-done {
        --toast-border: #cfe6d6;
        --toast-accent: #2f7d32;
      }

      .toast.is-failed {
        --toast-border: #f4d2d2;
        --toast-accent: #b3261e;
      }

      .toast__icon {
        grid-area: icon;
        width: 20px;
        height: 20px;
        margin-top: 1px;
        color: var(--toast-accent);
      }

      .toast__header {
        grid-area: header;
        display: flex;
        align-items: baseline;
        gap: 10px;
        min-width: 0;
      }

      .toast__title {
        font-size: 0.72rem;
        text-transform: uppercase;
        letter-spacing: 0.14em;
        font-weight: 700;
        color: var(--toast-accent);
        min-width: 0;
      }

      .toast__meta {
        font-size: 0.72rem;
        color: var(--toast-muted);
        white-space: nowrap;
        flex-shrink: 0;
      }

      .toast__body {
        grid-area: body;
        font-size: 0.88rem;
        font-weight: 600;
        color: var(--ink);
        min-width: 0;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .toast__dismiss {
        grid-area: close;
        appearance: none;
        border: 1px solid rgba(29, 27, 22, 0.12);
        background: rgba(255, 255, 255, 0.65);
        color: var(--ink-muted);
        width: 30px;
        height: 30px;
        border-radius: 10px;
        display: grid;
        place-items: center;
        cursor: pointer;
        justify-self: end;
      }

      .toast__dismiss:hover {
        border-color: var(--toast-accent);
        color: var(--toast-accent);
      }

      .toast__dismiss:focus-visible {
        outline: 2px solid var(--toast-accent);
        outline-offset: 2px;
      }

      .toast__progress {
        grid-area: progress;
        height: 2px;
        background: rgba(29, 27, 22, 0.1);
        border-radius: 999px;
        overflow: hidden;
      }

      .toast__progressBar {
        height: 100%;
        width: 100%;
        background: var(--toast-accent);
        transform-origin: left;
        animation: toastCountdown linear var(--toast-duration, 8000ms) forwards;
      }

      .toast.is-paused .toast__progressBar {
        animation-play-state: paused;
      }

      .toast.is-clickable {
        cursor: pointer;
      }

      .toast.is-clickable:hover {
        border-color: var(--toast-accent);
      }

      .toast.is-clickable:focus-within {
        outline: 2px solid var(--toast-accent);
        outline-offset: 2px;
      }

      @keyframes toastCountdown {
        from {
          transform: scaleX(1);
        }
        to {
          transform: scaleX(0);
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .toast {
          transition: none;
          transform: none;
        }

        .toast__progressBar {
          animation: none;
        }
      }

      @media (max-width: 720px) {
        main {
          padding: 32px 18px 48px;
        }

        .hero {
          flex-direction: column;
          align-items: flex-start;
        }

        .tablist {
          flex-direction: column;
          align-items: stretch;
        }

        .upload-actions {
          flex-direction: column;
          align-items: stretch;
        }

        .queue-header {
          flex-direction: column;
          align-items: flex-start;
        }

        .file-item {
          flex-direction: column;
          align-items: flex-start;
        }

        .file-remove {
          align-self: flex-start;
        }

        .job-row {
          flex-direction: column;
          align-items: flex-start;
        }

        .job-actions {
          flex-direction: row;
          align-items: center;
          justify-content: space-between;
          width: 100%;
        }

        .status-card {
          width: 100%;
        }

        .toast-stack {
          top: auto;
          right: max(16px, env(safe-area-inset-right));
          left: max(16px, env(safe-area-inset-left));
          bottom: max(16px, env(safe-area-inset-bottom));
        }

        .toast {
          min-width: auto;
          max-width: none;
          grid-template-columns: 20px 1fr auto;
          grid-template-areas:
            "icon header close"
            "body body body"
            "progress progress progress";
        }
      }
    </style>
  </head>
  <body>
    <main>
      <header class="hero">
        <div>
          <div class="eyebrow">Local-only transcription</div>
          <h1>Whisper WebUI (MLX)</h1>
          <p>Queue files for offline transcription. Upload and worker controls land here.</p>
        </div>
        <div class="status-card" aria-live="polite">
          <div class="status-label">Worker</div>
          <div class="status" id="worker-status">{{ worker.status }}</div>
          <p id="worker-detail">
            {% if worker.status == "Running" and worker.filename %}
              Running {{ worker.filename }}
            {% else %}
              Sequential queue, one job at a time.
            {% endif %}
          </p>
        </div>
      </header>

      <section class="tabs" aria-label="Main sections">
        <div class="tablist" role="tablist">
          <a
            class="tab is-active"
            role="tab"
            aria-selected="true"
            aria-controls="panel-queue"
            id="tab-queue"
            data-tab="queue"
            href="/?tab=queue"
          >
            Queue
          </a>
          <a
            class="tab"
            role="tab"
            aria-selected="false"
            aria-controls="panel-history"
            id="tab-history"
            data-tab="history"
            href="/?tab=history"
          >
            History
          </a>
          <a class="tab" href="/live">Live</a>
        </div>

        <div class="panels">
          <section
            class="panel is-active"
            role="tabpanel"
            id="panel-queue"
            aria-labelledby="tab-queue"
            data-panel="queue"
          >
            <div class="queue-header">
              <div>
                <h2>Queue</h2>
                <p>Upload files to start a sequential transcription run.</p>
              </div>
              <div class="queue-summary">
                <div class="queue-count" data-queue-count>
                  {{ queued_count }} {{ "file" if queued_count == 1 else "files" }} queued
                </div>
              </div>
            </div>
            <form class="upload-card" action="/upload" method="post" enctype="multipart/form-data">
              <label class="upload-label" for="file-input">Select audio or video files</label>
              <input
                id="file-input"
                class="upload-input"
                type="file"
                name="files"
                multiple
                required
                accept="audio/*,video/*"
              >
              <label
                class="dropzone"
                id="dropzone"
                tabindex="0"
                role="button"
                for="file-input"
                aria-describedby="dropzone-hint"
              >
                <div class="dropzone-title">Drag & drop files here</div>
                <div class="dropzone-subtitle" id="dropzone-hint">
                  or click to browse audio/video files
                </div>
              </label>
              <div class="file-summary" id="file-summary" aria-live="polite">No files selected yet.</div>
              <div class="file-list" id="file-list" aria-live="polite"></div>
              <div class="upload-actions">
                <button class="cta" id="upload-submit" type="submit">Queue uploads</button>
                <span class="hint">Files stay local in data/uploads.</span>
              </div>
            </form>
            <div class="job-list" aria-live="polite" id="queue-list">
              {% set offset = 1 if queue_jobs | selectattr("status", "equalto", "running") | list | length > 0 else 0 %}
              {% set queue_index = namespace(value=0) %}
              {% for job in queue_jobs %}
                {% set is_running = job.status == "running" %}
                {% if job.status == "queued" %}
                  {% set queue_index.value = queue_index.value + 1 %}
                {% endif %}
                <div class="job-row{% if is_running %} is-running{% endif %}">
                  {% if is_running %}
                    <div class="job-icon" aria-hidden="true">⏳</div>
                  {% endif %}
                  <div class="job-body">
                    <div class="job-name">{{ job.filename }}</div>
                    <div class="job-meta" data-iso="{{ job.created_at }}" data-label="Added">
                      Added {{ job.created_at }}
                    </div>
                    {% if job.started_at %}
                      <div class="job-meta" data-iso="{{ job.started_at }}" data-label="Started">
                        Started {{ job.started_at }}
                      </div>
                    {% endif %}
                    {% if job.status == "queued" %}
                      {% set queue_position = queue_index.value + offset %}
                      {% set items_ahead = queue_position - 1 %}
                      <div class="job-queue">
                        {{ items_ahead }} {{ "item" if items_ahead == 1 else "items" }} ahead
                      </div>
                    {% endif %}
                  </div>
                  <div class="job-actions">
                    <div class="job-status">{{ job.status }}</div>
                    {% if is_running and job.started_at %}
                      <div class="job-elapsed" data-started-at="{{ job.started_at }}"></div>
                    {% endif %}
                    {% if job.status == "queued" %}
                      <button
                        class="job-bin"
                        type="button"
                        data-job-id="{{ job.id }}"
                        aria-label="Remove from queue"
                        title="Remove from queue"
                      >
                        <svg class="job-bin-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                          <path d="M9 3h6l1 2h5v2H3V5h5l1-2zm-2 6h2v9H7V9zm4 0h2v9h-2V9zm4 0h2v9h-2V9z"></path>
                        </svg>
                        <span class="sr-only">Remove</span>
                      </button>
                    {% endif %}
                  </div>
                </div>
              {% endfor %}
            </div>
            <div class="placeholder" id="queue-placeholder"{% if queue_jobs %} style="display: none;"{% endif %}>
              <div class="placeholder-row">No jobs queued yet.</div>
              <div class="placeholder-row">Waiting for uploads.</div>
            </div>
          </section>

          <section
            class="panel"
            role="tabpanel"
            id="panel-history"
            aria-labelledby="tab-history"
            data-panel="history"
          >
            <h2>History</h2>
            <p>Completed jobs will appear here with download links.</p>
            <div class="job-list" aria-live="polite" id="history-list">
              {% for job in history_jobs %}
                <div class="job-row">
                  <div class="job-body">
                    <div class="job-name">{{ job.filename }}</div>
                    <div class="job-meta" data-iso="{{ job.created_at }}" data-label="Added">
                      Added {{ job.created_at }}
                    </div>
                    {% if job.started_at %}
                      <div class="job-meta" data-iso="{{ job.started_at }}" data-label="Started">
                        Started {{ job.started_at }}
                      </div>
                    {% endif %}
                    {% if job.completed_at %}
                      <div class="job-meta" data-iso="{{ job.completed_at }}" data-label="Completed">
                        Completed {{ job.completed_at }}
                      </div>
                    {% endif %}
                    {% if job.status == "failed" and job.error_message %}
                      <div class="job-error">{{ job.error_message }}</div>
                    {% endif %}
                    <div class="results">
                      <div class="result-label">Results</div>
                      {% set results = results_by_job.get(job.id, []) %}
                      {% if results %}
                        <ul class="result-list">
                          {% for result in results %}
                            <li class="result-item">
                              <a
                                class="result-link{% if result.endswith('.txt') %} is-text{% endif %}"
                                href="/results/{{ job.id }}/{{ result }}"
                                target="_blank"
                                rel="noopener"
                              >
                                {{ result }}
                              </a>
                              <a
                                class="result-action"
                                href="/results/{{ job.id }}/{{ result }}"
                                download="{{ result }}"
                              >
                                Download
                              </a>
                            </li>
                          {% endfor %}
                        </ul>
                      {% else %}
                        <div class="result-empty">No results yet.</div>
                      {% endif %}
                    </div>
                  </div>
                  <div class="job-actions">
                    <div class="job-status">{{ job.status }}</div>
                  </div>
                </div>
              {% endfor %}
            </div>
            <div class="placeholder" id="history-placeholder"{% if history_jobs %} style="display: none;"{% endif %}>
              <div class="placeholder-row">No completed jobs yet.</div>
              <div class="placeholder-row">Check back after a run.</div>
            </div>
          </section>
        </div>
      </section>
    </main>
    <div
      class="toast-stack"
      id="toast-stack"
      aria-live="polite"
      aria-atomic="false"
      aria-relevant="additions"
    ></div>

    <script>
      (function () {
        const tabs = Array.from(document.querySelectorAll("[data-tab]"));
        const panels = document.querySelectorAll("[data-panel]");
        if (!tabs.length) {
          return;
        }
        const tabNames = new Set(tabs.map((tab) => tab.dataset.tab));
        const TAB_STORAGE_KEY = "mlx-ui:last-tab";

        function updateUrl(tabName, replace) {
          const url = new URL(window.location.href);
          url.searchParams.set("tab", tabName);
          if (!replace && url.toString() === window.location.href) {
            return;
          }
          const state = { tab: tabName };
          if (replace) {
            history.replaceState(state, "", url);
          } else {
            history.pushState(state, "", url);
          }
        }

        function activate(tabName, options = {}) {
          const { updateHistory = false, replaceHistory = false } = options;
          if (!tabNames.has(tabName)) {
            return;
          }
          tabs.forEach((tab) => {
            const isActive = tab.dataset.tab === tabName;
            tab.classList.toggle("is-active", isActive);
            tab.setAttribute("aria-selected", isActive ? "true" : "false");
          });

          panels.forEach((panel) => {
            panel.classList.toggle("is-active", panel.dataset.panel === tabName);
          });

          try {
            localStorage.setItem(TAB_STORAGE_KEY, tabName);
          } catch (error) {
            // localStorage may be disabled; UI should still work.
          }

          if (updateHistory) {
            updateUrl(tabName, replaceHistory);
          }
        }

        function tabFromUrl() {
          const initialTab = new URLSearchParams(window.location.search).get("tab");
          return tabNames.has(initialTab) ? initialTab : null;
        }

        let storedTab = null;
        try {
          const candidate = localStorage.getItem(TAB_STORAGE_KEY);
          storedTab = tabNames.has(candidate) ? candidate : null;
        } catch (error) {
          storedTab = null;
        }

        const initialFromUrl = tabFromUrl();
        const initialTab = initialFromUrl || storedTab || "queue";
        activate(initialTab, {
          updateHistory: !initialFromUrl,
          replaceHistory: true
        });

        tabs.forEach((tab) => {
          tab.addEventListener("click", (event) => {
            if (
              event.defaultPrevented ||
              event.button !== 0 ||
              event.metaKey ||
              event.ctrlKey ||
              event.shiftKey ||
              event.altKey
            ) {
              return;
            }
            event.preventDefault();
            activate(tab.dataset.tab, { updateHistory: true });
          });
        });

        window.addEventListener("popstate", () => {
          const tabName = tabFromUrl() || "queue";
          activate(tabName);
        });

        const queueList = document.getElementById("queue-list");
        const historyList = document.getElementById("history-list");
        const queuePlaceholder = document.getElementById("queue-placeholder");
        const historyPlaceholder = document.getElementById("history-placeholder");
        const workerStatus = document.getElementById("worker-status");
        const workerDetail = document.getElementById("worker-detail");
        const queueCountEls = document.querySelectorAll("[data-queue-count]");
        const toastStack = document.getElementById("toast-stack");
        const uploadForm = document.querySelector(".upload-card");
        const fileInput = document.getElementById("file-input");
        const dropzone = document.getElementById("dropzone");
        const fileList = document.getElementById("file-list");
        const fileSummary = document.getElementById("file-summary");
        const uploadSubmit = document.getElementById("upload-submit");
        const notifiedJobIds = new Set();
        let notificationsSeeded = false;
        const ICON_CHECK = `
          <svg viewBox="0 0 24 24" width="22" height="22" aria-hidden="true" focusable="false">
            <path fill="currentColor" d="M9.2 16.6 4.9 12.3l1.4-1.4 2.9 2.9 8.6-8.6 1.4 1.4z"></path>
          </svg>
        `;
        const ICON_ERROR = `
          <svg viewBox="0 0 24 24" width="22" height="22" aria-hidden="true" focusable="false">
            <path fill="currentColor" d="M12 2 1 21h22L12 2zm1 15h-2v-2h2v2zm0-4h-2V9h2v4z"></path>
          </svg>
        `;
        const ICON_X = `
          <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true" focusable="false">
            <path fill="currentColor" d="M18.3 5.7 12 12l6.3 6.3-1.4 1.4L10.6 13.4 4.3 19.7 2.9 18.3 9.2 12 2.9 5.7 4.3 4.3l6.3 6.3 6.3-6.3z"></path>
          </svg>
        `;
        const relativeFormatter =
          typeof Intl !== "undefined" && Intl.RelativeTimeFormat
            ? new Intl.RelativeTimeFormat(undefined, { numeric: "auto", style: "short" })
            : null;

        function escapeHtml(value) {
          return String(value)
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#39;");
        }

        const pendingFiles = [];
        let syncingInput = false;
        let dragDepth = 0;

        function formatBytes(bytes) {
          if (!Number.isFinite(bytes) || bytes <= 0) {
            return "0 B";
          }
          const units = ["B", "KB", "MB", "GB", "TB"];
          let value = bytes;
          let unitIndex = 0;
          while (value >= 1024 && unitIndex < units.length - 1) {
            value /= 1024;
            unitIndex += 1;
          }
          const precision = value >= 10 || unitIndex === 0 ? 0 : 1;
          return `${value.toFixed(precision)} ${units[unitIndex]}`;
        }

        function buildFileKey(file) {
          return `${file.name}::${file.size}::${file.lastModified}`;
        }

        function syncInputFiles(files) {
          if (!fileInput) {
            return;
          }
          if (typeof DataTransfer === "undefined") {
            return;
          }
          const transfer = new DataTransfer();
          files.forEach((file) => transfer.items.add(file));
          syncingInput = true;
          fileInput.files = transfer.files;
          syncingInput = false;
        }

        function renderFileList() {
          if (!fileList || !fileSummary || !uploadSubmit || !dropzone) {
            return;
          }
          fileList.innerHTML = "";
          if (pendingFiles.length === 0) {
            fileSummary.textContent = "No files selected yet.";
            uploadSubmit.disabled = true;
            dropzone.classList.remove("has-files");
            return;
          }
          const totalBytes = pendingFiles.reduce((sum, file) => sum + (file.size || 0), 0);
          const label = pendingFiles.length === 1 ? "file" : "files";
          fileSummary.textContent = `${pendingFiles.length} ${label} ready · ${formatBytes(totalBytes)}`;
          uploadSubmit.disabled = false;
          dropzone.classList.add("has-files");

          const fragment = document.createDocumentFragment();
          pendingFiles.forEach((file, index) => {
            const item = document.createElement("div");
            item.className = "file-item";

            const meta = document.createElement("div");
            meta.className = "file-meta";

            const name = document.createElement("div");
            name.className = "file-name";
            name.textContent = file.name || "Untitled file";

            const size = document.createElement("div");
            size.className = "file-size";
            size.textContent = formatBytes(file.size || 0);

            meta.appendChild(name);
            meta.appendChild(size);

            const remove = document.createElement("button");
            remove.className = "file-remove";
            remove.type = "button";
            remove.dataset.removeIndex = String(index);
            remove.setAttribute("aria-label", `Remove ${file.name || "file"}`);
            remove.textContent = "Remove";

            item.appendChild(meta);
            item.appendChild(remove);
            fragment.appendChild(item);
          });
          fileList.appendChild(fragment);
        }

        function setPendingFiles(nextFiles) {
          pendingFiles.splice(0, pendingFiles.length, ...nextFiles);
          syncInputFiles(pendingFiles);
          renderFileList();
        }

        function mergeFiles(existing, incoming) {
          const merged = [...existing];
          const seen = new Set(existing.map(buildFileKey));
          incoming.forEach((file) => {
            const key = buildFileKey(file);
            if (!seen.has(key)) {
              merged.push(file);
              seen.add(key);
            }
          });
          return merged;
        }

        function isFileDrag(event) {
          if (!event.dataTransfer) {
            return false;
          }
          const types = Array.from(event.dataTransfer.types || []);
          if (types.includes("Files") || types.includes("public.file-url")) {
            return true;
          }
          if (event.dataTransfer.files && event.dataTransfer.files.length > 0) {
            return true;
          }
          if (event.dataTransfer.items && event.dataTransfer.items.length > 0) {
            return true;
          }
          return false;
        }

        function formatRelative(date) {
          if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
            return "";
          }
          const diffMs = date.getTime() - Date.now();
          const absMs = Math.abs(diffMs);
          if (absMs < 45000) {
            return "just now";
          }
          const units = [
            ["year", 31536000000],
            ["month", 2592000000],
            ["day", 86400000],
            ["hour", 3600000],
            ["minute", 60000],
          ];
          for (const [unit, unitMs] of units) {
            if (absMs >= unitMs) {
              const value = Math.round(diffMs / unitMs);
              if (relativeFormatter) {
                return relativeFormatter.format(value, unit);
              }
              const rounded = Math.abs(value);
              return `${rounded} ${unit}${rounded === 1 ? "" : "s"} ${
                value < 0 ? "ago" : "from now"
              }`;
            }
          }
          const seconds = Math.round(diffMs / 1000);
          if (relativeFormatter) {
            return relativeFormatter.format(seconds, "second");
          }
          const absSeconds = Math.abs(seconds);
          return `${absSeconds} sec ${seconds < 0 ? "ago" : "from now"}`;
        }

        function formatTimestamp(isoString) {
          if (!isoString) {
            return { absolute: "", relative: "" };
          }
          const date = new Date(isoString);
          if (Number.isNaN(date.getTime())) {
            return { absolute: isoString, relative: "" };
          }
          let absolute = "";
          try {
            absolute = date.toLocaleString([], {
              year: "numeric",
              month: "short",
              day: "numeric",
              hour: "2-digit",
              minute: "2-digit",
            });
          } catch (error) {
            absolute = date.toLocaleString();
          }
          return { absolute, relative: formatRelative(date) };
        }

        function formatDuration(ms) {
          const totalSeconds = Math.max(0, Math.floor(ms / 1000));
          const hours = Math.floor(totalSeconds / 3600);
          const minutes = Math.floor((totalSeconds % 3600) / 60);
          const seconds = totalSeconds % 60;
          const paddedMinutes = String(minutes).padStart(2, "0");
          const paddedSeconds = String(seconds).padStart(2, "0");
          if (hours > 0) {
            return `${String(hours).padStart(2, "0")}:${paddedMinutes}:${paddedSeconds}`;
          }
          return `${paddedMinutes}:${paddedSeconds}`;
        }

        function formatElapsed(isoString) {
          if (!isoString) {
            return "";
          }
          const startedAt = new Date(isoString);
          if (Number.isNaN(startedAt.getTime())) {
            return "";
          }
          return formatDuration(Date.now() - startedAt.getTime());
        }

        function hydrateTimestamps(root) {
          const scope = root || document;
          scope.querySelectorAll("[data-iso][data-label]").forEach((element) => {
            const isoString = element.getAttribute("data-iso");
            const label = element.getAttribute("data-label") || "";
            const { absolute, relative } = formatTimestamp(isoString);
            if (!absolute) {
              return;
            }
            const relativeText = relative ? ` · ${relative}` : "";
            element.textContent = `${label} ${absolute}${relativeText}`;
          });
        }

        function hydrateElapsed(root) {
          const scope = root || document;
          scope.querySelectorAll("[data-started-at]").forEach((element) => {
            const isoString = element.getAttribute("data-started-at");
            const elapsed = formatElapsed(isoString);
            element.textContent = elapsed ? `Running ${elapsed}` : "";
          });
        }

        function updateQueueCount(count) {
          const label = count === 1 ? "file" : "files";
          queueCountEls.forEach((element) => {
            element.textContent = `${count} ${label} queued`;
          });
        }

        if (uploadForm && fileInput && dropzone && fileList && fileSummary && uploadSubmit) {
          renderFileList();

          fileInput.addEventListener("change", () => {
            if (syncingInput) {
              return;
            }
            const nextFiles = Array.from(fileInput.files || []);
            setPendingFiles(nextFiles);
          });

          dropzone.addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              fileInput.click();
            }
          });

          dropzone.addEventListener("dragenter", (event) => {
            if (!isFileDrag(event)) {
              return;
            }
            event.preventDefault();
            dragDepth += 1;
            dropzone.classList.add("is-active");
          });

          dropzone.addEventListener("dragover", (event) => {
            if (!isFileDrag(event)) {
              return;
            }
            event.preventDefault();
          });

          dropzone.addEventListener("dragleave", (event) => {
            if (!isFileDrag(event)) {
              return;
            }
            dragDepth = Math.max(0, dragDepth - 1);
            if (dragDepth === 0) {
              dropzone.classList.remove("is-active");
            }
          });

          dropzone.addEventListener("drop", (event) => {
            if (!isFileDrag(event)) {
              return;
            }
            event.preventDefault();
            dragDepth = 0;
            dropzone.classList.remove("is-active");
            const droppedFiles = Array.from(event.dataTransfer.files || []);
            if (droppedFiles.length === 0) {
              return;
            }
            setPendingFiles(mergeFiles(pendingFiles, droppedFiles));
          });

          fileList.addEventListener("click", (event) => {
            const target = event.target.closest("[data-remove-index]");
            if (!target) {
              return;
            }
            const index = Number(target.dataset.removeIndex);
            if (Number.isNaN(index)) {
              return;
            }
            const nextFiles = pendingFiles.slice();
            nextFiles.splice(index, 1);
            setPendingFiles(nextFiles);
          });
        }

        function buildResults(jobId, results) {
          if (!results || results.length === 0) {
            return '<div class="result-empty">No results yet.</div>';
          }
          const encodedJobId = encodeURIComponent(jobId);
          const items = results
            .map((result) => {
              const encodedResult = encodeURIComponent(result);
              const safeResult = escapeHtml(result);
              const isText = result.endsWith(".txt");
              const textClass = isText ? " is-text" : "";
              return `
                <li class="result-item">
                  <a
                    class="result-link${textClass}"
                    href="/results/${encodedJobId}/${encodedResult}"
                    target="_blank"
                    rel="noopener"
                  >
                    ${safeResult}
                  </a>
                  <a
                    class="result-action"
                    href="/results/${encodedJobId}/${encodedResult}"
                    download="${safeResult}"
                  >
                    Download
                  </a>
                </li>
              `;
            })
            .join("");
          return `<ul class="result-list">${items}</ul>`;
        }

        function buildMetaLine(label, isoString) {
          if (!isoString) {
            return "";
          }
          return `
            <div class="job-meta" data-iso="${escapeHtml(isoString)}" data-label="${escapeHtml(
              label
            )}"></div>
          `;
        }

        function buildMetaLines(job) {
          const lines = [buildMetaLine("Added", job.created_at)];
          if (job.started_at) {
            lines.push(buildMetaLine("Started", job.started_at));
          }
          if (job.completed_at) {
            lines.push(buildMetaLine("Completed", job.completed_at));
          }
          return lines.join("");
        }

        function buildActions(job, isHistory, extra) {
          const status = `<div class="job-status">${escapeHtml(job.status)}</div>`;
          const extraBlock = extra || "";
          if (isHistory) {
            return `<div class="job-actions">${status}${extraBlock}</div>`;
          }
          const canDelete = job.status === "queued";
          const binButton = canDelete
            ? `
              <button
                class="job-bin"
                type="button"
                data-job-id="${escapeHtml(job.id)}"
                aria-label="Remove from queue"
                title="Remove from queue"
              >
                <svg class="job-bin-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                  <path d="M9 3h6l1 2h5v2H3V5h5l1-2zm-2 6h2v9H7V9zm4 0h2v9h-2V9zm4 0h2v9h-2V9z"></path>
                </svg>
                <span class="sr-only">Remove</span>
              </button>
            `
            : "";
          return `<div class="job-actions">${status}${extraBlock}${binButton}</div>`;
        }

        function buildQueueLine(position) {
          if (!position) {
            return "";
          }
          const itemsAhead = Math.max(position - 1, 0);
          const label = itemsAhead === 1 ? "item" : "items";
          return `<div class="job-queue">${itemsAhead} ${label} ahead</div>`;
        }

        function buildJobRow(job, options) {
          const opts = options || {};
          const isHistory = Boolean(opts.isHistory);
          const isRunning = Boolean(opts.isRunning);
          const queuePosition = opts.queuePosition || 0;
          const icon = isRunning ? '<div class="job-icon" aria-hidden="true">⏳</div>' : "";
          const metaLines = buildMetaLines(job);
          const queueLine = buildQueueLine(queuePosition);
          const errorBlock =
            isHistory && job.status === "failed" && job.error_message
              ? `<div class="job-error">${escapeHtml(job.error_message)}</div>`
              : "";
          const results =
            isHistory
              ? `
                <div class="results">
                  <div class="result-label">Results</div>
                  ${buildResults(job.id, (opts.resultsByJob || {})[job.id] || [])}
                </div>
              `
              : "";
          const elapsed =
            isRunning && job.started_at
              ? `<div class="job-elapsed" data-started-at="${escapeHtml(job.started_at)}"></div>`
              : "";
          const actions = buildActions(job, isHistory, elapsed);
          return `
            <div class="job-row${isRunning ? " is-running" : ""}">
              ${icon}
              <div class="job-body">
                <div class="job-name">${escapeHtml(job.filename)}</div>
                ${metaLines}
                ${queueLine}
                ${errorBlock}
                ${results}
              </div>
              ${actions}
            </div>
          `;
        }

        function buildToast(job, resultsByJob, opts) {
          if (!toastStack) {
            return;
          }
          const options = opts || {};
          const isFailed = job.status === "failed";
          const duration = options.duration || (isFailed ? 14000 : 9000);

          const toast = document.createElement("div");
          toast.className = `toast ${isFailed ? "is-failed" : "is-done"}`;
          toast.style.setProperty("--toast-duration", `${duration}ms`);
          toast.setAttribute("role", isFailed ? "alert" : "status");
          toast.setAttribute("aria-atomic", "true");
          if (options.clickable) {
            toast.classList.add("is-clickable");
            toast.setAttribute("tabindex", "0");
          }

          const icon = document.createElement("div");
          icon.className = "toast__icon";
          icon.innerHTML = isFailed ? ICON_ERROR : ICON_CHECK;

          const header = document.createElement("div");
          header.className = "toast__header";

          const title = document.createElement("div");
          title.className = "toast__title";
          title.textContent =
            options.title ||
            (isFailed ? "Transcription failed" : "Transcription complete");

          const meta = document.createElement("div");
          meta.className = "toast__meta";
          if (job.completed_at && options.showTime !== false) {
            try {
              meta.textContent = new Date(job.completed_at).toLocaleTimeString([], {
                hour: "2-digit",
                minute: "2-digit",
              });
            } catch (error) {
              meta.textContent = "";
            }
          }

          header.appendChild(title);
          if (meta.textContent) {
            header.appendChild(meta);
          }

          const body = document.createElement("div");
          body.className = "toast__body";
          const bodyText = options.body || job.filename || "Unknown file";
          body.textContent = bodyText;
          body.title = bodyText;

          const dismiss = document.createElement("button");
          dismiss.className = "toast__dismiss";
          dismiss.type = "button";
          dismiss.setAttribute("aria-label", "Dismiss notification");
          dismiss.innerHTML = ICON_X;

          const progress = document.createElement("div");
          progress.className = "toast__progress";
          const bar = document.createElement("div");
          bar.className = "toast__progressBar";
          progress.appendChild(bar);

          const toastLimit = 4;
          while (toastStack.children.length >= toastLimit) {
            toastStack.removeChild(toastStack.firstElementChild);
          }

          toast.appendChild(icon);
          toast.appendChild(header);
          toast.appendChild(dismiss);
          toast.appendChild(body);
          toast.appendChild(progress);
          toastStack.appendChild(toast);
          requestAnimationFrame(() => {
            toast.classList.add("is-visible");
          });

          let timeoutId = null;
          let remaining = duration;
          let startedAt = performance.now();

          function cleanup() {
            window.removeEventListener("keydown", onKeyDown);
          }

          function dismissToast() {
            window.clearTimeout(timeoutId);
            timeoutId = null;
            toast.classList.remove("is-visible");
            cleanup();
            window.setTimeout(() => toast.remove(), 200);
          }

          function schedule(ms) {
            window.clearTimeout(timeoutId);
            startedAt = performance.now();
            timeoutId = window.setTimeout(dismissToast, ms);
          }

          function pause() {
            if (!timeoutId) {
              return;
            }
            const elapsed = performance.now() - startedAt;
            remaining = Math.max(0, remaining - elapsed);
            window.clearTimeout(timeoutId);
            timeoutId = null;
            toast.classList.add("is-paused");
          }

          function resume() {
            if (timeoutId) {
              return;
            }
            toast.classList.remove("is-paused");
            if (remaining <= 0) {
              dismissToast();
              return;
            }
            schedule(remaining);
          }

          function onKeyDown(event) {
            if (event.key === "Escape") {
              if (toastStack && toastStack.lastElementChild === toast) {
                dismissToast();
              }
            }
          }

          dismiss.addEventListener("click", (event) => {
            event.stopPropagation();
            dismissToast();
          });
          toast.addEventListener("mouseenter", pause);
          toast.addEventListener("mouseleave", resume);
          toast.addEventListener("focusin", pause);
          toast.addEventListener("focusout", resume);
          window.addEventListener("keydown", onKeyDown);

          toast.addEventListener("click", () => {
            if (!options.clickable) {
              return;
            }
            window.location.href = options.link || "/?tab=history";
          });

          toast.addEventListener("keydown", (event) => {
            if (!options.clickable) {
              return;
            }
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              window.location.href = options.link || "/?tab=history";
            }
          });

          schedule(remaining);
        }

        function handleNotifications(history, resultsByJob) {
          const completed = (history || []).filter(
            (job) => job.status === "done" || job.status === "failed"
          );
          if (!notificationsSeeded) {
            completed.forEach((job) => notifiedJobIds.add(job.id));
            notificationsSeeded = true;
            return;
          }
          completed.forEach((job) => {
            if (!notifiedJobIds.has(job.id)) {
              notifiedJobIds.add(job.id);
              buildToast(job, resultsByJob, { clickable: true });
            }
          });
        }

        function notifySystem(titleText, bodyText, kind) {
          const isError = kind === "error";
          buildToast(
            {
              id: `system-${Date.now()}`,
              status: isError ? "failed" : "done",
              filename: bodyText,
              completed_at: new Date().toISOString(),
            },
            {},
            {
              title: titleText,
              body: bodyText,
              duration: isError ? 14000 : 8000,
              showTime: false,
              clickable: false,
            }
          );
        }

        function renderQueue(listEl, placeholderEl, jobs) {
          if (!listEl || !placeholderEl) {
            return;
          }
          if (!jobs || jobs.length === 0) {
            listEl.innerHTML = "";
            placeholderEl.style.display = "grid";
            return;
          }
          placeholderEl.style.display = "none";
          const hasRunning = jobs.some((job) => job.status === "running");
          let queuedIndex = 0;
          const rendered = [];
          for (const job of jobs) {
            const isRunning = job.status === "running";
            let queuePosition = 0;
            if (job.status === "queued") {
              queuedIndex += 1;
              queuePosition = queuedIndex + (hasRunning ? 1 : 0);
            }
            rendered.push(
              buildJobRow(job, {
                queuePosition,
                isHistory: false,
                isRunning,
              })
            );
          }
          listEl.innerHTML = rendered.join("");
          hydrateTimestamps(listEl);
          hydrateElapsed(listEl);
        }

        function renderHistory(listEl, placeholderEl, jobs, resultsByJob) {
          if (!listEl || !placeholderEl) {
            return;
          }
          if (!jobs || jobs.length === 0) {
            listEl.innerHTML = "";
            placeholderEl.style.display = "grid";
            return;
          }
          placeholderEl.style.display = "none";
          listEl.innerHTML = jobs
            .map((job) => buildJobRow(job, { isHistory: true, resultsByJob }))
            .join("");
          hydrateTimestamps(listEl);
        }

        async function refreshState() {
          try {
            const response = await fetch("/api/state", { cache: "no-store" });
            if (!response.ok) {
              return;
            }
            const payload = await response.json();
            const resultsByJob = payload.results_by_job || {};
            const queue = payload.queue || [];
            renderQueue(queueList, queuePlaceholder, queue);
            renderHistory(historyList, historyPlaceholder, payload.history || [], resultsByJob);
            handleNotifications(payload.history || [], resultsByJob);
            updateQueueCount(queue.filter((job) => job.status === "queued").length);
            if (payload.worker && workerStatus && workerDetail) {
              workerStatus.textContent = payload.worker.status || "Idle";
              if (payload.worker.status === "Running" && payload.worker.filename) {
                const elapsed = formatElapsed(payload.worker.started_at);
                const suffix = elapsed ? ` · ${elapsed}` : "";
                workerDetail.textContent = `Running ${payload.worker.filename}${suffix}`;
              } else {
                workerDetail.textContent = "Sequential queue, one job at a time.";
              }
            }
          } catch (error) {
            console.warn("Failed to refresh state", error);
          }
        }

        async function deleteQueuedJob(jobId) {
          const response = await fetch(`/api/jobs/${encodeURIComponent(jobId)}`, {
            method: "DELETE",
          });
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(errorText || "Failed to remove job.");
          }
        }

        if (queueList) {
          queueList.addEventListener("click", async (event) => {
            const target = event.target;
            if (!(target instanceof Element)) {
              return;
            }
            const button = target.closest(".job-bin");
            if (!button) {
              return;
            }
            const jobId = button.getAttribute("data-job-id");
            if (!jobId) {
              return;
            }
            if (!window.confirm("Remove this job from the queue?")) {
              return;
            }
            button.setAttribute("disabled", "disabled");
            try {
              await deleteQueuedJob(jobId);
            } catch (error) {
              console.warn("Failed to remove queued job", error);
              notifySystem("Action failed", "Failed to remove queued job.", "error");
            } finally {
              await refreshState();
            }
          });
        }

        hydrateTimestamps(document);
        hydrateElapsed(document);

        setInterval(refreshState, 2500);
        refreshState();
      })();
    </script>
  </body>
</html>
